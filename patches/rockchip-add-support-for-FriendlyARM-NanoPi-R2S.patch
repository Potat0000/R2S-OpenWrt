From f70064a8feb0e4156665dba2e589dbc2c0607eb2 Mon Sep 17 00:00:00 2001
From: Jayantajit Gogoi <jayanta.gogoi525@gmail.com>
Date: Wed, 24 Jun 2020 03:37:23 +0000
Subject: [PATCH] rockchip: add support for FriendlyARM NanoPi R2S

- forum discussion: https://forum.openwrt.org/t/nanopi-r2s-is-a-great-openwrt-device/65374/79?u=jayanta525

Instruction:

- Check README for CI/CD builds
- LAN: rtl8153
- WAN: rtl8211E

ToDo:

- Wireless Dongle Drivers

Signed-off-by: Jayantajit Gogoi <jayanta.gogoi525@gmail.com>
---
 package/boot/uboot-rockchip/Makefile          |    9 +
 .../patches/005-add-support-nanopi-r2s.patch  |  792 ++++++++
 ...006-add-support-nanopi-r2s-defconfig.patch |  149 ++
 .../patches/009-add-set-eth1-addr.patch       |   16 +
 .../armv8/base-files/etc/board.d/01_leds      |   18 +
 .../armv8/base-files/etc/board.d/02_network   |    3 +
 target/linux/rockchip/armv8/config-5.4        |   19 +-
 target/linux/rockchip/image/armv8.mk          |   10 +
 .../001-add-rk3328-dmc-driver.patch           | 1796 +++++++++++++++++
 .../003-add-nanopi-r2s-support.patch          |  780 +++++++
 .../003-nanopi-r2s-kernel-patches.patch       |  551 +++++
 .../010-nanopi-r2s-rtl8152-leds.patch         |   36 +
 .../011-nanopi-r2s-mac-frfom-dt.patch         |   40 +
 15 files changed, 4336 insertions(+), 15 deletions(-)
 create mode 100644 package/boot/uboot-rockchip/patches/005-add-support-nanopi-r2s.patch
 create mode 100644 package/boot/uboot-rockchip/patches/006-add-support-nanopi-r2s-defconfig.patch
 create mode 100644 package/boot/uboot-rockchip/patches/009-add-set-eth1-addr.patch
 create mode 100755 target/linux/rockchip/armv8/base-files/etc/board.d/01_leds
 create mode 100644 target/linux/rockchip/patches-5.4/001-add-rk3328-dmc-driver.patch
 create mode 100644 target/linux/rockchip/patches-5.4/003-add-nanopi-r2s-support.patch
 create mode 100644 target/linux/rockchip/patches-5.4/003-nanopi-r2s-kernel-patches.patch
 create mode 100644 target/linux/rockchip/patches-5.4/010-nanopi-r2s-rtl8152-leds.patch
 create mode 100644 target/linux/rockchip/patches-5.4/011-nanopi-r2s-mac-frfom-dt.patch

diff --git a/package/boot/uboot-rockchip/Makefile b/package/boot/uboot-rockchip/Makefile
index 13ca020861..1de1562f4a 100644
--- a/package/boot/uboot-rockchip/Makefile
+++ b/package/boot/uboot-rockchip/Makefile
@@ -21,6 +21,14 @@ define U-Boot/Default
   HIDDEN:=1
 endef
 
+define U-Boot/nanopi-r2s-rk3328
+  BUILD_SUBTARGET:=armv8
+  NAME:=NanoPi R2S
+  BUILD_DEVICES:= \
+    friendlyarm_nanopi-r2s
+  BL31=$(STAGING_DIR_IMAGE)/rk3328_bl31.elf
+endef
+
 define U-Boot/rock-pi-e-rk3328
   BUILD_SUBTARGET:=armv8
   NAME:=Rock Pi E
@@ -38,6 +46,7 @@ define U-Boot/rockpro64-rk3399
 endef
 
 UBOOT_TARGETS := \
+  nanopi-r2s-rk3328 \
   rock-pi-e-rk3328 \
   rockpro64-rk3399
 
diff --git a/package/boot/uboot-rockchip/patches/005-add-support-nanopi-r2s.patch b/package/boot/uboot-rockchip/patches/005-add-support-nanopi-r2s.patch
new file mode 100644
index 0000000000..2bc93378a7
--- /dev/null
+++ b/package/boot/uboot-rockchip/patches/005-add-support-nanopi-r2s.patch
@@ -0,0 +1,792 @@
+diff --git a/arch/arm/dts/Makefile b/arch/arm/dts/Makefile
+index 0127a91a..c5beaa85 100644
+--- a/arch/arm/dts/Makefile
++++ b/arch/arm/dts/Makefile
+@@ -104,7 +104,8 @@ dtb-$(CONFIG_ROCKCHIP_RK3308) += \
+ 
+ dtb-$(CONFIG_ROCKCHIP_RK3328) += \
+ 	rk3328-evb.dtb \
++	rk3328-nanopi-r2s.dtb \
+ 	rk3328-rock64.dtb \
+	rk3328-rock-pi-e.dtb
+ 
+ dtb-$(CONFIG_ROCKCHIP_RK3368) += \
+diff --git a/arch/arm/dts/rk3328-nanopi-r2-common.dtsi b/arch/arm/dts/rk3328-nanopi-r2-common.dtsi
+new file mode 100644
+index 00000000..bc924346
+--- /dev/null
++++ b/arch/arm/dts/rk3328-nanopi-r2-common.dtsi
+@@ -0,0 +1,614 @@
++// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
++/*
++ * Copyright (c) 2018 FriendlyElec Computer Tech. Co., Ltd.
++ * (http://www.friendlyarm.com)
++ *
++ * Copyright (c) 2017 Fuzhou Rockchip Electronics Co., Ltd
++ */
++
++/dts-v1/;
++/*#include "rk3328-dram-default-timing.dtsi"*/
++#include "rk3328.dtsi"
++
++/ {
++	model = "FriendlyARM boards based on Rockchip RK3328";
++	compatible = "friendlyarm,nanopi-r2", "rockchip,rk3328";
++
++	aliases {
++/*		ethernet1 = &r8153;*/
++	};
++
++	chosen {
++		bootargs = "swiotlb=1 coherent_pool=1m consoleblank=0";
++		stdout-path = "serial2:1500000n8";
++	};
++
++	gmac_clkin: external-gmac-clock {
++		compatible = "fixed-clock";
++		clock-frequency = <125000000>;
++		clock-output-names = "gmac_clkin";
++		#clock-cells = <0>;
++	};
++
++	leds: gpio-leds {
++		compatible = "gpio-leds";
++		pinctrl-names = "default";
++		pinctrl-0 =<&leds_gpio>;
++		status = "disabled";
++
++		status {
++			gpios = <&gpio0 RK_PA2 GPIO_ACTIVE_HIGH>;
++			label = "nanopi:red:status";
++			linux,default-trigger = "heartbeat";
++			linux,default-trigger-delay-ms = <0>;
++		};
++	};
++
++	sdio_pwrseq: sdio-pwrseq {
++		compatible = "mmc-pwrseq-simple";
++		clocks = <&rk805 1>;
++		clock-names = "ext_clock";
++		pinctrl-names = "default";
++		pinctrl-0 = <&wifi_enable_h>;
++
++		/*
++		 * On the module itself this is one of these (depending
++		 * on the actual card populated):
++		 * - SDIO_RESET_L_WL_REG_ON
++		 * - PDN (power down when low)
++		 */
++		reset-gpios = <&gpio3 RK_PB0 GPIO_ACTIVE_LOW>;
++	};
++
++/*	sdmmc_ext: dwmmc@ff5f0000 {
++		compatible = "rockchip,rk3328-dw-mshc", "rockchip,rk3288-dw-mshc";
++		reg = <0x0 0xff5f0000 0x0 0x4000>;
++		clock-freq-min-max = <400000 150000000>;
++		clocks = <&cru HCLK_SDMMC_EXT>, <&cru SCLK_SDMMC_EXT>,
++			 <&cru SCLK_SDMMC_EXT_DRV>, <&cru SCLK_SDMMC_EXT_SAMPLE>;
++		clock-names = "biu", "ciu", "ciu-drv", "ciu-sample";
++		fifo-depth = <0x100>;
++		interrupts = <GIC_SPI 4 IRQ_TYPE_LEVEL_HIGH>;
++		status = "disabled";
++	};*/
++
++	vcc_sd: sdmmc-regulator {
++		compatible = "regulator-fixed";
++		gpio = <&gpio0 30 GPIO_ACTIVE_LOW>;
++		pinctrl-names = "default";
++		pinctrl-0 = <&sdmmc0m1_gpio>;
++		regulator-name = "vcc_sd";
++		regulator-min-microvolt = <3300000>;
++		regulator-max-microvolt = <3300000>;
++		vin-supply = <&vcc_io>;
++	};
++
++	vccio_sd: sdmmcio-regulator {
++		compatible = "regulator-gpio";
++		gpios = <&gpio1 RK_PD4 GPIO_ACTIVE_HIGH>;
++		states = <1800000 0x1
++			  3300000 0x0>;
++		regulator-name = "vccio_sd";
++		regulator-type = "voltage";
++		regulator-min-microvolt = <1800000>;
++		regulator-max-microvolt = <3300000>;
++		regulator-always-on;
++		vin-supply = <&vcc_io>;
++		startup-delay-us = <2000>;
++		regulator-settling-time-us = <5000>;
++		enable-active-high;
++		status = "disabled";
++	};
++
++	vcc_sys: vcc-sys {
++		compatible = "regulator-fixed";
++		regulator-name = "vcc_sys";
++		regulator-always-on;
++		regulator-boot-on;
++		regulator-min-microvolt = <5000000>;
++		regulator-max-microvolt = <5000000>;
++	};
++
++	vcc_phy: vcc-phy-regulator {
++		compatible = "regulator-fixed";
++		regulator-name = "vcc_phy";
++		regulator-always-on;
++		regulator-boot-on;
++	};
++
++	vcc_host_vbus: host-vbus-regulator {
++		compatible = "regulator-fixed";
++		regulator-name = "vcc_host_vbus";
++		regulator-always-on;
++		regulator-boot-on;
++		regulator-min-microvolt = <5000000>;
++		regulator-max-microvolt = <5000000>;
++	};
++
++	dfi: dfi@ff790000 {
++		reg = <0x00 0xff790000 0x00 0x400>;
++		compatible = "rockchip,rk3328-dfi";
++		rockchip,grf = <&grf>;
++		status = "disabled";
++	};
++
++/*	dmc: dmc {
++		compatible = "rockchip,rk3328-dmc";
++		devfreq-events = <&dfi>;
++		clocks = <&cru SCLK_DDRCLK>;
++		clock-names = "dmc_clk";
++		operating-points-v2 = <&dmc_opp_table>;
++		ddr_timing = <&ddr_timing>;
++		upthreshold = <40>;
++		downdifferential = <20>;
++		auto-min-freq = <786000>;
++		auto-freq-en = <0>;
++		#cooling-cells = <2>;
++		status = "disabled";
++
++		ddr_power_model: ddr_power_model {
++			compatible = "ddr_power_model";
++			dynamic-power-coefficient = <120>;
++			static-power-coefficient = <200>;
++			ts = <32000 4700 (-80) 2>;
++			thermal-zone = "soc-thermal";
++		};
++	};
++
++	dmc_opp_table: dmc-opp-table {
++		compatible = "operating-points-v2";
++
++		rockchip,leakage-voltage-sel = <
++			1   10    0
++			11  254   1
++		>;
++		nvmem-cells = <&logic_leakage>;
++		nvmem-cell-names = "ddr_leakage";
++
++		opp-786000000 {
++			opp-hz = /bits/ 64 <786000000>;
++			opp-microvolt = <1075000>;
++			opp-microvolt-L0 = <1075000>;
++			opp-microvolt-L1 = <1050000>;
++		};
++		opp-798000000 {
++			opp-hz = /bits/ 64 <798000000>;
++			opp-microvolt = <1075000>;
++			opp-microvolt-L0 = <1075000>;
++			opp-microvolt-L1 = <1050000>;
++		};
++		opp-840000000 {
++			opp-hz = /bits/ 64 <840000000>;
++			opp-microvolt = <1075000>;
++			opp-microvolt-L0 = <1075000>;
++			opp-microvolt-L1 = <1050000>;
++		};
++		opp-924000000 {
++			opp-hz = /bits/ 64 <924000000>;
++			opp-microvolt = <1100000>;
++			opp-microvolt-L0 = <1100000>;
++			opp-microvolt-L1 = <1075000>;
++		};
++		opp-1056000000 {
++			opp-hz = /bits/ 64 <1056000000>;
++			opp-microvolt = <1175000>;
++			opp-microvolt-L0 = <1175000>;
++			opp-microvolt-L1 = <1150000>;
++		};
++	};
++*/};
++
++&cpu0 {
++	cpu-supply = <&vdd_arm>;
++};
++
++&dfi {
++	status = "okay";
++};
++
++/*&dmc {
++	center-supply = <&vdd_logic>;
++	status = "okay";
++};*/
++
++&emmc {
++	bus-width = <8>;
++	cap-mmc-highspeed;
++	max-frequency = <150000000>;
++	mmc-hs200-1_8v;
++	no-sd;
++	non-removable;
++	pinctrl-names = "default";
++	pinctrl-0 = <&emmc_clk &emmc_cmd &emmc_bus8>;
++	vmmc-supply = <&vcc_io>;
++	vqmmc-supply = <&vcc18_emmc>;
++	status = "okay";
++};
++
++&gmac2phy {
++	phy-supply = <&vcc_phy>;
++	clock_in_out = "output";
++	assigned-clocks = <&cru SCLK_MAC2PHY_SRC>;
++	assigned-clock-rate = <50000000>;
++	assigned-clocks = <&cru SCLK_MAC2PHY>;
++	assigned-clock-parents = <&cru SCLK_MAC2PHY_SRC>;
++	status = "disabled";
++};
++
++&gmac2io {
++	assigned-clocks = <&cru SCLK_MAC2IO>, <&cru SCLK_MAC2IO_EXT>;
++	assigned-clock-parents = <&gmac_clkin>, <&gmac_clkin>;
++	clock_in_out = "input";
++	pinctrl-names = "default";
++	pinctrl-0 = <&rgmiim1_pins>;
++	phy-handle = <&rtl8211e>;
++	phy-mode = "rgmii";
++	phy-supply = <&vcc_phy>;
++	snps,reset-active-low;
++	snps,reset-delays-us = <0 10000 30000>;
++	snps,reset-gpio = <&gpio1 RK_PC2 GPIO_ACTIVE_LOW>;
++	snps,aal;
++	snps,rxpbl = <0x4>;
++	snps,txpbl = <0x4>;
++	tx_delay = <0x24>;
++	rx_delay = <0x18>;
++	status = "okay";
++
++	mdio {
++		compatible = "snps,dwmac-mdio";
++		#address-cells = <1>;
++		#size-cells = <0>;
++
++		rtl8211e: phy@0 {
++			reg = <0>;
++			reset-assert-us = <10000>;
++			reset-deassert-us = <30000>;
++			/* reset-gpios = <&gpio1 RK_PC2 GPIO_ACTIVE_LOW>; */
++		};
++	};
++};
++
++&i2c1 {
++	status = "okay";
++
++	rk805: rk805@18 {
++		compatible = "rockchip,rk805";
++		reg = <0x18>;
++		interrupt-parent = <&gpio2>;
++		interrupts = <6 IRQ_TYPE_LEVEL_LOW>;
++		#clock-cells = <1>;
++		clock-output-names = "xin32k", "rk805-clkout2";
++		gpio-controller;
++		#gpio-cells = <2>;
++		pinctrl-names = "default";
++		pinctrl-0 = <&pmic_int_l>;
++		rockchip,system-power-controller;
++		wakeup-source;
++
++		vcc1-supply = <&vcc_sys>;
++		vcc2-supply = <&vcc_sys>;
++		vcc3-supply = <&vcc_sys>;
++		vcc4-supply = <&vcc_sys>;
++		vcc5-supply = <&vcc_io>;
++		vcc6-supply = <&vcc_io>;
++
++		regulators {
++			vdd_logic: DCDC_REG1 {
++				regulator-name = "vdd_logic";
++				regulator-init-microvolt = <1075000>;
++				regulator-min-microvolt = <712500>;
++				regulator-max-microvolt = <1450000>;
++				regulator-always-on;
++				regulator-boot-on;
++				regulator-state-mem {
++					regulator-on-in-suspend;
++					regulator-suspend-microvolt = <1000000>;
++				};
++			};
++
++			vdd_arm: DCDC_REG2 {
++				regulator-name = "vdd_arm";
++				regulator-init-microvolt = <1225000>;
++				regulator-min-microvolt = <712500>;
++				regulator-max-microvolt = <1450000>;
++				regulator-always-on;
++				regulator-boot-on;
++				regulator-state-mem {
++					regulator-on-in-suspend;
++					regulator-suspend-microvolt = <950000>;
++				};
++			};
++
++			vcc_ddr: DCDC_REG3 {
++				regulator-name = "vcc_ddr";
++				regulator-always-on;
++				regulator-boot-on;
++				regulator-state-mem {
++					regulator-on-in-suspend;
++				};
++			};
++
++			vcc_io: DCDC_REG4 {
++				regulator-name = "vcc_io";
++				regulator-min-microvolt = <3300000>;
++				regulator-max-microvolt = <3300000>;
++				regulator-always-on;
++				regulator-boot-on;
++				regulator-state-mem {
++					regulator-on-in-suspend;
++					regulator-suspend-microvolt = <3300000>;
++				};
++			};
++
++			vcc_18: LDO_REG1 {
++				regulator-name = "vcc_18";
++				regulator-min-microvolt = <1800000>;
++				regulator-max-microvolt = <1800000>;
++				regulator-always-on;
++				regulator-boot-on;
++				regulator-state-mem {
++					regulator-on-in-suspend;
++					regulator-suspend-microvolt = <1800000>;
++				};
++			};
++
++			vcc18_emmc: LDO_REG2 {
++				regulator-name = "vcc18_emmc";
++				regulator-min-microvolt = <1800000>;
++				regulator-max-microvolt = <1800000>;
++				regulator-always-on;
++				regulator-boot-on;
++				regulator-state-mem {
++					regulator-on-in-suspend;
++					regulator-suspend-microvolt = <1800000>;
++				};
++			};
++
++			vdd_10: LDO_REG3 {
++				regulator-name = "vdd_10";
++				regulator-min-microvolt = <1000000>;
++				regulator-max-microvolt = <1000000>;
++				regulator-always-on;
++				regulator-boot-on;
++				regulator-state-mem {
++					regulator-on-in-suspend;
++					regulator-suspend-microvolt = <1000000>;
++				};
++			};
++		};
++	};
++};
++
++&io_domains {
++	status = "okay";
++
++	vccio1-supply = <&vcc_io>;
++	vccio2-supply = <&vcc18_emmc>;
++	vccio3-supply = <&vcc_io>;
++	vccio4-supply = <&vcc_io>;
++	vccio5-supply = <&vcc_io>;
++	vccio6-supply = <&vcc_18>;
++	pmuio-supply = <&vcc_io>;
++};
++
++&pinctrl {
++	pmic {
++		pmic_int_l: pmic-int-l {
++			rockchip,pins = <2 RK_PA6 RK_FUNC_GPIO &pcfg_pull_up>;
++		};
++	};
++
++	sdio-pwrseq {
++		wifi_enable_h: wifi-enable-h {
++			rockchip,pins = <3 RK_PB0 RK_FUNC_GPIO &pcfg_pull_none>;
++		};
++	};
++
++	sdmmc0 {
++		sdmmc0_clk: sdmmc0-clk {
++			rockchip,pins = <1 RK_PA6 1 &pcfg_pull_none_4ma>;
++		};
++
++		sdmmc0_cmd: sdmmc0-cmd {
++			rockchip,pins = <1 RK_PA4 1 &pcfg_pull_up_4ma>;
++		};
++
++		sdmmc0_dectn: sdmmc0-dectn {
++			rockchip,pins = <1 RK_PA5 1 &pcfg_pull_up_4ma>;
++		};
++
++		sdmmc0_bus4: sdmmc0-bus4 {
++			rockchip,pins =
++				<1 RK_PA0 1 &pcfg_pull_up_4ma>,
++				<1 RK_PA1 1 &pcfg_pull_up_4ma>,
++				<1 RK_PA2 1 &pcfg_pull_up_4ma>,
++				<1 RK_PA3 1 &pcfg_pull_up_4ma>;
++		};
++	};
++
++	sdmmc0ext {
++		sdmmc0ext_clk: sdmmc0ext-clk {
++			rockchip,pins = <3 RK_PA2 3 &pcfg_pull_none_2ma>;
++		};
++
++		sdmmc0ext_cmd: sdmmc0ext-cmd {
++			rockchip,pins = <3 RK_PA0 3 &pcfg_pull_up_2ma>;
++		};
++
++		sdmmc0ext_bus4: sdmmc0ext-bus4 {
++			rockchip,pins =
++				<3 RK_PA4 3 &pcfg_pull_up_2ma>,
++				<3 RK_PA5 3 &pcfg_pull_up_2ma>,
++				<3 RK_PA6 3 &pcfg_pull_up_2ma>,
++				<3 RK_PA7 3 &pcfg_pull_up_2ma>;
++		};
++	};
++
++	gmac-1 {
++		rgmiim1_pins: rgmiim1-pins {
++			rockchip,pins =
++				/* mac_txclk */
++				<1 RK_PB4 2 &pcfg_pull_none_4ma>,
++				/* mac_rxclk */
++				<1 RK_PB5 2 &pcfg_pull_none>,
++				/* mac_mdio */
++				<1 RK_PC3 2 &pcfg_pull_none_2ma>,
++				/* mac_txen */
++				<1 RK_PD1 2 &pcfg_pull_none_4ma>,
++				/* mac_clk */
++				<1 RK_PC5 2 &pcfg_pull_none_2ma>,
++				/* mac_rxdv */
++				<1 RK_PC6 2 &pcfg_pull_none>,
++				/* mac_mdc */
++				<1 RK_PC7 2 &pcfg_pull_none_2ma>,
++				/* mac_rxd1 */
++				<1 RK_PB2 2 &pcfg_pull_none>,
++				/* mac_rxd0 */
++				<1 RK_PB3 2 &pcfg_pull_none>,
++				/* mac_txd1 */
++				<1 RK_PB0 2 &pcfg_pull_none_4ma>,
++				/* mac_txd0 */
++				<1 RK_PB1 2 &pcfg_pull_none_4ma>,
++				/* mac_rxd3 */
++				<1 RK_PB6 2 &pcfg_pull_none>,
++				/* mac_rxd2 */
++				<1 RK_PB7 2 &pcfg_pull_none>,
++				/* mac_txd3 */
++				<1 RK_PC0 2 &pcfg_pull_none_4ma>,
++				/* mac_txd2 */
++				<1 RK_PC1 2 &pcfg_pull_none_4ma>,
++
++				/* mac_txclk */
++				<0 RK_PB0 1 &pcfg_pull_none>,
++				/* mac_txen */
++				<0 RK_PB4 1 &pcfg_pull_none>,
++				/* mac_clk */
++				<0 RK_PD0 1 &pcfg_pull_none>,
++				/* mac_txd1 */
++				<0 RK_PC0 1 &pcfg_pull_none>,
++				/* mac_txd0 */
++				<0 RK_PC1 1 &pcfg_pull_none>,
++				/* mac_txd3 */
++				<0 RK_PC7 1 &pcfg_pull_none>,
++				/* mac_txd2 */
++				<0 RK_PC6 1 &pcfg_pull_none>;
++		};
++	};
++
++	usb {
++		host_vbus_drv: host-vbus-drv {
++			rockchip,pins = <0 RK_PA0 RK_FUNC_GPIO &pcfg_pull_none>;
++		};
++
++		otg_vbus_drv: otg-vbus-drv {
++			rockchip,pins = <3 RK_PA1 RK_FUNC_GPIO &pcfg_pull_none>;
++		};
++	};
++
++	gpio-leds {
++		leds_gpio: leds-gpio {
++			rockchip,pins = <0 RK_PA2 RK_FUNC_GPIO &pcfg_pull_none>;
++		};
++	};
++};
++
++&sdmmc {
++	bus-width = <4>;
++	cap-mmc-highspeed;
++	cap-sd-highspeed;
++	disable-wp;
++	max-frequency = <150000000>;
++	pinctrl-names = "default";
++	pinctrl-0 = <&sdmmc0_clk &sdmmc0_cmd &sdmmc0_dectn &sdmmc0_bus4>;
++	vmmc-supply = <&vcc_sd>;
++	status = "okay";
++};
++
++/*&sdmmc_ext {
++	bus-width = <4>;
++	cap-sd-highspeed;
++	cap-sdio-irq;
++	disable-wp;
++	keep-power-in-suspend;
++	max-frequency = <100000000>;
++	mmc-pwrseq = <&sdio_pwrseq>;
++	non-removable;
++	num-slots = <1>;
++	pinctrl-names = "default";
++	pinctrl-0 = <&sdmmc0ext_clk &sdmmc0ext_cmd &sdmmc0ext_bus4>;
++	rockchip,default-sample-phase = <120>;
++	supports-sdio;
++	sd-uhs-sdr104;
++	#address-cells = <1>;
++	#size-cells = <0>;
++	status = "okay";
++
++	brcmf: bcrmf@1 {
++		reg = <1>;
++		compatible = "brcm,bcm4329-fmac";
++		interrupt-parent = <&gpio1>;
++		interrupts = <RK_PD2 IRQ_TYPE_LEVEL_HIGH>;
++		interrupt-names = "host-wake";
++	};
++};*/
++
++/*&tsadc {
++	status = "okay";
++};*/
++
++&uart2 {
++	status = "okay";
++};
++
++/*&u2phy {
++	status = "okay";
++};
++
++&u2phy_host {
++	status = "okay";
++};
++
++&u2phy_otg {
++	status = "okay";
++};
++
++&u3phy {
++	vbus-supply = <&vcc_host_vbus>;
++	status = "okay";
++};
++
++&u3phy_utmi {
++	status = "okay";
++};
++
++&u3phy_pipe {
++	status = "okay";
++};
++
++&usb20_otg {
++	status = "okay";
++};
++
++&usb_host0_ehci {
++	status = "okay";
++};
++
++&usb_host0_ohci {
++	status = "okay";
++};
++
++&usbdrd3 {
++	status = "okay";
++};
++
++&usbdrd_dwc3 {
++	status = "okay";
++	#address-cells = <1>;
++	#size-cells = <0>;
++
++	r8153: device@2 {
++		compatible = "usbbda:8153";
++		reg = <2>;
++		local-mac-address = [00 00 00 00 00 00];
++	};
++};*/
+diff --git a/arch/arm/dts/rk3328-nanopi-r2s.dts b/arch/arm/dts/rk3328-nanopi-r2s.dts
+new file mode 100644
+index 00000000..c3313bdc
+--- /dev/null
++++ b/arch/arm/dts/rk3328-nanopi-r2s.dts
+@@ -0,0 +1,140 @@
++// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
++/*
++ * Copyright (c) 2019 FriendlyElec Computer Tech. Co., Ltd.
++ * (http://www.friendlyarm.com)
++ */
++
++/dts-v1/;
++#include <dt-bindings/input/linux-event-codes.h>
++#include "rk3328-nanopi-r2-common.dtsi"
++
++/ {
++	model = "FriendlyARM NanoPi R2S";
++	compatible = "friendlyarm,nanopi-r2s", "rockchip,rk3328";
++
++	gpio-keys {
++		compatible = "gpio-keys";
++		#address-cells = <1>;
++		#size-cells = <0>;
++		autorepeat;
++
++		pinctrl-names = "default";
++		pinctrl-0 = <&gpio_key1>;
++
++		reset {
++			gpios = <&gpio0 RK_PA0 GPIO_ACTIVE_LOW>;
++			label = "reset";
++			linux,code = <KEY_RESTART>;
++			linux,input-type = <1>;
++			gpio-key,wakeup = <1>;
++			debounce-interval = <100>;
++		};
++	};
++
++	vcc_rtl8153: vcc-rtl8153-regulator {
++		compatible = "regulator-fixed";
++		gpio = <&gpio2 RK_PC6 GPIO_ACTIVE_HIGH>;
++		pinctrl-names = "default";
++		pinctrl-0 = <&usb30_en_drv>;
++		regulator-always-on;
++		regulator-name = "vcc_rtl8153";
++		regulator-min-microvolt = <5000000>;
++		regulator-max-microvolt = <5000000>;
++		off-on-delay-us = <5000>;
++		enable-active-high;
++	};
++};
++
++&emmc {
++	status = "disabled";
++};
++
++&i2c0 {
++	status = "okay";
++};
++
++&leds {
++	status = "okay";
++
++	lan {
++		gpios = <&gpio2 RK_PB7 GPIO_ACTIVE_HIGH>;
++		label = "nanopi:green:lan";
++	};
++
++	wan {
++		gpios = <&gpio2 RK_PC2 GPIO_ACTIVE_HIGH>;
++		label = "nanopi:green:wan";
++	};
++};
++
++&leds_gpio {
++	rockchip,pins =
++		<0 RK_PA2 RK_FUNC_GPIO &pcfg_pull_none>,
++		<2 RK_PB7 RK_FUNC_GPIO &pcfg_pull_none>,
++		<2 RK_PC2 RK_FUNC_GPIO &pcfg_pull_none>;
++};
++
++/*&pwm2 {
++	pinctrl-names = "default", "sleep";
++	pinctrl-1 = <&pwm2_sleep_pin>;
++	status = "okay";
++};*/
++
++&rk805 {
++	interrupt-parent = <&gpio1>;
++	interrupts = <RK_PD0 IRQ_TYPE_LEVEL_LOW>;
++};
++
++&vccio_sd {
++	status = "okay";
++};
++
++&io_domains {
++	vccio3-supply = <&vccio_sd>;
++};
++
++&sdmmc {
++	vqmmc-supply = <&vccio_sd>;
++	max-frequency = <150000000>;
++	sd-uhs-sdr50;
++	sd-uhs-sdr104;
++	status = "okay";
++};
++
++/*&sdmmc_ext {
++	status = "disabled";
++};*/
++
++&sdio_pwrseq {
++	status = "disabled";
++};
++
++&pinctrl {
++	pmic {
++		pmic_int_l: pmic-int-l {
++			rockchip,pins = <1 RK_PD0 RK_FUNC_GPIO &pcfg_pull_up>;
++		};
++	};
++
++	pwm {
++		pwm2_sleep_pin: pwm2-sleep-pin {
++			rockchip,pins = <2 RK_PA6 RK_FUNC_GPIO &pcfg_output_low>;
++		};
++	};
++
++	rockchip-key {
++		gpio_key1: gpio-key1 {
++			rockchip,pins = <0 RK_PA0 RK_FUNC_GPIO &pcfg_pull_none>;
++		};
++	};
++
++	usb {
++		otg_vbus_drv: otg-vbus-drv {
++			rockchip,pins = <1 RK_PD2 RK_FUNC_GPIO &pcfg_pull_none>;
++		};
++
++		usb30_en_drv: usb30-en-drv {
++			rockchip,pins = <2 RK_PC6 RK_FUNC_GPIO &pcfg_pull_none>;
++		};
++	};
++};
+diff --git a/arch/arm/dts/rk3328.dtsi b/arch/arm/dts/rk3328.dtsi
+index 060c84e6..eac257b0 100644
+--- a/arch/arm/dts/rk3328.dtsi
++++ b/arch/arm/dts/rk3328.dtsi
+@@ -1386,7 +1386,7 @@
+ 			};
+ 		};
+ 
+-		gmac2phy {
++		gmac2phy: gmac2phy {
+ 			fephyled_speed100: fephyled-speed100 {
+ 				rockchip,pins =
+ 					<0 31 RK_FUNC_1 &pcfg_pull_none>;
diff --git a/package/boot/uboot-rockchip/patches/006-add-support-nanopi-r2s-defconfig.patch b/package/boot/uboot-rockchip/patches/006-add-support-nanopi-r2s-defconfig.patch
new file mode 100644
index 0000000000..44503ba615
--- /dev/null
+++ b/package/boot/uboot-rockchip/patches/006-add-support-nanopi-r2s-defconfig.patch
@@ -0,0 +1,149 @@
+diff --git a/arch/arm/dts/rk3328-nanopi-r2s-u-boot.dtsi b/arch/arm/dts/rk3328-nanopi-r2s-u-boot.dtsi
+new file mode 100644
+index 00000000..cf3452ea
+--- /dev/null
++++ b/arch/arm/dts/rk3328-nanopi-r2s-u-boot.dtsi
+@@ -0,0 +1,37 @@
++// SPDX-License-Identifier: GPL-2.0+
++/*
++ * (C) Copyright 2018-2019 Rockchip Electronics Co., Ltd
++ */
++
++#include "rk3328-u-boot.dtsi"
++#include "rk3328-sdram-ddr4-666.dtsi"
++/ {
++	chosen {
++		u-boot,spl-boot-order = "same-as-spl", &sdmmc, &emmc;
++	};
++};
++
++&gpio0 {
++	u-boot,dm-spl;
++};
++
++&pinctrl {
++	u-boot,dm-spl;
++};
++
++&sdmmc0m1_gpio {
++	u-boot,dm-spl;
++};
++
++&pcfg_pull_up_4ma {
++	u-boot,dm-spl;
++};
++
++&usb_host0_xhci {
++	status = "okay";
++};
++
++/* Need this and all the pinctrl/gpio stuff above to set pinmux */
++&vcc_sd {
++	u-boot,dm-spl;
++};
+diff --git a/configs/nanopi-r2s-rk3328_defconfig b/configs/nanopi-r2s-rk3328_defconfig
+new file mode 100644
+index 00000000..720b5e04
+--- /dev/null
++++ b/configs/nanopi-r2s-rk3328_defconfig
+@@ -0,0 +1,100 @@
++CONFIG_ARM=y
++CONFIG_ARCH_ROCKCHIP=y
++CONFIG_SYS_TEXT_BASE=0x00200000
++CONFIG_SPL_GPIO_SUPPORT=y
++CONFIG_ROCKCHIP_RK3328=y
++CONFIG_TPL_ROCKCHIP_COMMON_BOARD=y
++CONFIG_TPL_LIBCOMMON_SUPPORT=y
++CONFIG_TPL_LIBGENERIC_SUPPORT=y
++CONFIG_SPL_DRIVERS_MISC_SUPPORT=y
++CONFIG_ENV_OFFSET=0x3F8000
++CONFIG_SPL_STACK_R_ADDR=0x600000
++CONFIG_NR_DRAM_BANKS=1
++CONFIG_DEBUG_UART_BASE=0xFF130000
++CONFIG_DEBUG_UART_CLOCK=24000000
++CONFIG_SMBIOS_PRODUCT_NAME="nanopi-r2s_rk3328"
++CONFIG_DEBUG_UART=y
++CONFIG_TPL_SYS_MALLOC_F_LEN=0x800
++# CONFIG_ANDROID_BOOT_IMAGE is not set
++CONFIG_FIT=y
++CONFIG_FIT_VERBOSE=y
++CONFIG_SPL_LOAD_FIT=y
++CONFIG_DEFAULT_FDT_FILE="rockchip/rk3328-nanopi-r2s.dtb"
++CONFIG_MISC_INIT_R=y
++# CONFIG_DISPLAY_CPUINFO is not set
++CONFIG_DISPLAY_BOARDINFO_LATE=y
++# CONFIG_SPL_RAW_IMAGE_SUPPORT is not set
++CONFIG_TPL_SYS_MALLOC_SIMPLE=y
++CONFIG_SPL_STACK_R=y
++CONFIG_SPL_I2C_SUPPORT=y
++CONFIG_SPL_POWER_SUPPORT=y
++CONFIG_SPL_ATF=y
++CONFIG_SPL_ATF_NO_PLATFORM_PARAM=y
++CONFIG_CMD_BOOTZ=y
++CONFIG_CMD_GPT=y
++CONFIG_CMD_MMC=y
++CONFIG_CMD_USB=y
++# CONFIG_CMD_SETEXPR is not set
++CONFIG_CMD_TIME=y
++CONFIG_SPL_OF_CONTROL=y
++CONFIG_TPL_OF_CONTROL=y
++CONFIG_DEFAULT_DEVICE_TREE="rk3328-nanopi-r2s"
++CONFIG_OF_SPL_REMOVE_PROPS="clock-names interrupt-parent assigned-clocks assigned-clock-rates assigned-clock-parents"
++CONFIG_TPL_OF_PLATDATA=y
++CONFIG_ENV_IS_IN_MMC=y
++CONFIG_SYS_RELOC_GD_ENV_ADDR=y
++CONFIG_NET_RANDOM_ETHADDR=y
++CONFIG_TPL_DM=y
++CONFIG_REGMAP=y
++CONFIG_SPL_REGMAP=y
++CONFIG_TPL_REGMAP=y
++CONFIG_SYSCON=y
++CONFIG_SPL_SYSCON=y
++CONFIG_TPL_SYSCON=y
++CONFIG_CLK=y
++CONFIG_SPL_CLK=y
++CONFIG_FASTBOOT_BUF_ADDR=0x800800
++CONFIG_FASTBOOT_CMD_OEM_FORMAT=y
++CONFIG_ROCKCHIP_GPIO=y
++CONFIG_SYS_I2C_ROCKCHIP=y
++CONFIG_MMC_DW=y
++CONFIG_MMC_DW_ROCKCHIP=y
++CONFIG_SF_DEFAULT_SPEED=20000000
++CONFIG_DM_ETH=y
++CONFIG_ETH_DESIGNWARE=y
++CONFIG_GMAC_ROCKCHIP=y
++CONFIG_PHY=y
++CONFIG_PINCTRL=y
++CONFIG_SPL_PINCTRL=y
++CONFIG_DM_PMIC=y
++CONFIG_PMIC_RK8XX=y
++CONFIG_SPL_DM_REGULATOR=y
++CONFIG_REGULATOR_PWM=y
++CONFIG_SPL_DM_REGULATOR_FIXED=y
++CONFIG_DM_REGULATOR_FIXED=y
++CONFIG_REGULATOR_RK8XX=y
++CONFIG_PWM_ROCKCHIP=y
++CONFIG_RAM=y
++CONFIG_SPL_RAM=y
++CONFIG_TPL_RAM=y
++CONFIG_DM_RESET=y
++CONFIG_BAUDRATE=1500000
++CONFIG_DEBUG_UART_SHIFT=2
++CONFIG_SYSRESET=y
++# CONFIG_TPL_SYSRESET is not set
++CONFIG_USB=y
++CONFIG_USB_XHCI_HCD=y
++CONFIG_USB_XHCI_DWC3=y
++CONFIG_USB_EHCI_HCD=y
++CONFIG_USB_EHCI_GENERIC=y
++CONFIG_USB_OHCI_HCD=y
++CONFIG_USB_OHCI_GENERIC=y
++CONFIG_USB_DWC2=y
++CONFIG_USB_DWC3=y
++# CONFIG_USB_DWC3_GADGET is not set
++CONFIG_USB_GADGET=y
++CONFIG_USB_GADGET_DWC2_OTG=y
++CONFIG_SPL_TINY_MEMSET=y
++CONFIG_TPL_TINY_MEMSET=y
++CONFIG_ERRNO_STR=y
++CONFIG_SMBIOS_MANUFACTURER="friendlyarm"
diff --git a/package/boot/uboot-rockchip/patches/009-add-set-eth1-addr.patch b/package/boot/uboot-rockchip/patches/009-add-set-eth1-addr.patch
new file mode 100644
index 0000000000..422cbc3f9a
--- /dev/null
+++ b/package/boot/uboot-rockchip/patches/009-add-set-eth1-addr.patch
@@ -0,0 +1,16 @@
+diff --git a/arch/arm/mach-rockchip/misc.c b/arch/arm/mach-rockchip/misc.c
+index 6dbb9bde..89f3a918 100644
+--- a/arch/arm/mach-rockchip/misc.c
++++ b/arch/arm/mach-rockchip/misc.c
+@@ -50,6 +50,11 @@ int rockchip_setup_macaddr(void)
+ 	mac_addr[0] &= 0xfe;  /* clear multicast bit */
+ 	mac_addr[0] |= 0x02;  /* set local assignment bit (IEEE802) */
+ 	eth_env_set_enetaddr("ethaddr", mac_addr);
++
++	/* Make a valid MAC address for eth1 too */
++	mac_addr[5] += 0x20;
++	mac_addr[5] &= 0xff;
++	eth_env_set_enetaddr("eth1addr", mac_addr);
+ #endif
+ 	return 0;
+ }
diff --git a/target/linux/rockchip/armv8/base-files/etc/board.d/01_leds b/target/linux/rockchip/armv8/base-files/etc/board.d/01_leds
new file mode 100755
index 0000000000..2b75aab533
--- /dev/null
+++ b/target/linux/rockchip/armv8/base-files/etc/board.d/01_leds
@@ -0,0 +1,18 @@
+#!/bin/sh
+#
+# Copyright © 2017 OpenWrt.org
+#
+
+. /lib/functions/uci-defaults.sh
+
+board_config_update
+
+case "$(board_name)" in
+friendlyarm,nanopi-r2s)
+	ucidef_set_led_netdev "wan" "WAN" "nanopi:green:wan" "eth0"
+	ucidef_set_led_netdev "lan" "LAN" "nanopi:green:lan" "eth1"
+	;;
+esac
+board_config_flush
+
+exit 0
diff --git a/target/linux/rockchip/armv8/base-files/etc/board.d/02_network b/target/linux/rockchip/armv8/base-files/etc/board.d/02_network
index b436110f42..ed14d58a4f 100755
--- a/target/linux/rockchip/armv8/base-files/etc/board.d/02_network
+++ b/target/linux/rockchip/armv8/base-files/etc/board.d/02_network
@@ -5,6 +5,9 @@
 board_config_update
 
 case "$(board_name)" in
+friendlyarm,nanopi-r2s)
+	ucidef_set_interfaces_lan_wan "eth1" "eth0"
+	;;
 radxa,rock-pi-e)
 	ucidef_set_interfaces_lan_wan "eth1" "eth0"
 	;;
diff --git a/target/linux/rockchip/armv8/config-5.4 b/target/linux/rockchip/armv8/config-5.4
index 526ecd78b6..b0de9266b0 100644
--- a/target/linux/rockchip/armv8/config-5.4
+++ b/target/linux/rockchip/armv8/config-5.4
@@ -410,6 +410,7 @@ CONFIG_REGMAP_MMIO=y
 CONFIG_REGULATOR=y
 CONFIG_REGULATOR_FAN53555=y
 CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_REGULATOR_GPIO=y
 CONFIG_REGULATOR_PWM=y
 CONFIG_REGULATOR_RK808=y
 CONFIG_RELOCATABLE=y
@@ -567,18 +568,6 @@ CONFIG_ZLIB_INFLATE=y
 CONFIG_ARM64_CRYPTO=y
 CONFIG_ARM_ROCKCHIP_CPUFREQ=y
 CONFIG_ARM_ROCKCHIP_DMC_DEVFREQ=y
-CONFIG_CRYPTO_AES_ARM64_CE_BLK=y
-CONFIG_CRYPTO_AES_ARM64_CE_CCM=y
-CONFIG_CRYPTO_ANSI_CPRNG=y
-CONFIG_CRYPTO_CMAC=y
-CONFIG_CRYPTO_ECB=y
-CONFIG_CRYPTO_GHASH_ARM64_CE=y
-CONFIG_CRYPTO_MD5=y
-CONFIG_CRYPTO_SHA1=y
-CONFIG_CRYPTO_SHA1_ARM64_CE=y
-CONFIG_CRYPTO_SHA2_ARM64_CE=y
-CONFIG_CRYPTO_SHA512=y
-CONFIG_CRYPTO_TWOFISH=y
-CONFIG_CRYPTO_USER_API_HASH=y
-CONFIG_CRYPTO_USER_API_SKCIPHER=y
-CONFIG_REGULATOR_GPIO=y
\ No newline at end of file
+CONFIG_ARM_RK3328_DMC_DEVFREQ=y
+CONFIG_USB_G_MULTI_RNDIS=y
+CONFIG_USB_G_MULTI_CDC=y
\ No newline at end of file
diff --git a/target/linux/rockchip/image/armv8.mk b/target/linux/rockchip/image/armv8.mk
index 865ad8d443..5c6381b416 100644
--- a/target/linux/rockchip/image/armv8.mk
+++ b/target/linux/rockchip/image/armv8.mk
@@ -4,6 +4,16 @@
 # This is free software, licensed under the GNU General Public License v2.
 # See /LICENSE for more information.
 #
+define Device/friendlyarm_nanopi-r2s
+  DEVICE_VENDOR := FriendlyARM
+  DEVICE_MODEL := NanoPi R2S
+  SOC := rk3328
+  UBOOT_DEVICE_NAME := nanopi-r2s-rk3328
+  IMAGE/sysupgrade.img.gz := boot-common | boot-script | sdcard-img | gzip | append-metadata
+  DEVICE_PACKAGES += kmod-phy-realtek kmod-usb-net kmod-usb-net-rtl8152 kmod-macvlan
+endef
+TARGET_DEVICES += friendlyarm_nanopi-r2s
+
 define Device/radxa_rock-pi-e
   DEVICE_VENDOR := Radxa
   DEVICE_MODEL := Rock Pi E
diff --git a/target/linux/rockchip/patches-5.4/001-add-rk3328-dmc-driver.patch b/target/linux/rockchip/patches-5.4/001-add-rk3328-dmc-driver.patch
new file mode 100644
index 0000000000..761429289f
--- /dev/null
+++ b/target/linux/rockchip/patches-5.4/001-add-rk3328-dmc-driver.patch
@@ -0,0 +1,1796 @@
+From fcd9629c05f373771e85920e1c1d0ab252617878 Mon Sep 17 00:00:00 2001
+From: hmz007 <hmz007@gmail.com>
+Date: Tue, 19 Nov 2019 13:53:25 +0800
+Subject: [PATCH] PM / devfreq: rockchip: add devfreq driver for rk3328 dmc
+
+Signed-off-by: hmz007 <hmz007@gmail.com>
+---
+ drivers/devfreq/Kconfig      |  18 +-
+ drivers/devfreq/Makefile     |   1 +
+ drivers/devfreq/rk3328_dmc.c | 846 +++++++++++++++++++++++++++++++++++
+ 3 files changed, 862 insertions(+), 3 deletions(-)
+ create mode 100644 drivers/devfreq/rk3328_dmc.c
+
+diff --git a/drivers/devfreq/Kconfig b/drivers/devfreq/Kconfig
+index defe1d438710..5ae0832f046b 100644
+--- a/drivers/devfreq/Kconfig
++++ b/drivers/devfreq/Kconfig
+@@ -115,6 +115,18 @@ config ARM_TEGRA20_DEVFREQ
+ 	  It reads Memory Controller counters and adjusts the operating
+ 	  frequencies and voltages with OPP support.
+ 
++config ARM_RK3328_DMC_DEVFREQ
++	tristate "ARM RK3328 DMC DEVFREQ Driver"
++	depends on ARCH_ROCKCHIP
++	select DEVFREQ_EVENT_ROCKCHIP_DFI
++	select DEVFREQ_GOV_SIMPLE_ONDEMAND
++	select PM_DEVFREQ_EVENT
++	select PM_OPP
++	help
++	  This adds the DEVFREQ driver for the RK3328 DMC(Dynamic Memory Controller).
++	  It sets the frequency for the memory controller and reads the usage counts
++	  from hardware.
++
+ config ARM_RK3399_DMC_DEVFREQ
+ 	tristate "ARM RK3399 DMC DEVFREQ Driver"
+ 	depends on ARCH_ROCKCHIP
+@@ -123,9 +135,9 @@ config ARM_RK3399_DMC_DEVFREQ
+ 	select PM_DEVFREQ_EVENT
+ 	select PM_OPP
+ 	help
+-          This adds the DEVFREQ driver for the RK3399 DMC(Dynamic Memory Controller).
+-          It sets the frequency for the memory controller and reads the usage counts
+-          from hardware.
++	  This adds the DEVFREQ driver for the RK3399 DMC(Dynamic Memory Controller).
++	  It sets the frequency for the memory controller and reads the usage counts
++	  from hardware.
+ 
+ source "drivers/devfreq/event/Kconfig"
+ 
+diff --git a/drivers/devfreq/Makefile b/drivers/devfreq/Makefile
+index 338ae8440db6..ec568406ef50 100644
+--- a/drivers/devfreq/Makefile
++++ b/drivers/devfreq/Makefile
+@@ -10,6 +10,7 @@ obj-$(CONFIG_DEVFREQ_GOV_PASSIVE)	+= governor_passive.o
+ # DEVFREQ Drivers
+ obj-$(CONFIG_ARM_EXYNOS_BUS_DEVFREQ)	+= exynos-bus.o
+ obj-$(CONFIG_ARM_RK3399_DMC_DEVFREQ)	+= rk3399_dmc.o
++obj-$(CONFIG_ARM_RK3328_DMC_DEVFREQ)	+= rk3328_dmc.o
+ obj-$(CONFIG_ARM_TEGRA_DEVFREQ)		+= tegra30-devfreq.o
+ obj-$(CONFIG_ARM_TEGRA20_DEVFREQ)	+= tegra20-devfreq.o
+ 
+diff --git a/drivers/devfreq/rk3328_dmc.c b/drivers/devfreq/rk3328_dmc.c
+new file mode 100644
+index 000000000000..9e3c87019ada
+--- /dev/null
++++ b/drivers/devfreq/rk3328_dmc.c
+@@ -0,0 +1,846 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright (c) 2016, Fuzhou Rockchip Electronics Co., Ltd.
++ * Author: Lin Huang <hl@rock-chips.com>
++ */
++
++#include <linux/arm-smccc.h>
++#include <linux/clk.h>
++#include <linux/delay.h>
++#include <linux/devfreq.h>
++#include <linux/devfreq-event.h>
++#include <linux/interrupt.h>
++#include <linux/mfd/syscon.h>
++#include <linux/module.h>
++#include <linux/of.h>
++#include <linux/platform_device.h>
++#include <linux/pm_opp.h>
++#include <linux/regmap.h>
++#include <linux/regulator/consumer.h>
++#include <linux/rwsem.h>
++#include <linux/suspend.h>
++
++#include <soc/rockchip/rockchip_sip.h>
++
++#define DTS_PAR_OFFSET		(4096)
++
++struct share_params {
++	u32 hz;
++	u32 lcdc_type;
++	u32 vop;
++	u32 vop_dclk_mode;
++	u32 sr_idle_en;
++	u32 addr_mcu_el3;
++	/*
++	 * 1: need to wait flag1
++	 * 0: never wait flag1
++	 */
++	u32 wait_flag1;
++	/*
++	 * 1: need to wait flag1
++	 * 0: never wait flag1
++	 */
++	u32 wait_flag0;
++	u32 complt_hwirq;
++	/* if need, add parameter after */
++};
++
++static struct share_params *ddr_psci_param;
++
++/* hope this define can adapt all future platform */
++static const char * const rk3328_dts_timing[] = {
++	"ddr3_speed_bin",
++	"ddr4_speed_bin",
++	"pd_idle",
++	"sr_idle",
++	"sr_mc_gate_idle",
++	"srpd_lite_idle",
++	"standby_idle",
++
++	"auto_pd_dis_freq",
++	"auto_sr_dis_freq",
++	"ddr3_dll_dis_freq",
++	"ddr4_dll_dis_freq",
++	"phy_dll_dis_freq",
++
++	"ddr3_odt_dis_freq",
++	"phy_ddr3_odt_dis_freq",
++	"ddr3_drv",
++	"ddr3_odt",
++	"phy_ddr3_ca_drv",
++	"phy_ddr3_ck_drv",
++	"phy_ddr3_dq_drv",
++	"phy_ddr3_odt",
++
++	"lpddr3_odt_dis_freq",
++	"phy_lpddr3_odt_dis_freq",
++	"lpddr3_drv",
++	"lpddr3_odt",
++	"phy_lpddr3_ca_drv",
++	"phy_lpddr3_ck_drv",
++	"phy_lpddr3_dq_drv",
++	"phy_lpddr3_odt",
++
++	"lpddr4_odt_dis_freq",
++	"phy_lpddr4_odt_dis_freq",
++	"lpddr4_drv",
++	"lpddr4_dq_odt",
++	"lpddr4_ca_odt",
++	"phy_lpddr4_ca_drv",
++	"phy_lpddr4_ck_cs_drv",
++	"phy_lpddr4_dq_drv",
++	"phy_lpddr4_odt",
++
++	"ddr4_odt_dis_freq",
++	"phy_ddr4_odt_dis_freq",
++	"ddr4_drv",
++	"ddr4_odt",
++	"phy_ddr4_ca_drv",
++	"phy_ddr4_ck_drv",
++	"phy_ddr4_dq_drv",
++	"phy_ddr4_odt",
++};
++
++static const char * const rk3328_dts_ca_timing[] = {
++	"ddr3a1_ddr4a9_de-skew",
++	"ddr3a0_ddr4a10_de-skew",
++	"ddr3a3_ddr4a6_de-skew",
++	"ddr3a2_ddr4a4_de-skew",
++	"ddr3a5_ddr4a8_de-skew",
++	"ddr3a4_ddr4a5_de-skew",
++	"ddr3a7_ddr4a11_de-skew",
++	"ddr3a6_ddr4a7_de-skew",
++	"ddr3a9_ddr4a0_de-skew",
++	"ddr3a8_ddr4a13_de-skew",
++	"ddr3a11_ddr4a3_de-skew",
++	"ddr3a10_ddr4cs0_de-skew",
++	"ddr3a13_ddr4a2_de-skew",
++	"ddr3a12_ddr4ba1_de-skew",
++	"ddr3a15_ddr4odt0_de-skew",
++	"ddr3a14_ddr4a1_de-skew",
++	"ddr3ba1_ddr4a15_de-skew",
++	"ddr3ba0_ddr4bg0_de-skew",
++	"ddr3ras_ddr4cke_de-skew",
++	"ddr3ba2_ddr4ba0_de-skew",
++	"ddr3we_ddr4bg1_de-skew",
++	"ddr3cas_ddr4a12_de-skew",
++	"ddr3ckn_ddr4ckn_de-skew",
++	"ddr3ckp_ddr4ckp_de-skew",
++	"ddr3cke_ddr4a16_de-skew",
++	"ddr3odt0_ddr4a14_de-skew",
++	"ddr3cs0_ddr4act_de-skew",
++	"ddr3reset_ddr4reset_de-skew",
++	"ddr3cs1_ddr4cs1_de-skew",
++	"ddr3odt1_ddr4odt1_de-skew",
++};
++
++static const char * const rk3328_dts_cs0_timing[] = {
++	"cs0_dm0_rx_de-skew",
++	"cs0_dm0_tx_de-skew",
++	"cs0_dq0_rx_de-skew",
++	"cs0_dq0_tx_de-skew",
++	"cs0_dq1_rx_de-skew",
++	"cs0_dq1_tx_de-skew",
++	"cs0_dq2_rx_de-skew",
++	"cs0_dq2_tx_de-skew",
++	"cs0_dq3_rx_de-skew",
++	"cs0_dq3_tx_de-skew",
++	"cs0_dq4_rx_de-skew",
++	"cs0_dq4_tx_de-skew",
++	"cs0_dq5_rx_de-skew",
++	"cs0_dq5_tx_de-skew",
++	"cs0_dq6_rx_de-skew",
++	"cs0_dq6_tx_de-skew",
++	"cs0_dq7_rx_de-skew",
++	"cs0_dq7_tx_de-skew",
++	"cs0_dqs0_rx_de-skew",
++	"cs0_dqs0p_tx_de-skew",
++	"cs0_dqs0n_tx_de-skew",
++
++	"cs0_dm1_rx_de-skew",
++	"cs0_dm1_tx_de-skew",
++	"cs0_dq8_rx_de-skew",
++	"cs0_dq8_tx_de-skew",
++	"cs0_dq9_rx_de-skew",
++	"cs0_dq9_tx_de-skew",
++	"cs0_dq10_rx_de-skew",
++	"cs0_dq10_tx_de-skew",
++	"cs0_dq11_rx_de-skew",
++	"cs0_dq11_tx_de-skew",
++	"cs0_dq12_rx_de-skew",
++	"cs0_dq12_tx_de-skew",
++	"cs0_dq13_rx_de-skew",
++	"cs0_dq13_tx_de-skew",
++	"cs0_dq14_rx_de-skew",
++	"cs0_dq14_tx_de-skew",
++	"cs0_dq15_rx_de-skew",
++	"cs0_dq15_tx_de-skew",
++	"cs0_dqs1_rx_de-skew",
++	"cs0_dqs1p_tx_de-skew",
++	"cs0_dqs1n_tx_de-skew",
++
++	"cs0_dm2_rx_de-skew",
++	"cs0_dm2_tx_de-skew",
++	"cs0_dq16_rx_de-skew",
++	"cs0_dq16_tx_de-skew",
++	"cs0_dq17_rx_de-skew",
++	"cs0_dq17_tx_de-skew",
++	"cs0_dq18_rx_de-skew",
++	"cs0_dq18_tx_de-skew",
++	"cs0_dq19_rx_de-skew",
++	"cs0_dq19_tx_de-skew",
++	"cs0_dq20_rx_de-skew",
++	"cs0_dq20_tx_de-skew",
++	"cs0_dq21_rx_de-skew",
++	"cs0_dq21_tx_de-skew",
++	"cs0_dq22_rx_de-skew",
++	"cs0_dq22_tx_de-skew",
++	"cs0_dq23_rx_de-skew",
++	"cs0_dq23_tx_de-skew",
++	"cs0_dqs2_rx_de-skew",
++	"cs0_dqs2p_tx_de-skew",
++	"cs0_dqs2n_tx_de-skew",
++
++	"cs0_dm3_rx_de-skew",
++	"cs0_dm3_tx_de-skew",
++	"cs0_dq24_rx_de-skew",
++	"cs0_dq24_tx_de-skew",
++	"cs0_dq25_rx_de-skew",
++	"cs0_dq25_tx_de-skew",
++	"cs0_dq26_rx_de-skew",
++	"cs0_dq26_tx_de-skew",
++	"cs0_dq27_rx_de-skew",
++	"cs0_dq27_tx_de-skew",
++	"cs0_dq28_rx_de-skew",
++	"cs0_dq28_tx_de-skew",
++	"cs0_dq29_rx_de-skew",
++	"cs0_dq29_tx_de-skew",
++	"cs0_dq30_rx_de-skew",
++	"cs0_dq30_tx_de-skew",
++	"cs0_dq31_rx_de-skew",
++	"cs0_dq31_tx_de-skew",
++	"cs0_dqs3_rx_de-skew",
++	"cs0_dqs3p_tx_de-skew",
++	"cs0_dqs3n_tx_de-skew",
++};
++
++static const char * const rk3328_dts_cs1_timing[] = {
++	"cs1_dm0_rx_de-skew",
++	"cs1_dm0_tx_de-skew",
++	"cs1_dq0_rx_de-skew",
++	"cs1_dq0_tx_de-skew",
++	"cs1_dq1_rx_de-skew",
++	"cs1_dq1_tx_de-skew",
++	"cs1_dq2_rx_de-skew",
++	"cs1_dq2_tx_de-skew",
++	"cs1_dq3_rx_de-skew",
++	"cs1_dq3_tx_de-skew",
++	"cs1_dq4_rx_de-skew",
++	"cs1_dq4_tx_de-skew",
++	"cs1_dq5_rx_de-skew",
++	"cs1_dq5_tx_de-skew",
++	"cs1_dq6_rx_de-skew",
++	"cs1_dq6_tx_de-skew",
++	"cs1_dq7_rx_de-skew",
++	"cs1_dq7_tx_de-skew",
++	"cs1_dqs0_rx_de-skew",
++	"cs1_dqs0p_tx_de-skew",
++	"cs1_dqs0n_tx_de-skew",
++
++	"cs1_dm1_rx_de-skew",
++	"cs1_dm1_tx_de-skew",
++	"cs1_dq8_rx_de-skew",
++	"cs1_dq8_tx_de-skew",
++	"cs1_dq9_rx_de-skew",
++	"cs1_dq9_tx_de-skew",
++	"cs1_dq10_rx_de-skew",
++	"cs1_dq10_tx_de-skew",
++	"cs1_dq11_rx_de-skew",
++	"cs1_dq11_tx_de-skew",
++	"cs1_dq12_rx_de-skew",
++	"cs1_dq12_tx_de-skew",
++	"cs1_dq13_rx_de-skew",
++	"cs1_dq13_tx_de-skew",
++	"cs1_dq14_rx_de-skew",
++	"cs1_dq14_tx_de-skew",
++	"cs1_dq15_rx_de-skew",
++	"cs1_dq15_tx_de-skew",
++	"cs1_dqs1_rx_de-skew",
++	"cs1_dqs1p_tx_de-skew",
++	"cs1_dqs1n_tx_de-skew",
++
++	"cs1_dm2_rx_de-skew",
++	"cs1_dm2_tx_de-skew",
++	"cs1_dq16_rx_de-skew",
++	"cs1_dq16_tx_de-skew",
++	"cs1_dq17_rx_de-skew",
++	"cs1_dq17_tx_de-skew",
++	"cs1_dq18_rx_de-skew",
++	"cs1_dq18_tx_de-skew",
++	"cs1_dq19_rx_de-skew",
++	"cs1_dq19_tx_de-skew",
++	"cs1_dq20_rx_de-skew",
++	"cs1_dq20_tx_de-skew",
++	"cs1_dq21_rx_de-skew",
++	"cs1_dq21_tx_de-skew",
++	"cs1_dq22_rx_de-skew",
++	"cs1_dq22_tx_de-skew",
++	"cs1_dq23_rx_de-skew",
++	"cs1_dq23_tx_de-skew",
++	"cs1_dqs2_rx_de-skew",
++	"cs1_dqs2p_tx_de-skew",
++	"cs1_dqs2n_tx_de-skew",
++
++	"cs1_dm3_rx_de-skew",
++	"cs1_dm3_tx_de-skew",
++	"cs1_dq24_rx_de-skew",
++	"cs1_dq24_tx_de-skew",
++	"cs1_dq25_rx_de-skew",
++	"cs1_dq25_tx_de-skew",
++	"cs1_dq26_rx_de-skew",
++	"cs1_dq26_tx_de-skew",
++	"cs1_dq27_rx_de-skew",
++	"cs1_dq27_tx_de-skew",
++	"cs1_dq28_rx_de-skew",
++	"cs1_dq28_tx_de-skew",
++	"cs1_dq29_rx_de-skew",
++	"cs1_dq29_tx_de-skew",
++	"cs1_dq30_rx_de-skew",
++	"cs1_dq30_tx_de-skew",
++	"cs1_dq31_rx_de-skew",
++	"cs1_dq31_tx_de-skew",
++	"cs1_dqs3_rx_de-skew",
++	"cs1_dqs3p_tx_de-skew",
++	"cs1_dqs3n_tx_de-skew",
++};
++
++struct rk3328_ddr_dts_config_timing {
++	unsigned int ddr3_speed_bin;
++	unsigned int ddr4_speed_bin;
++	unsigned int pd_idle;
++	unsigned int sr_idle;
++	unsigned int sr_mc_gate_idle;
++	unsigned int srpd_lite_idle;
++	unsigned int standby_idle;
++
++	unsigned int auto_pd_dis_freq;
++	unsigned int auto_sr_dis_freq;
++	/* for ddr3 only */
++	unsigned int ddr3_dll_dis_freq;
++	/* for ddr4 only */
++	unsigned int ddr4_dll_dis_freq;
++	unsigned int phy_dll_dis_freq;
++
++	unsigned int ddr3_odt_dis_freq;
++	unsigned int phy_ddr3_odt_dis_freq;
++	unsigned int ddr3_drv;
++	unsigned int ddr3_odt;
++	unsigned int phy_ddr3_ca_drv;
++	unsigned int phy_ddr3_ck_drv;
++	unsigned int phy_ddr3_dq_drv;
++	unsigned int phy_ddr3_odt;
++
++	unsigned int lpddr3_odt_dis_freq;
++	unsigned int phy_lpddr3_odt_dis_freq;
++	unsigned int lpddr3_drv;
++	unsigned int lpddr3_odt;
++	unsigned int phy_lpddr3_ca_drv;
++	unsigned int phy_lpddr3_ck_drv;
++	unsigned int phy_lpddr3_dq_drv;
++	unsigned int phy_lpddr3_odt;
++
++	unsigned int lpddr4_odt_dis_freq;
++	unsigned int phy_lpddr4_odt_dis_freq;
++	unsigned int lpddr4_drv;
++	unsigned int lpddr4_dq_odt;
++	unsigned int lpddr4_ca_odt;
++	unsigned int phy_lpddr4_ca_drv;
++	unsigned int phy_lpddr4_ck_cs_drv;
++	unsigned int phy_lpddr4_dq_drv;
++	unsigned int phy_lpddr4_odt;
++
++	unsigned int ddr4_odt_dis_freq;
++	unsigned int phy_ddr4_odt_dis_freq;
++	unsigned int ddr4_drv;
++	unsigned int ddr4_odt;
++	unsigned int phy_ddr4_ca_drv;
++	unsigned int phy_ddr4_ck_drv;
++	unsigned int phy_ddr4_dq_drv;
++	unsigned int phy_ddr4_odt;
++
++	unsigned int ca_skew[15];
++	unsigned int cs0_skew[44];
++	unsigned int cs1_skew[44];
++
++	unsigned int available;
++};
++
++struct rk3328_ddr_de_skew_setting {
++	unsigned int ca_de_skew[30];
++	unsigned int cs0_de_skew[84];
++	unsigned int cs1_de_skew[84];
++};
++
++struct rk3328_dmcfreq {
++	struct device *dev;
++	struct devfreq *devfreq;
++	struct devfreq_simple_ondemand_data ondemand_data;
++	struct clk *dmc_clk;
++	struct devfreq_event_dev *edev;
++	struct mutex lock;
++	struct regulator *vdd_center;
++	unsigned long rate, target_rate;
++	unsigned long volt, target_volt;
++
++	int (*set_auto_self_refresh)(u32 en);
++};
++
++static void
++rk3328_de_skew_setting_2_register(struct rk3328_ddr_de_skew_setting *de_skew,
++				  struct rk3328_ddr_dts_config_timing *tim)
++{
++	u32 n;
++	u32 offset;
++	u32 shift;
++
++	memset_io(tim->ca_skew, 0, sizeof(tim->ca_skew));
++	memset_io(tim->cs0_skew, 0, sizeof(tim->cs0_skew));
++	memset_io(tim->cs1_skew, 0, sizeof(tim->cs1_skew));
++
++	/* CA de-skew */
++	for (n = 0; n < ARRAY_SIZE(de_skew->ca_de_skew); n++) {
++		offset = n / 2;
++		shift = n % 2;
++		/* 0 => 4; 1 => 0 */
++		shift = (shift == 0) ? 4 : 0;
++		tim->ca_skew[offset] &= ~(0xf << shift);
++		tim->ca_skew[offset] |= (de_skew->ca_de_skew[n] << shift);
++	}
++
++	/* CS0 data de-skew */
++	for (n = 0; n < ARRAY_SIZE(de_skew->cs0_de_skew); n++) {
++		offset = ((n / 21) * 11) + ((n % 21) / 2);
++		shift = ((n % 21) % 2);
++		if ((n % 21) == 20)
++			shift = 0;
++		else
++			/* 0 => 4; 1 => 0 */
++			shift = (shift == 0) ? 4 : 0;
++		tim->cs0_skew[offset] &= ~(0xf << shift);
++		tim->cs0_skew[offset] |= (de_skew->cs0_de_skew[n] << shift);
++	}
++
++	/* CS1 data de-skew */
++	for (n = 0; n < ARRAY_SIZE(de_skew->cs1_de_skew); n++) {
++		offset = ((n / 21) * 11) + ((n % 21) / 2);
++		shift = ((n % 21) % 2);
++		if ((n % 21) == 20)
++			shift = 0;
++		else
++			/* 0 => 4; 1 => 0 */
++			shift = (shift == 0) ? 4 : 0;
++		tim->cs1_skew[offset] &= ~(0xf << shift);
++		tim->cs1_skew[offset] |= (de_skew->cs1_de_skew[n] << shift);
++	}
++}
++
++static void of_get_rk3328_timings(struct device *dev,
++				  struct device_node *np, uint32_t *timing)
++{
++	struct device_node *np_tim;
++	u32 *p;
++	struct rk3328_ddr_dts_config_timing *dts_timing;
++	struct rk3328_ddr_de_skew_setting *de_skew;
++	int ret = 0;
++	u32 i;
++
++	dts_timing =
++		(struct rk3328_ddr_dts_config_timing *)(timing +
++							DTS_PAR_OFFSET / 4);
++
++	np_tim = of_parse_phandle(np, "ddr_timing", 0);
++	if (!np_tim) {
++		ret = -EINVAL;
++		goto end;
++	}
++	de_skew = kmalloc(sizeof(*de_skew), GFP_KERNEL);
++	if (!de_skew) {
++		ret = -ENOMEM;
++		goto end;
++	}
++
++	p = (u32 *)dts_timing;
++	for (i = 0; i < ARRAY_SIZE(rk3328_dts_timing); i++) {
++		ret |= of_property_read_u32(np_tim, rk3328_dts_timing[i],
++					p + i);
++	}
++	p = (u32 *)de_skew->ca_de_skew;
++	for (i = 0; i < ARRAY_SIZE(rk3328_dts_ca_timing); i++) {
++		ret |= of_property_read_u32(np_tim, rk3328_dts_ca_timing[i],
++					p + i);
++	}
++	p = (u32 *)de_skew->cs0_de_skew;
++	for (i = 0; i < ARRAY_SIZE(rk3328_dts_cs0_timing); i++) {
++		ret |= of_property_read_u32(np_tim, rk3328_dts_cs0_timing[i],
++					p + i);
++	}
++	p = (u32 *)de_skew->cs1_de_skew;
++	for (i = 0; i < ARRAY_SIZE(rk3328_dts_cs1_timing); i++) {
++		ret |= of_property_read_u32(np_tim, rk3328_dts_cs1_timing[i],
++					p + i);
++	}
++	if (!ret)
++		rk3328_de_skew_setting_2_register(de_skew, dts_timing);
++
++	kfree(de_skew);
++end:
++	if (!ret) {
++		dts_timing->available = 1;
++	} else {
++		dts_timing->available = 0;
++		dev_err(dev, "of_get_ddr_timings: fail\n");
++	}
++
++	of_node_put(np_tim);
++}
++
++static int rockchip_ddr_set_auto_self_refresh(uint32_t en)
++{
++	struct arm_smccc_res res;
++
++	ddr_psci_param->sr_idle_en = en;
++
++	arm_smccc_smc(ROCKCHIP_SIP_DRAM_FREQ,
++		      SHARE_PAGE_TYPE_DDR, 0, ROCKCHIP_SIP_CONFIG_DRAM_SET_AT_SR,
++		      0, 0, 0, 0, &res);
++
++	return res.a0;
++}
++
++static int rk3328_dmc_init(struct platform_device *pdev,
++			   struct rk3328_dmcfreq *dmcfreq)
++{
++	struct arm_smccc_res res;
++	u32 size, page_num;
++
++	arm_smccc_smc(ROCKCHIP_SIP_DRAM_FREQ,
++		      0, 0, ROCKCHIP_SIP_CONFIG_DRAM_GET_VERSION,
++		      0, 0, 0, 0, &res);
++	if (res.a0 || (res.a1 < 0x101)) {
++		dev_err(&pdev->dev,
++			"trusted firmware need to update or is invalid\n");
++		return -ENXIO;
++	}
++
++	dev_notice(&pdev->dev, "current ATF version 0x%lx\n", res.a1);
++
++	/*
++	 * first 4KB is used for interface parameters
++	 * after 4KB * N is dts parameters
++	 */
++	size = sizeof(struct rk3328_ddr_dts_config_timing);
++	page_num = DIV_ROUND_UP(size, 4096) + 1;
++
++	arm_smccc_smc(ROCKCHIP_SIP_SHARE_MEM,
++		      page_num, SHARE_PAGE_TYPE_DDR, 0,
++		      0, 0, 0, 0, &res);
++	if (res.a0 != 0) {
++		dev_err(&pdev->dev, "no ATF memory for init\n");
++		return -ENOMEM;
++	}
++
++	ddr_psci_param = ioremap(res.a1, page_num << 12);
++	of_get_rk3328_timings(&pdev->dev, pdev->dev.of_node,
++			      (uint32_t *)ddr_psci_param);
++
++	arm_smccc_smc(ROCKCHIP_SIP_DRAM_FREQ,
++		      SHARE_PAGE_TYPE_DDR, 0, ROCKCHIP_SIP_CONFIG_DRAM_INIT,
++		      0, 0, 0, 0, &res);
++	if (res.a0) {
++		dev_err(&pdev->dev, "Rockchip dram init error %lx\n", res.a0);
++		return -ENOMEM;
++	}
++
++	dmcfreq->set_auto_self_refresh = rockchip_ddr_set_auto_self_refresh;
++
++	return 0;
++}
++
++static int rk3328_dmcfreq_target(struct device *dev, unsigned long *freq,
++				 u32 flags)
++{
++	struct rk3328_dmcfreq *dmcfreq = dev_get_drvdata(dev);
++	struct dev_pm_opp *opp;
++	unsigned long old_clk_rate = dmcfreq->rate;
++	unsigned long target_volt, target_rate;
++	int err;
++
++	opp = devfreq_recommended_opp(dev, freq, flags);
++	if (IS_ERR(opp))
++		return PTR_ERR(opp);
++
++	target_rate = dev_pm_opp_get_freq(opp);
++	target_volt = dev_pm_opp_get_voltage(opp);
++	dev_pm_opp_put(opp);
++
++	if (dmcfreq->rate == target_rate)
++		return 0;
++
++	mutex_lock(&dmcfreq->lock);
++
++	/*
++	 * If frequency scaling from low to high, adjust voltage first.
++	 * If frequency scaling from high to low, adjust frequency first.
++	 */
++	if (old_clk_rate < target_rate) {
++		err = regulator_set_voltage(dmcfreq->vdd_center, target_volt,
++					    target_volt);
++		if (err) {
++			dev_err(dev, "Cannot set voltage %lu uV\n",
++				target_volt);
++			goto out;
++		}
++	}
++
++	err = clk_set_rate(dmcfreq->dmc_clk, target_rate);
++	if (err) {
++		dev_err(dev, "Cannot set frequency %lu (%d)\n", target_rate,
++			err);
++		regulator_set_voltage(dmcfreq->vdd_center, dmcfreq->volt,
++				      dmcfreq->volt);
++		goto out;
++	}
++
++	/*
++	 * Check the dpll rate,
++	 * There only two result we will get,
++	 * 1. Ddr frequency scaling fail, we still get the old rate.
++	 * 2. Ddr frequency scaling sucessful, we get the rate we set.
++	 */
++	dmcfreq->rate = clk_get_rate(dmcfreq->dmc_clk);
++
++	/* If get the incorrect rate, set voltage to old value. */
++	if (dmcfreq->rate != target_rate) {
++		dev_err(dev, "Got wrong frequency, Request %lu, Current %lu\n",
++			target_rate, dmcfreq->rate);
++		regulator_set_voltage(dmcfreq->vdd_center, dmcfreq->volt,
++				      dmcfreq->volt);
++		goto out;
++	} else if (old_clk_rate > target_rate)
++		err = regulator_set_voltage(dmcfreq->vdd_center, target_volt,
++					    target_volt);
++	if (err)
++		dev_err(dev, "Cannot set voltage %lu uV\n", target_volt);
++
++	dmcfreq->rate = target_rate;
++	dmcfreq->volt = target_volt;
++
++out:
++	mutex_unlock(&dmcfreq->lock);
++	return err;
++}
++
++static int rk3328_dmcfreq_get_dev_status(struct device *dev,
++					 struct devfreq_dev_status *stat)
++{
++	struct rk3328_dmcfreq *dmcfreq = dev_get_drvdata(dev);
++	struct devfreq_event_data edata;
++	int ret = 0;
++
++	ret = devfreq_event_get_event(dmcfreq->edev, &edata);
++	if (ret < 0)
++		return ret;
++
++	stat->current_frequency = dmcfreq->rate;
++	stat->busy_time = edata.load_count;
++	stat->total_time = edata.total_count;
++
++	return ret;
++}
++
++static int rk3328_dmcfreq_get_cur_freq(struct device *dev, unsigned long *freq)
++{
++	struct rk3328_dmcfreq *dmcfreq = dev_get_drvdata(dev);
++
++	*freq = dmcfreq->rate;
++
++	return 0;
++}
++
++static struct devfreq_dev_profile rk3328_devfreq_dmc_profile = {
++	.polling_ms	= 200,
++	.target		= rk3328_dmcfreq_target,
++	.get_dev_status	= rk3328_dmcfreq_get_dev_status,
++	.get_cur_freq	= rk3328_dmcfreq_get_cur_freq,
++};
++
++static __maybe_unused int rk3328_dmcfreq_suspend(struct device *dev)
++{
++	struct rk3328_dmcfreq *dmcfreq = dev_get_drvdata(dev);
++	int ret = 0;
++
++	ret = devfreq_event_disable_edev(dmcfreq->edev);
++	if (ret < 0) {
++		dev_err(dev, "failed to disable the devfreq-event devices\n");
++		return ret;
++	}
++
++	ret = devfreq_suspend_device(dmcfreq->devfreq);
++	if (ret < 0) {
++		dev_err(dev, "failed to suspend the devfreq devices\n");
++		return ret;
++	}
++
++	return 0;
++}
++
++static __maybe_unused int rk3328_dmcfreq_resume(struct device *dev)
++{
++	struct rk3328_dmcfreq *dmcfreq = dev_get_drvdata(dev);
++	int ret = 0;
++
++	ret = devfreq_event_enable_edev(dmcfreq->edev);
++	if (ret < 0) {
++		dev_err(dev, "failed to enable the devfreq-event devices\n");
++		return ret;
++	}
++
++	ret = devfreq_resume_device(dmcfreq->devfreq);
++	if (ret < 0) {
++		dev_err(dev, "failed to resume the devfreq devices\n");
++		return ret;
++	}
++	return ret;
++}
++
++static SIMPLE_DEV_PM_OPS(rk3328_dmcfreq_pm, rk3328_dmcfreq_suspend,
++			 rk3328_dmcfreq_resume);
++
++static int rk3328_dmcfreq_probe(struct platform_device *pdev)
++{
++	struct device *dev = &pdev->dev;
++	struct device_node *np = pdev->dev.of_node;
++	struct rk3328_dmcfreq *data;
++	struct dev_pm_opp *opp;
++	int ret;
++
++	data = devm_kzalloc(dev, sizeof(struct rk3328_dmcfreq), GFP_KERNEL);
++	if (!data)
++		return -ENOMEM;
++
++	mutex_init(&data->lock);
++
++	data->vdd_center = devm_regulator_get(dev, "center");
++	if (IS_ERR(data->vdd_center)) {
++		if (PTR_ERR(data->vdd_center) == -EPROBE_DEFER)
++			return -EPROBE_DEFER;
++
++		dev_err(dev, "Cannot get the regulator \"center\"\n");
++		return PTR_ERR(data->vdd_center);
++	}
++
++	data->dmc_clk = devm_clk_get(dev, "dmc_clk");
++	if (IS_ERR(data->dmc_clk)) {
++		if (PTR_ERR(data->dmc_clk) == -EPROBE_DEFER)
++			return -EPROBE_DEFER;
++
++		dev_err(dev, "Cannot get the clk dmc_clk\n");
++		return PTR_ERR(data->dmc_clk);
++	}
++
++	data->edev = devfreq_event_get_edev_by_phandle(dev, 0);
++	if (IS_ERR(data->edev))
++		return -EPROBE_DEFER;
++
++	ret = devfreq_event_enable_edev(data->edev);
++	if (ret < 0) {
++		dev_err(dev, "failed to enable devfreq-event devices\n");
++		return ret;
++	}
++
++	ret = rk3328_dmc_init(pdev, data);
++	if (ret)
++		return ret;
++
++	/*
++	 * We add a devfreq driver to our parent since it has a device tree node
++	 * with operating points.
++	 */
++	if (dev_pm_opp_of_add_table(dev)) {
++		dev_err(dev, "Invalid operating-points in device tree.\n");
++		return -EINVAL;
++	}
++
++	of_property_read_u32(np, "upthreshold",
++			     &data->ondemand_data.upthreshold);
++	of_property_read_u32(np, "downdifferential",
++			     &data->ondemand_data.downdifferential);
++
++	data->rate = clk_get_rate(data->dmc_clk);
++
++	opp = devfreq_recommended_opp(dev, &data->rate, 0);
++	if (IS_ERR(opp)) {
++		ret = PTR_ERR(opp);
++		goto err_free_opp;
++	}
++
++	data->rate = dev_pm_opp_get_freq(opp);
++	data->volt = dev_pm_opp_get_voltage(opp);
++	dev_pm_opp_put(opp);
++
++	rk3328_devfreq_dmc_profile.initial_freq = data->rate;
++
++	data->devfreq = devm_devfreq_add_device(dev,
++					   &rk3328_devfreq_dmc_profile,
++					   DEVFREQ_GOV_SIMPLE_ONDEMAND,
++					   &data->ondemand_data);
++	if (IS_ERR(data->devfreq)) {
++		ret = PTR_ERR(data->devfreq);
++		goto err_free_opp;
++	}
++
++	devm_devfreq_register_opp_notifier(dev, data->devfreq);
++
++	data->dev = dev;
++	platform_set_drvdata(pdev, data);
++
++	return 0;
++
++err_free_opp:
++	dev_pm_opp_of_remove_table(&pdev->dev);
++	return ret;
++}
++
++static int rk3328_dmcfreq_remove(struct platform_device *pdev)
++{
++	struct rk3328_dmcfreq *dmcfreq = dev_get_drvdata(&pdev->dev);
++
++	/*
++	 * Before remove the opp table we need to unregister the opp notifier.
++	 */
++	devm_devfreq_unregister_opp_notifier(dmcfreq->dev, dmcfreq->devfreq);
++	dev_pm_opp_of_remove_table(dmcfreq->dev);
++
++	return 0;
++}
++
++static const struct of_device_id rk3328dmc_devfreq_of_match[] = {
++	{ .compatible = "rockchip,rk3328-dmc" },
++	{ },
++};
++MODULE_DEVICE_TABLE(of, rk3328dmc_devfreq_of_match);
++
++static struct platform_driver rk3328_dmcfreq_driver = {
++	.probe	= rk3328_dmcfreq_probe,
++	.remove = rk3328_dmcfreq_remove,
++	.driver = {
++		.name	= "rk3328-dmc-freq",
++		.pm	= &rk3328_dmcfreq_pm,
++		.of_match_table = rk3328dmc_devfreq_of_match,
++	},
++};
++module_platform_driver(rk3328_dmcfreq_driver);
++
++MODULE_LICENSE("GPL v2");
++MODULE_AUTHOR("Lin Huang <hl@rock-chips.com>");
++MODULE_DESCRIPTION("RK3328 dmcfreq driver with devfreq framework");
+From ce6d3614888e6358466f0e84e248177a6bca5258 Mon Sep 17 00:00:00 2001
+From: Tang Yun ping <typ@rock-chips.com>
+Date: Thu, 4 May 2017 20:49:58 +0800
+Subject: [PATCH] clk: rockchip: support setting ddr clock via SIP Version 2
+ APIs
+
+commit 764e893ee82321938fc6f4349e9e7caf06a04410 rockchip.
+
+Signed-off-by: Tang Yun ping <typ@rock-chips.com>
+Signed-off-by: hmz007 <hmz007@gmail.com>
+---
+ drivers/clk/rockchip/clk-ddr.c      | 130 ++++++++++++++++++++++++++++
+ drivers/clk/rockchip/clk-rk3328.c   |   7 +-
+ drivers/clk/rockchip/clk.h          |   3 +-
+ include/soc/rockchip/rockchip_sip.h |  11 +++
+ 4 files changed, 147 insertions(+), 4 deletions(-)
+
+diff --git a/drivers/clk/rockchip/clk-ddr.c b/drivers/clk/rockchip/clk-ddr.c
+index 9273bce4d7b6..555aaf4e758d 100644
+--- a/drivers/clk/rockchip/clk-ddr.c
++++ b/drivers/clk/rockchip/clk-ddr.c
+@@ -87,6 +87,133 @@ static const struct clk_ops rockchip_ddrclk_sip_ops = {
+ 	.get_parent = rockchip_ddrclk_get_parent,
+ };
+
++/* See v4.4/include/dt-bindings/display/rk_fb.h */
++#define SCREEN_NULL			0
++#define SCREEN_HDMI			6
++
++static inline int rk_drm_get_lcdc_type(void)
++{
++	return SCREEN_NULL;
++}
++
++struct share_params {
++	u32 hz;
++	u32 lcdc_type;
++	u32 vop;
++	u32 vop_dclk_mode;
++	u32 sr_idle_en;
++	u32 addr_mcu_el3;
++	/*
++	 * 1: need to wait flag1
++	 * 0: never wait flag1
++	 */
++	u32 wait_flag1;
++	/*
++	 * 1: need to wait flag1
++	 * 0: never wait flag1
++	 */
++	u32 wait_flag0;
++	u32 complt_hwirq;
++	 /* if need, add parameter after */
++};
++
++struct rockchip_ddrclk_data {
++	u32 inited_flag;
++	void __iomem *share_memory;
++};
++
++static struct rockchip_ddrclk_data ddr_data;
++
++static void rockchip_ddrclk_data_init(void)
++{
++	struct arm_smccc_res res;
++
++	arm_smccc_smc(ROCKCHIP_SIP_SHARE_MEM,
++		      1, SHARE_PAGE_TYPE_DDR, 0,
++		      0, 0, 0, 0, &res);
++
++	if (!res.a0) {
++		ddr_data.share_memory = (void __iomem *)ioremap(res.a1, 1<<12);
++		ddr_data.inited_flag = 1;
++	}
++}
++
++static int rockchip_ddrclk_sip_set_rate_v2(struct clk_hw *hw,
++					   unsigned long drate,
++					   unsigned long prate)
++{
++	struct share_params *p;
++	struct arm_smccc_res res;
++
++	if (!ddr_data.inited_flag)
++		rockchip_ddrclk_data_init();
++
++	p = (struct share_params *)ddr_data.share_memory;
++
++	p->hz = drate;
++	p->lcdc_type = rk_drm_get_lcdc_type();
++	p->wait_flag1 = 1;
++	p->wait_flag0 = 1;
++
++	arm_smccc_smc(ROCKCHIP_SIP_DRAM_FREQ,
++		      SHARE_PAGE_TYPE_DDR, 0,
++		      ROCKCHIP_SIP_CONFIG_DRAM_SET_RATE,
++		      0, 0, 0, 0, &res);
++
++	if ((int)res.a1 == -6) {
++		pr_err("%s: timeout, drate = %lumhz\n", __func__, drate/1000000);
++		/* TODO: rockchip_dmcfreq_wait_complete(); */
++	}
++
++	return res.a0;
++}
++
++static unsigned long rockchip_ddrclk_sip_recalc_rate_v2
++			(struct clk_hw *hw, unsigned long parent_rate)
++{
++	struct arm_smccc_res res;
++
++	arm_smccc_smc(ROCKCHIP_SIP_DRAM_FREQ,
++		      SHARE_PAGE_TYPE_DDR, 0,
++		      ROCKCHIP_SIP_CONFIG_DRAM_GET_RATE,
++		      0, 0, 0, 0, &res);
++	if (!res.a0)
++		return res.a1;
++	else
++		return 0;
++}
++
++static long rockchip_ddrclk_sip_round_rate_v2(struct clk_hw *hw,
++					      unsigned long rate,
++					      unsigned long *prate)
++{
++	struct share_params *p;
++	struct arm_smccc_res res;
++
++	if (!ddr_data.inited_flag)
++		rockchip_ddrclk_data_init();
++
++	p = (struct share_params *)ddr_data.share_memory;
++
++	p->hz = rate;
++
++	arm_smccc_smc(ROCKCHIP_SIP_DRAM_FREQ,
++		      SHARE_PAGE_TYPE_DDR, 0,
++		      ROCKCHIP_SIP_CONFIG_DRAM_ROUND_RATE,
++		      0, 0, 0, 0, &res);
++	if (!res.a0)
++		return res.a1;
++	else
++		return 0;
++}
++
++static const struct clk_ops rockchip_ddrclk_sip_ops_v2 = {
++	.recalc_rate = rockchip_ddrclk_sip_recalc_rate_v2,
++	.set_rate = rockchip_ddrclk_sip_set_rate_v2,
++	.round_rate = rockchip_ddrclk_sip_round_rate_v2,
++	.get_parent = rockchip_ddrclk_get_parent,
++};
++
+ struct clk *rockchip_clk_register_ddrclk(const char *name, int flags,
+ 					 const char *const *parent_names,
+ 					 u8 num_parents, int mux_offset,
+@@ -114,6 +241,9 @@ struct clk *rockchip_clk_register_ddrclk(const char *name, int flags,
+ 	case ROCKCHIP_DDRCLK_SIP:
+ 		init.ops = &rockchip_ddrclk_sip_ops;
+ 		break;
++	case ROCKCHIP_DDRCLK_SIP_V2:
++		init.ops = &rockchip_ddrclk_sip_ops_v2;
++		break;
+ 	default:
+ 		pr_err("%s: unsupported ddrclk type %d\n", __func__, ddr_flag);
+ 		kfree(ddrclk);
+diff --git a/drivers/clk/rockchip/clk-rk3328.c b/drivers/clk/rockchip/clk-rk3328.c
+index c186a1985bf4..ac6e6163a232 100644
+--- a/drivers/clk/rockchip/clk-rk3328.c
++++ b/drivers/clk/rockchip/clk-rk3328.c
+@@ -314,9 +314,10 @@ static struct rockchip_clk_branch rk3328_clk_branches[] __initdata = {
+ 			RK3328_CLKGATE_CON(14), 1, GFLAGS),
+
+ 	/* PD_DDR */
+-	COMPOSITE(0, "clk_ddr", mux_ddrphy_p, CLK_IGNORE_UNUSED,
+-			RK3328_CLKSEL_CON(3), 8, 2, MFLAGS, 0, 3, DFLAGS | CLK_DIVIDER_POWER_OF_TWO,
+-			RK3328_CLKGATE_CON(0), 4, GFLAGS),
++	COMPOSITE_DDRCLK(SCLK_DDRCLK, "sclk_ddrc", mux_ddrphy_p, 0,
++			RK3328_CLKSEL_CON(3), 8, 2, 0, 3,
++			ROCKCHIP_DDRCLK_SIP_V2),
++
+ 	GATE(0, "clk_ddrmsch", "clk_ddr", CLK_IGNORE_UNUSED,
+ 			RK3328_CLKGATE_CON(18), 6, GFLAGS),
+ 	GATE(0, "clk_ddrupctl", "clk_ddr", CLK_IGNORE_UNUSED,
+diff --git a/drivers/clk/rockchip/clk.h b/drivers/clk/rockchip/clk.h
+index 2271a84124b0..7405aaf965ec 100644
+--- a/drivers/clk/rockchip/clk.h
++++ b/drivers/clk/rockchip/clk.h
+@@ -362,7 +362,8 @@ struct clk *rockchip_clk_register_mmc(const char *name,
+  * DDRCLK flags, including method of setting the rate
+  * ROCKCHIP_DDRCLK_SIP: use SIP call to bl31 to change ddrclk rate.
+  */
+-#define ROCKCHIP_DDRCLK_SIP		BIT(0)
++#define ROCKCHIP_DDRCLK_SIP		0x01
++#define ROCKCHIP_DDRCLK_SIP_V2		0x03
+
+ struct clk *rockchip_clk_register_ddrclk(const char *name, int flags,
+ 					 const char *const *parent_names,
+diff --git a/include/soc/rockchip/rockchip_sip.h b/include/soc/rockchip/rockchip_sip.h
+index c46a9ae2a2ab..fa7e0a2d72cc 100644
+--- a/include/soc/rockchip/rockchip_sip.h
++++ b/include/soc/rockchip/rockchip_sip.h
+@@ -16,5 +16,16 @@
+ #define ROCKCHIP_SIP_CONFIG_DRAM_CLR_IRQ	0x06
+ #define ROCKCHIP_SIP_CONFIG_DRAM_SET_PARAM	0x07
+ #define ROCKCHIP_SIP_CONFIG_DRAM_SET_ODT_PD	0x08
++#define ROCKCHIP_SIP_CONFIG_DRAM_GET_VERSION	0x08
++
++#define ROCKCHIP_SIP_SHARE_MEM			0x82000009
++
++/* Share mem page types */
++typedef enum {
++    SHARE_PAGE_TYPE_INVALID = 0,
++    SHARE_PAGE_TYPE_UARTDBG,
++    SHARE_PAGE_TYPE_DDR,
++    SHARE_PAGE_TYPE_MAX,
++} share_page_type_t;
+
+ #endif
+From 4db93c6dad0c71750b86163df2fdb21c35f00d9a Mon Sep 17 00:00:00 2001
+From: hmz007 <hmz007@gmail.com>
+Date: Tue, 19 Nov 2019 12:49:48 +0800
+Subject: [PATCH] PM / devfreq: rockchip-dfi: add more soc support
+
+Signed-off-by: hmz007 <hmz007@gmail.com>
+---
+ drivers/devfreq/event/rockchip-dfi.c | 554 ++++++++++++++++++++++++---
+ 1 file changed, 505 insertions(+), 49 deletions(-)
+
+diff --git a/drivers/devfreq/event/rockchip-dfi.c b/drivers/devfreq/event/rockchip-dfi.c
+index 5d1042188727..80be0efdfb9b 100644
+--- a/drivers/devfreq/event/rockchip-dfi.c
++++ b/drivers/devfreq/event/rockchip-dfi.c
+@@ -18,25 +18,66 @@
+ #include <linux/list.h>
+ #include <linux/of.h>
+ 
+-#include <soc/rockchip/rk3399_grf.h>
+-
+-#define RK3399_DMC_NUM_CH	2
+-
++#define PX30_PMUGRF_OS_REG2		0x208
++
++#define RK3128_GRF_SOC_CON0		0x140
++#define RK3128_GRF_OS_REG1		0x1cc
++#define RK3128_GRF_DFI_WRNUM		0x220
++#define RK3128_GRF_DFI_RDNUM		0x224
++#define RK3128_GRF_DFI_TIMERVAL		0x22c
++#define RK3128_DDR_MONITOR_EN		((1 << (16 + 6)) + (1 << 6))
++#define RK3128_DDR_MONITOR_DISB		((1 << (16 + 6)) + (0 << 6))
++
++#define RK3288_PMU_SYS_REG2		0x9c
++#define RK3288_GRF_SOC_CON4		0x254
++#define RK3288_GRF_SOC_STATUS(n)	(0x280 + (n) * 4)
++#define RK3288_DFI_EN			(0x30003 << 14)
++#define RK3288_DFI_DIS			(0x30000 << 14)
++#define RK3288_LPDDR_SEL		(0x10001 << 13)
++#define RK3288_DDR3_SEL			(0x10000 << 13)
++
++#define RK3328_GRF_OS_REG2		0x5d0
++
++#define RK3368_GRF_DDRC0_CON0		0x600
++#define RK3368_GRF_SOC_STATUS5		0x494
++#define RK3368_GRF_SOC_STATUS6		0x498
++#define RK3368_GRF_SOC_STATUS8		0x4a0
++#define RK3368_GRF_SOC_STATUS9		0x4a4
++#define RK3368_GRF_SOC_STATUS10		0x4a8
++#define RK3368_DFI_EN			(0x30003 << 5)
++#define RK3368_DFI_DIS			(0x30000 << 5)
++
++#define MAX_DMC_NUM_CH			2
++#define READ_DRAMTYPE_INFO(n)		(((n) >> 13) & 0x7)
++#define READ_CH_INFO(n)			(((n) >> 28) & 0x3)
+ /* DDRMON_CTRL */
+-#define DDRMON_CTRL	0x04
+-#define CLR_DDRMON_CTRL	(0x1f0000 << 0)
+-#define LPDDR4_EN	(0x10001 << 4)
+-#define HARDWARE_EN	(0x10001 << 3)
+-#define LPDDR3_EN	(0x10001 << 2)
+-#define SOFTWARE_EN	(0x10001 << 1)
+-#define SOFTWARE_DIS	(0x10000 << 1)
+-#define TIME_CNT_EN	(0x10001 << 0)
++#define DDRMON_CTRL			0x04
++#define CLR_DDRMON_CTRL			(0x3f0000 << 0)
++#define DDR4_EN				(0x10001 << 5)
++#define LPDDR4_EN			(0x10001 << 4)
++#define HARDWARE_EN			(0x10001 << 3)
++#define LPDDR2_3_EN			(0x10001 << 2)
++#define SOFTWARE_EN			(0x10001 << 1)
++#define SOFTWARE_DIS			(0x10000 << 1)
++#define TIME_CNT_EN			(0x10001 << 0)
+ 
+ #define DDRMON_CH0_COUNT_NUM		0x28
+ #define DDRMON_CH0_DFI_ACCESS_NUM	0x2c
+ #define DDRMON_CH1_COUNT_NUM		0x3c
+ #define DDRMON_CH1_DFI_ACCESS_NUM	0x40
+ 
++/* pmu grf */
++#define PMUGRF_OS_REG2			0x308
++
++enum {
++	DDR4 = 0,
++	DDR3 = 3,
++	LPDDR2 = 5,
++	LPDDR3 = 6,
++	LPDDR4 = 7,
++	UNUSED = 0xFF
++};
++
+ struct dmc_usage {
+ 	u32 access;
+ 	u32 total;
+@@ -50,33 +91,261 @@ struct dmc_usage {
+ struct rockchip_dfi {
+ 	struct devfreq_event_dev *edev;
+ 	struct devfreq_event_desc *desc;
+-	struct dmc_usage ch_usage[RK3399_DMC_NUM_CH];
++	struct dmc_usage ch_usage[MAX_DMC_NUM_CH];
+ 	struct device *dev;
+ 	void __iomem *regs;
+ 	struct regmap *regmap_pmu;
++	struct regmap *regmap_grf;
++	struct regmap *regmap_pmugrf;
+ 	struct clk *clk;
++	u32 dram_type;
++	/*
++	 * available mask, 1: available, 0: not available
++	 * each bit represent a channel
++	 */
++	u32 ch_msk;
++};
++
++static void rk3128_dfi_start_hardware_counter(struct devfreq_event_dev *edev)
++{
++	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
++
++	regmap_write(info->regmap_grf,
++		     RK3128_GRF_SOC_CON0,
++		     RK3128_DDR_MONITOR_EN);
++}
++
++static void rk3128_dfi_stop_hardware_counter(struct devfreq_event_dev *edev)
++{
++	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
++
++	regmap_write(info->regmap_grf,
++		     RK3128_GRF_SOC_CON0,
++		     RK3128_DDR_MONITOR_DISB);
++}
++
++static int rk3128_dfi_disable(struct devfreq_event_dev *edev)
++{
++	rk3128_dfi_stop_hardware_counter(edev);
++
++	return 0;
++}
++
++static int rk3128_dfi_enable(struct devfreq_event_dev *edev)
++{
++	rk3128_dfi_start_hardware_counter(edev);
++
++	return 0;
++}
++
++static int rk3128_dfi_set_event(struct devfreq_event_dev *edev)
++{
++	return 0;
++}
++
++static int rk3128_dfi_get_event(struct devfreq_event_dev *edev,
++				struct devfreq_event_data *edata)
++{
++	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
++	unsigned long flags;
++	u32 dfi_wr, dfi_rd, dfi_timer;
++
++	local_irq_save(flags);
++
++	rk3128_dfi_stop_hardware_counter(edev);
++
++	regmap_read(info->regmap_grf, RK3128_GRF_DFI_WRNUM, &dfi_wr);
++	regmap_read(info->regmap_grf, RK3128_GRF_DFI_RDNUM, &dfi_rd);
++	regmap_read(info->regmap_grf, RK3128_GRF_DFI_TIMERVAL, &dfi_timer);
++
++	edata->load_count = (dfi_wr + dfi_rd) * 4;
++	edata->total_count = dfi_timer;
++
++	rk3128_dfi_start_hardware_counter(edev);
++
++	local_irq_restore(flags);
++
++	return 0;
++}
++
++static const struct devfreq_event_ops rk3128_dfi_ops = {
++	.disable = rk3128_dfi_disable,
++	.enable = rk3128_dfi_enable,
++	.get_event = rk3128_dfi_get_event,
++	.set_event = rk3128_dfi_set_event,
++};
++
++static void rk3288_dfi_start_hardware_counter(struct devfreq_event_dev *edev)
++{
++	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
++
++	regmap_write(info->regmap_grf, RK3288_GRF_SOC_CON4, RK3288_DFI_EN);
++}
++
++static void rk3288_dfi_stop_hardware_counter(struct devfreq_event_dev *edev)
++{
++	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
++
++	regmap_write(info->regmap_grf, RK3288_GRF_SOC_CON4, RK3288_DFI_DIS);
++}
++
++static int rk3288_dfi_disable(struct devfreq_event_dev *edev)
++{
++	rk3288_dfi_stop_hardware_counter(edev);
++
++	return 0;
++}
++
++static int rk3288_dfi_enable(struct devfreq_event_dev *edev)
++{
++	rk3288_dfi_start_hardware_counter(edev);
++
++	return 0;
++}
++
++static int rk3288_dfi_set_event(struct devfreq_event_dev *edev)
++{
++	return 0;
++}
++
++static int rk3288_dfi_get_busier_ch(struct devfreq_event_dev *edev)
++{
++	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
++	u32 tmp, max = 0;
++	u32 i, busier_ch = 0;
++	u32 rd_count, wr_count, total_count;
++
++	rk3288_dfi_stop_hardware_counter(edev);
++
++	/* Find out which channel is busier */
++	for (i = 0; i < MAX_DMC_NUM_CH; i++) {
++		if (!(info->ch_msk & BIT(i)))
++			continue;
++		regmap_read(info->regmap_grf,
++			    RK3288_GRF_SOC_STATUS(11 + i * 4), &wr_count);
++		regmap_read(info->regmap_grf,
++			    RK3288_GRF_SOC_STATUS(12 + i * 4), &rd_count);
++		regmap_read(info->regmap_grf,
++			    RK3288_GRF_SOC_STATUS(14 + i * 4), &total_count);
++		info->ch_usage[i].access = (wr_count + rd_count) * 4;
++		info->ch_usage[i].total = total_count;
++		tmp = info->ch_usage[i].access;
++		if (tmp > max) {
++			busier_ch = i;
++			max = tmp;
++		}
++	}
++	rk3288_dfi_start_hardware_counter(edev);
++
++	return busier_ch;
++}
++
++static int rk3288_dfi_get_event(struct devfreq_event_dev *edev,
++				struct devfreq_event_data *edata)
++{
++	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
++	int busier_ch;
++	unsigned long flags;
++
++	local_irq_save(flags);
++	busier_ch = rk3288_dfi_get_busier_ch(edev);
++	local_irq_restore(flags);
++
++	edata->load_count = info->ch_usage[busier_ch].access;
++	edata->total_count = info->ch_usage[busier_ch].total;
++
++	return 0;
++}
++
++static const struct devfreq_event_ops rk3288_dfi_ops = {
++	.disable = rk3288_dfi_disable,
++	.enable = rk3288_dfi_enable,
++	.get_event = rk3288_dfi_get_event,
++	.set_event = rk3288_dfi_set_event,
++};
++
++static void rk3368_dfi_start_hardware_counter(struct devfreq_event_dev *edev)
++{
++	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
++
++	regmap_write(info->regmap_grf, RK3368_GRF_DDRC0_CON0, RK3368_DFI_EN);
++}
++
++static void rk3368_dfi_stop_hardware_counter(struct devfreq_event_dev *edev)
++{
++	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
++
++	regmap_write(info->regmap_grf, RK3368_GRF_DDRC0_CON0, RK3368_DFI_DIS);
++}
++
++static int rk3368_dfi_disable(struct devfreq_event_dev *edev)
++{
++	rk3368_dfi_stop_hardware_counter(edev);
++
++	return 0;
++}
++
++static int rk3368_dfi_enable(struct devfreq_event_dev *edev)
++{
++	rk3368_dfi_start_hardware_counter(edev);
++
++	return 0;
++}
++
++static int rk3368_dfi_set_event(struct devfreq_event_dev *edev)
++{
++	return 0;
++}
++
++static int rk3368_dfi_get_event(struct devfreq_event_dev *edev,
++				struct devfreq_event_data *edata)
++{
++	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
++	unsigned long flags;
++	u32 dfi0_wr, dfi0_rd, dfi1_wr, dfi1_rd, dfi_timer;
++
++	local_irq_save(flags);
++
++	rk3368_dfi_stop_hardware_counter(edev);
++
++	regmap_read(info->regmap_grf, RK3368_GRF_SOC_STATUS5, &dfi0_wr);
++	regmap_read(info->regmap_grf, RK3368_GRF_SOC_STATUS6, &dfi0_rd);
++	regmap_read(info->regmap_grf, RK3368_GRF_SOC_STATUS9, &dfi1_wr);
++	regmap_read(info->regmap_grf, RK3368_GRF_SOC_STATUS10, &dfi1_rd);
++	regmap_read(info->regmap_grf, RK3368_GRF_SOC_STATUS8, &dfi_timer);
++
++	edata->load_count = (dfi0_wr + dfi0_rd + dfi1_wr + dfi1_rd) * 2;
++	edata->total_count = dfi_timer;
++
++	rk3368_dfi_start_hardware_counter(edev);
++
++	local_irq_restore(flags);
++
++	return 0;
++}
++
++static const struct devfreq_event_ops rk3368_dfi_ops = {
++	.disable = rk3368_dfi_disable,
++	.enable = rk3368_dfi_enable,
++	.get_event = rk3368_dfi_get_event,
++	.set_event = rk3368_dfi_set_event,
+ };
+ 
+ static void rockchip_dfi_start_hardware_counter(struct devfreq_event_dev *edev)
+ {
+ 	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
+ 	void __iomem *dfi_regs = info->regs;
+-	u32 val;
+-	u32 ddr_type;
+-
+-	/* get ddr type */
+-	regmap_read(info->regmap_pmu, RK3399_PMUGRF_OS_REG2, &val);
+-	ddr_type = (val >> RK3399_PMUGRF_DDRTYPE_SHIFT) &
+-		    RK3399_PMUGRF_DDRTYPE_MASK;
+ 
+ 	/* clear DDRMON_CTRL setting */
+ 	writel_relaxed(CLR_DDRMON_CTRL, dfi_regs + DDRMON_CTRL);
+ 
+ 	/* set ddr type to dfi */
+-	if (ddr_type == RK3399_PMUGRF_DDRTYPE_LPDDR3)
+-		writel_relaxed(LPDDR3_EN, dfi_regs + DDRMON_CTRL);
+-	else if (ddr_type == RK3399_PMUGRF_DDRTYPE_LPDDR4)
++	if (info->dram_type == LPDDR3 || info->dram_type == LPDDR2)
++		writel_relaxed(LPDDR2_3_EN, dfi_regs + DDRMON_CTRL);
++	else if (info->dram_type == LPDDR4)
+ 		writel_relaxed(LPDDR4_EN, dfi_regs + DDRMON_CTRL);
++	else if (info->dram_type == DDR4)
++		writel_relaxed(DDR4_EN, dfi_regs + DDRMON_CTRL);
+ 
+ 	/* enable count, use software mode */
+ 	writel_relaxed(SOFTWARE_EN, dfi_regs + DDRMON_CTRL);
+@@ -100,12 +369,22 @@ static int rockchip_dfi_get_busier_ch(struct devfreq_event_dev *edev)
+ 	rockchip_dfi_stop_hardware_counter(edev);
+ 
+ 	/* Find out which channel is busier */
+-	for (i = 0; i < RK3399_DMC_NUM_CH; i++) {
+-		info->ch_usage[i].access = readl_relaxed(dfi_regs +
+-				DDRMON_CH0_DFI_ACCESS_NUM + i * 20) * 4;
++	for (i = 0; i < MAX_DMC_NUM_CH; i++) {
++		if (!(info->ch_msk & BIT(i)))
++			continue;
++
+ 		info->ch_usage[i].total = readl_relaxed(dfi_regs +
+ 				DDRMON_CH0_COUNT_NUM + i * 20);
+-		tmp = info->ch_usage[i].access;
++
++		/* LPDDR4 BL = 16,other DDR type BL = 8 */
++		tmp = readl_relaxed(dfi_regs +
++				DDRMON_CH0_DFI_ACCESS_NUM + i * 20);
++		if (info->dram_type == LPDDR4)
++			tmp *= 8;
++		else
++			tmp *= 4;
++		info->ch_usage[i].access = tmp;
++
+ 		if (tmp > max) {
+ 			busier_ch = i;
+ 			max = tmp;
+@@ -121,7 +400,8 @@ static int rockchip_dfi_disable(struct devfreq_event_dev *edev)
+ 	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
+ 
+ 	rockchip_dfi_stop_hardware_counter(edev);
+-	clk_disable_unprepare(info->clk);
++	if (info->clk)
++		clk_disable_unprepare(info->clk);
+ 
+ 	return 0;
+ }
+@@ -131,10 +411,13 @@ static int rockchip_dfi_enable(struct devfreq_event_dev *edev)
+ 	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
+ 	int ret;
+ 
+-	ret = clk_prepare_enable(info->clk);
+-	if (ret) {
+-		dev_err(&edev->dev, "failed to enable dfi clk: %d\n", ret);
+-		return ret;
++	if (info->clk) {
++		ret = clk_prepare_enable(info->clk);
++		if (ret) {
++			dev_err(&edev->dev, "failed to enable dfi clk: %d\n",
++				ret);
++			return ret;
++		}
+ 	}
+ 
+ 	rockchip_dfi_start_hardware_counter(edev);
+@@ -151,8 +434,11 @@ static int rockchip_dfi_get_event(struct devfreq_event_dev *edev,
+ {
+ 	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
+ 	int busier_ch;
++	unsigned long flags;
+ 
++	local_irq_save(flags);
+ 	busier_ch = rockchip_dfi_get_busier_ch(edev);
++	local_irq_restore(flags);
+ 
+ 	edata->load_count = info->ch_usage[busier_ch].access;
+ 	edata->total_count = info->ch_usage[busier_ch].total;
+@@ -167,23 +453,117 @@ static const struct devfreq_event_ops rockchip_dfi_ops = {
+ 	.set_event = rockchip_dfi_set_event,
+ };
+ 
+-static const struct of_device_id rockchip_dfi_id_match[] = {
+-	{ .compatible = "rockchip,rk3399-dfi" },
+-	{ },
+-};
+-MODULE_DEVICE_TABLE(of, rockchip_dfi_id_match);
++static __init int px30_dfi_init(struct platform_device *pdev,
++				  struct rockchip_dfi *data,
++				  struct devfreq_event_desc *desc)
++{
++	struct device_node *np = pdev->dev.of_node, *node;
++	struct resource *res;
++	u32 val;
+ 
+-static int rockchip_dfi_probe(struct platform_device *pdev)
++	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
++	data->regs = devm_ioremap_resource(&pdev->dev, res);
++	if (IS_ERR(data->regs))
++		return PTR_ERR(data->regs);
++
++	node = of_parse_phandle(np, "rockchip,pmugrf", 0);
++	if (node) {
++		data->regmap_pmugrf = syscon_node_to_regmap(node);
++		if (IS_ERR(data->regmap_pmugrf))
++			return PTR_ERR(data->regmap_pmugrf);
++	}
++
++	regmap_read(data->regmap_pmugrf, PX30_PMUGRF_OS_REG2, &val);
++	data->dram_type = READ_DRAMTYPE_INFO(val);
++	data->ch_msk = 1;
++	data->clk = NULL;
++
++	desc->ops = &rockchip_dfi_ops;
++
++	return 0;
++}
++
++static __init int rk3128_dfi_init(struct platform_device *pdev,
++				  struct rockchip_dfi *data,
++				  struct devfreq_event_desc *desc)
++{
++	struct device_node *np = pdev->dev.of_node, *node;
++
++	node = of_parse_phandle(np, "rockchip,grf", 0);
++	if (node) {
++		data->regmap_grf = syscon_node_to_regmap(node);
++		if (IS_ERR(data->regmap_grf))
++			return PTR_ERR(data->regmap_grf);
++	}
++
++	desc->ops = &rk3128_dfi_ops;
++
++	return 0;
++}
++
++static __init int rk3288_dfi_init(struct platform_device *pdev,
++				  struct rockchip_dfi *data,
++				  struct devfreq_event_desc *desc)
++{
++	struct device_node *np = pdev->dev.of_node, *node;
++	u32 val;
++
++	node = of_parse_phandle(np, "rockchip,pmu", 0);
++	if (node) {
++		data->regmap_pmu = syscon_node_to_regmap(node);
++		if (IS_ERR(data->regmap_pmu))
++			return PTR_ERR(data->regmap_pmu);
++	}
++
++	node = of_parse_phandle(np, "rockchip,grf", 0);
++	if (node) {
++		data->regmap_grf = syscon_node_to_regmap(node);
++		if (IS_ERR(data->regmap_grf))
++			return PTR_ERR(data->regmap_grf);
++	}
++
++	regmap_read(data->regmap_pmu, RK3288_PMU_SYS_REG2, &val);
++	data->dram_type = READ_DRAMTYPE_INFO(val);
++	data->ch_msk = READ_CH_INFO(val);
++
++	if (data->dram_type == DDR3)
++		regmap_write(data->regmap_grf, RK3288_GRF_SOC_CON4,
++			     RK3288_DDR3_SEL);
++	else
++		regmap_write(data->regmap_grf, RK3288_GRF_SOC_CON4,
++			     RK3288_LPDDR_SEL);
++
++	desc->ops = &rk3288_dfi_ops;
++
++	return 0;
++}
++
++static __init int rk3368_dfi_init(struct platform_device *pdev,
++				  struct rockchip_dfi *data,
++				  struct devfreq_event_desc *desc)
++{
++	struct device *dev = &pdev->dev;
++
++	if (!dev->parent || !dev->parent->of_node)
++		return -EINVAL;
++
++	data->regmap_grf = syscon_node_to_regmap(dev->parent->of_node);
++	if (IS_ERR(data->regmap_grf))
++		return PTR_ERR(data->regmap_grf);
++
++	desc->ops = &rk3368_dfi_ops;
++
++	return 0;
++}
++
++static __init int rockchip_dfi_init(struct platform_device *pdev,
++				    struct rockchip_dfi *data,
++				    struct devfreq_event_desc *desc)
+ {
+ 	struct device *dev = &pdev->dev;
+-	struct rockchip_dfi *data;
+ 	struct resource *res;
+-	struct devfreq_event_desc *desc;
+ 	struct device_node *np = pdev->dev.of_node, *node;
+-
+-	data = devm_kzalloc(dev, sizeof(struct rockchip_dfi), GFP_KERNEL);
+-	if (!data)
+-		return -ENOMEM;
++	u32 val;
+ 
+ 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+ 	data->regs = devm_ioremap_resource(&pdev->dev, res);
+@@ -203,21 +583,97 @@ static int rockchip_dfi_probe(struct platform_device *pdev)
+ 		if (IS_ERR(data->regmap_pmu))
+ 			return PTR_ERR(data->regmap_pmu);
+ 	}
+-	data->dev = dev;
++
++	regmap_read(data->regmap_pmu, PMUGRF_OS_REG2, &val);
++	data->dram_type = READ_DRAMTYPE_INFO(val);
++	data->ch_msk = READ_CH_INFO(val);
++
++	desc->ops = &rockchip_dfi_ops;
++
++	return 0;
++}
++
++static __init int rk3328_dfi_init(struct platform_device *pdev,
++				  struct rockchip_dfi *data,
++				  struct devfreq_event_desc *desc)
++{
++	struct device_node *np = pdev->dev.of_node, *node;
++	struct resource *res;
++	u32 val;
++
++	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
++	data->regs = devm_ioremap_resource(&pdev->dev, res);
++	if (IS_ERR(data->regs))
++		return PTR_ERR(data->regs);
++
++	node = of_parse_phandle(np, "rockchip,grf", 0);
++	if (node) {
++		data->regmap_grf = syscon_node_to_regmap(node);
++		if (IS_ERR(data->regmap_grf))
++			return PTR_ERR(data->regmap_grf);
++	}
++
++	regmap_read(data->regmap_grf, RK3328_GRF_OS_REG2, &val);
++	data->dram_type = READ_DRAMTYPE_INFO(val);
++	data->ch_msk = 1;
++	data->clk = NULL;
++
++	desc->ops = &rockchip_dfi_ops;
++
++	return 0;
++}
++
++static const struct of_device_id rockchip_dfi_id_match[] = {
++	{ .compatible = "rockchip,px30-dfi", .data = px30_dfi_init },
++	{ .compatible = "rockchip,rk1808-dfi", .data = px30_dfi_init },
++	{ .compatible = "rockchip,rk3128-dfi", .data = rk3128_dfi_init },
++	{ .compatible = "rockchip,rk3288-dfi", .data = rk3288_dfi_init },
++	{ .compatible = "rockchip,rk3328-dfi", .data = rk3328_dfi_init },
++	{ .compatible = "rockchip,rk3368-dfi", .data = rk3368_dfi_init },
++	{ .compatible = "rockchip,rk3399-dfi", .data = rockchip_dfi_init },
++	{ },
++};
++MODULE_DEVICE_TABLE(of, rockchip_dfi_id_match);
++
++static int rockchip_dfi_probe(struct platform_device *pdev)
++{
++	struct device *dev = &pdev->dev;
++	struct rockchip_dfi *data;
++	struct devfreq_event_desc *desc;
++	struct device_node *np = pdev->dev.of_node;
++	const struct of_device_id *match;
++	int (*init)(struct platform_device *pdev, struct rockchip_dfi *data,
++		    struct devfreq_event_desc *desc);
++
++	data = devm_kzalloc(dev, sizeof(struct rockchip_dfi), GFP_KERNEL);
++	if (!data)
++		return -ENOMEM;
+ 
+ 	desc = devm_kzalloc(dev, sizeof(*desc), GFP_KERNEL);
+ 	if (!desc)
+ 		return -ENOMEM;
+ 
+-	desc->ops = &rockchip_dfi_ops;
++	match = of_match_node(rockchip_dfi_id_match, pdev->dev.of_node);
++	if (match) {
++		init = match->data;
++		if (init) {
++			if (init(pdev, data, desc))
++				return -EINVAL;
++		} else {
++			return 0;
++		}
++	} else {
++		return 0;
++	}
++
+ 	desc->driver_data = data;
+ 	desc->name = np->name;
+ 	data->desc = desc;
++	data->dev = dev;
+ 
+-	data->edev = devm_devfreq_event_add_edev(&pdev->dev, desc);
++	data->edev = devm_devfreq_event_add_edev(dev, desc);
+ 	if (IS_ERR(data->edev)) {
+-		dev_err(&pdev->dev,
+-			"failed to add devfreq-event device\n");
++		dev_err(dev, "failed to add devfreq-event device\n");
+ 		return PTR_ERR(data->edev);
+ 	}
diff --git a/target/linux/rockchip/patches-5.4/003-add-nanopi-r2s-support.patch b/target/linux/rockchip/patches-5.4/003-add-nanopi-r2s-support.patch
new file mode 100644
index 0000000000..3463df5c2e
--- /dev/null
+++ b/target/linux/rockchip/patches-5.4/003-add-nanopi-r2s-support.patch
@@ -0,0 +1,780 @@
+diff --git a/arch/arm64/boot/dts/rockchip/Makefile b/arch/arm64/boot/dts/rockchip/Makefile
+index 92d796a33..24a6c304f 100644
+--- a/arch/arm64/boot/dts/rockchip/Makefile
++++ b/arch/arm64/boot/dts/rockchip/Makefile
+@@ -1,6 +1,7 @@
+ # SPDX-License-Identifier: GPL-2.0
+ dtb-$(CONFIG_ARCH_ROCKCHIP) += px30-evb.dtb
+ dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3328-evb.dtb
++dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3328-nanopi-r2s.dtb
+ dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3328-rock64.dtb
+ dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3328-roc-cc.dtb
+ dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3368-evb-act8846.dtb
+diff --git a/arch/arm64/boot/dts/rockchip/rk3328-nanopi-r2-common.dtsi b/arch/arm64/boot/dts/rockchip/rk3328-nanopi-r2-common.dtsi
+new file mode 100644
+index 000000000..36890bb7f
+--- /dev/null
++++ b/arch/arm64/boot/dts/rockchip/rk3328-nanopi-r2-common.dtsi
+@@ -0,0 +1,614 @@
++// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
++/*
++ * Copyright (c) 2018 FriendlyElec Computer Tech. Co., Ltd.
++ * (http://www.friendlyarm.com)
++ *
++ * Copyright (c) 2017 Fuzhou Rockchip Electronics Co., Ltd
++ */
++
++/dts-v1/;
++#include "rk3328-dram-default-timing.dtsi"
++#include "rk3328.dtsi"
++
++/ {
++	model = "FriendlyARM boards based on Rockchip RK3328";
++	compatible = "friendlyarm,nanopi-r2s", "rockchip,rk3328";
++
++	aliases {
++		ethernet1 = &r8153;
++	};
++
++	chosen {
++		bootargs = "swiotlb=1 coherent_pool=1m consoleblank=0";
++		stdout-path = "serial2:1500000n8";
++	};
++
++	gmac_clkin: external-gmac-clock {
++		compatible = "fixed-clock";
++		clock-frequency = <125000000>;
++		clock-output-names = "gmac_clkin";
++		#clock-cells = <0>;
++	};
++
++	leds: gpio-leds {
++		compatible = "gpio-leds";
++		pinctrl-names = "default";
++		pinctrl-0 =<&leds_gpio>;
++		status = "disabled";
++
++		status {
++			gpios = <&gpio0 RK_PA2 GPIO_ACTIVE_HIGH>;
++			label = "nanopi:red:status";
++			linux,default-trigger = "heartbeat";
++			linux,default-trigger-delay-ms = <0>;
++		};
++	};
++
++	sdio_pwrseq: sdio-pwrseq {
++		compatible = "mmc-pwrseq-simple";
++		clocks = <&rk805 1>;
++		clock-names = "ext_clock";
++		pinctrl-names = "default";
++		pinctrl-0 = <&wifi_enable_h>;
++
++		/*
++		 * On the module itself this is one of these (depending
++		 * on the actual card populated):
++		 * - SDIO_RESET_L_WL_REG_ON
++		 * - PDN (power down when low)
++		 */
++		reset-gpios = <&gpio3 RK_PB0 GPIO_ACTIVE_LOW>;
++	};
++
++	vcc_sd: sdmmc-regulator {
++		compatible = "regulator-fixed";
++		gpio = <&gpio0 RK_PD6 GPIO_ACTIVE_LOW>;
++		pinctrl-names = "default";
++		pinctrl-0 = <&sdmmc0m1_gpio>;
++		regulator-name = "vcc_sd";
++		regulator-min-microvolt = <3300000>;
++		regulator-max-microvolt = <3300000>;
++		vin-supply = <&vcc_io>;
++	};
++
++	vccio_sd: sdmmcio-regulator {
++		compatible = "regulator-gpio";
++		gpios = <&gpio1 RK_PD4 GPIO_ACTIVE_HIGH>;
++		states = <1800000 0x1
++			  3300000 0x0>;
++		regulator-name = "vccio_sd";
++		regulator-type = "voltage";
++		regulator-min-microvolt = <1800000>;
++		regulator-max-microvolt = <3300000>;
++		regulator-always-on;
++		vin-supply = <&vcc_io>;
++		startup-delay-us = <2000>;
++		regulator-settling-time-us = <5000>;
++		enable-active-high;
++		status = "disabled";
++	};
++
++	vcc_sys: vcc-sys {
++		compatible = "regulator-fixed";
++		regulator-name = "vcc_sys";
++		regulator-always-on;
++		regulator-boot-on;
++		regulator-min-microvolt = <5000000>;
++		regulator-max-microvolt = <5000000>;
++	};
++
++	vcc_phy: vcc-phy-regulator {
++		compatible = "regulator-fixed";
++		regulator-name = "vcc_phy";
++		regulator-always-on;
++		regulator-boot-on;
++	};
++
++	vcc_host_vbus: host-vbus-regulator {
++		compatible = "regulator-fixed";
++		regulator-name = "vcc_host_vbus";
++		regulator-always-on;
++		regulator-boot-on;
++		regulator-min-microvolt = <5000000>;
++		regulator-max-microvolt = <5000000>;
++	};
++
++	dfi: dfi@ff790000 {
++		reg = <0x00 0xff790000 0x00 0x400>;
++		compatible = "rockchip,rk3328-dfi";
++		rockchip,grf = <&grf>;
++		status = "disabled";
++	};
++
++	dmc: dmc {
++		compatible = "rockchip,rk3328-dmc";
++		devfreq-events = <&dfi>;
++		clocks = <&cru SCLK_DDRCLK>;
++		clock-names = "dmc_clk";
++		operating-points-v2 = <&dmc_opp_table>;
++		ddr_timing = <&ddr_timing>;
++		upthreshold = <40>;
++		downdifferential = <20>;
++		auto-min-freq = <786000>;
++		auto-freq-en = <0>;
++		#cooling-cells = <2>;
++		status = "disabled";
++
++		ddr_power_model: ddr_power_model {
++			compatible = "ddr_power_model";
++			dynamic-power-coefficient = <120>;
++			static-power-coefficient = <200>;
++			ts = <32000 4700 (-80) 2>;
++			thermal-zone = "soc-thermal";
++		};
++	};
++
++	dmc_opp_table: dmc-opp-table {
++		compatible = "operating-points-v2";
++
++		rockchip,leakage-voltage-sel = <
++			1   10    0
++			11  254   1
++		>;
++		nvmem-cells = <&logic_leakage>;
++		nvmem-cell-names = "ddr_leakage";
++
++		opp-786000000 {
++			opp-hz = /bits/ 64 <786000000>;
++			opp-microvolt = <1075000>;
++			opp-microvolt-L0 = <1075000>;
++			opp-microvolt-L1 = <1050000>;
++		};
++		opp-798000000 {
++			opp-hz = /bits/ 64 <798000000>;
++			opp-microvolt = <1075000>;
++			opp-microvolt-L0 = <1075000>;
++			opp-microvolt-L1 = <1050000>;
++		};
++		opp-840000000 {
++			opp-hz = /bits/ 64 <840000000>;
++			opp-microvolt = <1075000>;
++			opp-microvolt-L0 = <1075000>;
++			opp-microvolt-L1 = <1050000>;
++		};
++		opp-924000000 {
++			opp-hz = /bits/ 64 <924000000>;
++			opp-microvolt = <1100000>;
++			opp-microvolt-L0 = <1100000>;
++			opp-microvolt-L1 = <1075000>;
++		};
++		opp-1056000000 {
++			opp-hz = /bits/ 64 <1056000000>;
++			opp-microvolt = <1175000>;
++			opp-microvolt-L0 = <1175000>;
++			opp-microvolt-L1 = <1150000>;
++		};
++	};
++};
++
++&cpu0 {
++	cpu-supply = <&vdd_arm>;
++};
++
++&cpu1 {
++	cpu-supply = <&vdd_arm>;
++};
++
++&cpu2 {
++	cpu-supply = <&vdd_arm>;
++};
++
++&cpu3 {
++	cpu-supply = <&vdd_arm>;
++};
++
++&dfi {
++	status = "okay";
++};
++
++&dmc {
++	center-supply = <&vdd_logic>;
++	status = "okay";
++};
++
++&emmc {
++	bus-width = <8>;
++	cap-mmc-highspeed;
++	max-frequency = <150000000>;
++	mmc-hs200-1_8v;
++	no-sd;
++	non-removable;
++	pinctrl-names = "default";
++	pinctrl-0 = <&emmc_clk &emmc_cmd &emmc_bus8>;
++	vmmc-supply = <&vcc_io>;
++	vqmmc-supply = <&vcc18_emmc>;
++	status = "okay";
++};
++
++&gmac2phy {
++	phy-supply = <&vcc_phy>;
++	clock_in_out = "output";
++	assigned-clocks = <&cru SCLK_MAC2PHY_SRC>;
++	assigned-clock-rate = <50000000>;
++	assigned-clocks = <&cru SCLK_MAC2PHY>;
++	assigned-clock-parents = <&cru SCLK_MAC2PHY_SRC>;
++	status = "disabled";
++};
++
++&gmac2io {
++	assigned-clocks = <&cru SCLK_MAC2IO>, <&cru SCLK_MAC2IO_EXT>;
++	assigned-clock-parents = <&gmac_clkin>, <&gmac_clkin>;
++	clock_in_out = "input";
++	pinctrl-names = "default";
++	pinctrl-0 = <&rgmiim1_pins>;
++	phy-handle = <&rtl8211e>;
++	phy-mode = "rgmii";
++	phy-supply = <&vcc_phy>;
++	snps,reset-active-low;
++	snps,reset-delays-us = <0 10000 30000>;
++	snps,reset-gpio = <&gpio1 RK_PC2 GPIO_ACTIVE_LOW>;
++	snps,aal;
++	snps,rxpbl = <0x4>;
++	snps,txpbl = <0x4>;
++	tx_delay = <0x24>;
++	rx_delay = <0x18>;
++	status = "okay";
++
++	mdio {
++		compatible = "snps,dwmac-mdio";
++		#address-cells = <1>;
++		#size-cells = <0>;
++
++		rtl8211e: phy@0 {
++			reg = <0>;
++			reset-assert-us = <10000>;
++			reset-deassert-us = <30000>;
++			/* reset-gpios = <&gpio1 RK_PC2 GPIO_ACTIVE_LOW>; */
++		};
++	};
++};
++
++&i2c1 {
++	status = "okay";
++
++	rk805: rk805@18 {
++		compatible = "rockchip,rk805";
++		reg = <0x18>;
++		interrupt-parent = <&gpio2>;
++		interrupts = <6 IRQ_TYPE_LEVEL_LOW>;
++		#clock-cells = <1>;
++		clock-output-names = "xin32k", "rk805-clkout2";
++		gpio-controller;
++		#gpio-cells = <2>;
++		pinctrl-names = "default";
++		pinctrl-0 = <&pmic_int_l>;
++		rockchip,system-power-controller;
++		wakeup-source;
++
++		vcc1-supply = <&vcc_sys>;
++		vcc2-supply = <&vcc_sys>;
++		vcc3-supply = <&vcc_sys>;
++		vcc4-supply = <&vcc_sys>;
++		vcc5-supply = <&vcc_io>;
++		vcc6-supply = <&vcc_io>;
++
++		regulators {
++			vdd_logic: DCDC_REG1 {
++				regulator-name = "vdd_logic";
++				regulator-init-microvolt = <1075000>;
++				regulator-min-microvolt = <712500>;
++				regulator-max-microvolt = <1450000>;
++				regulator-always-on;
++				regulator-boot-on;
++				regulator-state-mem {
++					regulator-on-in-suspend;
++					regulator-suspend-microvolt = <1000000>;
++				};
++			};
++
++			vdd_arm: DCDC_REG2 {
++				regulator-name = "vdd_arm";
++				regulator-init-microvolt = <1225000>;
++				regulator-min-microvolt = <712500>;
++				regulator-max-microvolt = <1450000>;
++				regulator-always-on;
++				regulator-boot-on;
++				regulator-state-mem {
++					regulator-on-in-suspend;
++					regulator-suspend-microvolt = <950000>;
++				};
++			};
++
++			vcc_ddr: DCDC_REG3 {
++				regulator-name = "vcc_ddr";
++				regulator-always-on;
++				regulator-boot-on;
++				regulator-state-mem {
++					regulator-on-in-suspend;
++				};
++			};
++
++			vcc_io: DCDC_REG4 {
++				regulator-name = "vcc_io";
++				regulator-min-microvolt = <3300000>;
++				regulator-max-microvolt = <3300000>;
++				regulator-always-on;
++				regulator-boot-on;
++				regulator-state-mem {
++					regulator-on-in-suspend;
++					regulator-suspend-microvolt = <3300000>;
++				};
++			};
++
++			vcc_18: LDO_REG1 {
++				regulator-name = "vcc_18";
++				regulator-min-microvolt = <1800000>;
++				regulator-max-microvolt = <1800000>;
++				regulator-always-on;
++				regulator-boot-on;
++				regulator-state-mem {
++					regulator-on-in-suspend;
++					regulator-suspend-microvolt = <1800000>;
++				};
++			};
++
++			vcc18_emmc: LDO_REG2 {
++				regulator-name = "vcc18_emmc";
++				regulator-min-microvolt = <1800000>;
++				regulator-max-microvolt = <1800000>;
++				regulator-always-on;
++				regulator-boot-on;
++				regulator-state-mem {
++					regulator-on-in-suspend;
++					regulator-suspend-microvolt = <1800000>;
++				};
++			};
++
++			vdd_10: LDO_REG3 {
++				regulator-name = "vdd_10";
++				regulator-min-microvolt = <1000000>;
++				regulator-max-microvolt = <1000000>;
++				regulator-always-on;
++				regulator-boot-on;
++				regulator-state-mem {
++					regulator-on-in-suspend;
++					regulator-suspend-microvolt = <1000000>;
++				};
++			};
++		};
++	};
++};
++
++&io_domains {
++	status = "okay";
++
++	vccio1-supply = <&vcc_io>;
++	vccio2-supply = <&vcc18_emmc>;
++	vccio3-supply = <&vcc_io>;
++	vccio4-supply = <&vcc_io>;
++	vccio5-supply = <&vcc_io>;
++	vccio6-supply = <&vcc_18>;
++	pmuio-supply = <&vcc_io>;
++};
++
++&pinctrl {
++	pmic {
++		pmic_int_l: pmic-int-l {
++			rockchip,pins = <2 RK_PA6 RK_FUNC_GPIO &pcfg_pull_up>;
++		};
++	};
++
++	sdio-pwrseq {
++		wifi_enable_h: wifi-enable-h {
++			rockchip,pins = <3 RK_PB0 RK_FUNC_GPIO &pcfg_pull_none>;
++		};
++	};
++
++	sdmmc0 {
++		sdmmc0_clk: sdmmc0-clk {
++			rockchip,pins = <1 RK_PA6 1 &pcfg_pull_none_4ma>;
++		};
++
++		sdmmc0_cmd: sdmmc0-cmd {
++			rockchip,pins = <1 RK_PA4 1 &pcfg_pull_up_4ma>;
++		};
++
++		sdmmc0_dectn: sdmmc0-dectn {
++			rockchip,pins = <1 RK_PA5 1 &pcfg_pull_up_4ma>;
++		};
++
++		sdmmc0_bus4: sdmmc0-bus4 {
++			rockchip,pins =
++				<1 RK_PA0 1 &pcfg_pull_up_4ma>,
++				<1 RK_PA1 1 &pcfg_pull_up_4ma>,
++				<1 RK_PA2 1 &pcfg_pull_up_4ma>,
++				<1 RK_PA3 1 &pcfg_pull_up_4ma>;
++		};
++	};
++
++	sdmmc0ext {
++		sdmmc0ext_clk: sdmmc0ext-clk {
++			rockchip,pins = <3 RK_PA2 3 &pcfg_pull_none_2ma>;
++		};
++
++		sdmmc0ext_cmd: sdmmc0ext-cmd {
++			rockchip,pins = <3 RK_PA0 3 &pcfg_pull_up_2ma>;
++		};
++
++		sdmmc0ext_bus4: sdmmc0ext-bus4 {
++			rockchip,pins =
++				<3 RK_PA4 3 &pcfg_pull_up_2ma>,
++				<3 RK_PA5 3 &pcfg_pull_up_2ma>,
++				<3 RK_PA6 3 &pcfg_pull_up_2ma>,
++				<3 RK_PA7 3 &pcfg_pull_up_2ma>;
++		};
++	};
++
++	gmac-1 {
++		rgmiim1_pins: rgmiim1-pins {
++			rockchip,pins =
++				/* mac_txclk */
++				<1 RK_PB4 2 &pcfg_pull_none_4ma>,
++				/* mac_rxclk */
++				<1 RK_PB5 2 &pcfg_pull_none>,
++				/* mac_mdio */
++				<1 RK_PC3 2 &pcfg_pull_none_2ma>,
++				/* mac_txen */
++				<1 RK_PD1 2 &pcfg_pull_none_4ma>,
++				/* mac_clk */
++				<1 RK_PC5 2 &pcfg_pull_none_2ma>,
++				/* mac_rxdv */
++				<1 RK_PC6 2 &pcfg_pull_none>,
++				/* mac_mdc */
++				<1 RK_PC7 2 &pcfg_pull_none_2ma>,
++				/* mac_rxd1 */
++				<1 RK_PB2 2 &pcfg_pull_none>,
++				/* mac_rxd0 */
++				<1 RK_PB3 2 &pcfg_pull_none>,
++				/* mac_txd1 */
++				<1 RK_PB0 2 &pcfg_pull_none_4ma>,
++				/* mac_txd0 */
++				<1 RK_PB1 2 &pcfg_pull_none_4ma>,
++				/* mac_rxd3 */
++				<1 RK_PB6 2 &pcfg_pull_none>,
++				/* mac_rxd2 */
++				<1 RK_PB7 2 &pcfg_pull_none>,
++				/* mac_txd3 */
++				<1 RK_PC0 2 &pcfg_pull_none_4ma>,
++				/* mac_txd2 */
++				<1 RK_PC1 2 &pcfg_pull_none_4ma>,
++
++				/* mac_txclk */
++				<0 RK_PB0 1 &pcfg_pull_none>,
++				/* mac_txen */
++				<0 RK_PB4 1 &pcfg_pull_none>,
++				/* mac_clk */
++				<0 RK_PD0 1 &pcfg_pull_none>,
++				/* mac_txd1 */
++				<0 RK_PC0 1 &pcfg_pull_none>,
++				/* mac_txd0 */
++				<0 RK_PC1 1 &pcfg_pull_none>,
++				/* mac_txd3 */
++				<0 RK_PC7 1 &pcfg_pull_none>,
++				/* mac_txd2 */
++				<0 RK_PC6 1 &pcfg_pull_none>;
++		};
++	};
++
++	usb {
++		host_vbus_drv: host-vbus-drv {
++			rockchip,pins = <0 RK_PA0 RK_FUNC_GPIO &pcfg_pull_none>;
++		};
++
++		otg_vbus_drv: otg-vbus-drv {
++			rockchip,pins = <3 RK_PA1 RK_FUNC_GPIO &pcfg_pull_none>;
++		};
++	};
++
++	gpio-leds {
++		leds_gpio: leds-gpio {
++			rockchip,pins = <0 RK_PA2 RK_FUNC_GPIO &pcfg_pull_none>;
++		};
++	};
++};
++
++&sdmmc {
++	bus-width = <4>;
++	cap-mmc-highspeed;
++	cap-sd-highspeed;
++	disable-wp;
++	max-frequency = <150000000>;
++	pinctrl-names = "default";
++	pinctrl-0 = <&sdmmc0_clk &sdmmc0_cmd &sdmmc0_dectn &sdmmc0_bus4>;
++	vmmc-supply = <&vcc_sd>;
++	status = "okay";
++};
++
++&sdmmc_ext {
++	bus-width = <4>;
++	cap-sd-highspeed;
++	cap-sdio-irq;
++	disable-wp;
++	keep-power-in-suspend;
++	max-frequency = <100000000>;
++	mmc-pwrseq = <&sdio_pwrseq>;
++	non-removable;
++	num-slots = <1>;
++	pinctrl-names = "default";
++	pinctrl-0 = <&sdmmc0ext_clk &sdmmc0ext_cmd &sdmmc0ext_bus4>;
++	rockchip,default-sample-phase = <120>;
++	supports-sdio;
++	sd-uhs-sdr104;
++	#address-cells = <1>;
++	#size-cells = <0>;
++	status = "okay";
++
++	brcmf: bcrmf@1 {
++		reg = <1>;
++		compatible = "brcm,bcm4329-fmac";
++		interrupt-parent = <&gpio1>;
++		interrupts = <RK_PD2 IRQ_TYPE_LEVEL_HIGH>;
++		interrupt-names = "host-wake";
++	};
++};
++
++&tsadc {
++	status = "okay";
++};
++
++&uart2 {
++	status = "okay";
++};
++
++&u2phy {
++	status = "okay";
++};
++
++&u2phy_host {
++	status = "okay";
++};
++
++&u2phy_otg {
++	status = "okay";
++};
++
++&u3phy {
++	vbus-supply = <&vcc_host_vbus>;
++	status = "okay";
++};
++
++&u3phy_utmi {
++	status = "okay";
++};
++
++&u3phy_pipe {
++	status = "okay";
++};
++
++&usb20_otg {
++	status = "okay";
++};
++
++&usb_host0_ehci {
++	status = "okay";
++};
++
++&usb_host0_ohci {
++	status = "okay";
++};
++
++&usbdrd3 {
++	status = "okay";
++};
++
++&usbdrd_dwc3 {
++	status = "okay";
++	#address-cells = <1>;
++	#size-cells = <0>;
++
++	r8153: device@2 {
++		compatible = "usbbda:8153";
++		reg = <2>;
++		local-mac-address = [00 00 00 00 00 00];
++	};
++};
+diff --git a/arch/arm64/boot/dts/rockchip/rk3328-nanopi-r2s.dts b/arch/arm64/boot/dts/rockchip/rk3328-nanopi-r2s.dts
+new file mode 100644
+index 000000000..971397659
+--- /dev/null
++++ b/arch/arm64/boot/dts/rockchip/rk3328-nanopi-r2s.dts
+@@ -0,0 +1,142 @@
++// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
++/*
++ * Copyright (c) 2019 FriendlyElec Computer Tech. Co., Ltd.
++ * (http://www.friendlyarm.com)
++ */
++
++/dts-v1/;
++#include <dt-bindings/input/linux-event-codes.h>
++#include "rk3328-nanopi-r2-common.dtsi"
++
++/ {
++	model = "FriendlyARM NanoPi R2S";
++	compatible = "friendlyarm,nanopi-r2s", "rockchip,rk3328";
++
++	gpio-keys {
++		compatible = "gpio-keys";
++		#address-cells = <1>;
++		#size-cells = <0>;
++		autorepeat;
++
++		pinctrl-names = "default";
++		pinctrl-0 = <&gpio_key1>;
++
++		reset {
++			gpios = <&gpio0 RK_PA0 GPIO_ACTIVE_LOW>;
++			label = "reset";
++			linux,code = <KEY_RESTART>;
++			linux,input-type = <1>;
++			gpio-key,wakeup = <1>;
++			debounce-interval = <100>;
++		};
++	};
++
++	vcc_rtl8153: vcc-rtl8153-regulator {
++		compatible = "regulator-fixed";
++		gpio = <&gpio2 RK_PC6 GPIO_ACTIVE_HIGH>;
++		pinctrl-names = "default";
++		pinctrl-0 = <&usb30_en_drv>;
++		regulator-always-on;
++		regulator-name = "vcc_rtl8153";
++		regulator-min-microvolt = <5000000>;
++		regulator-max-microvolt = <5000000>;
++		off-on-delay-us = <5000>;
++		enable-active-high;
++	};
++};
++
++&emmc {
++	status = "disabled";
++};
++
++&i2c0 {
++	status = "okay";
++};
++
++&leds {
++	status = "okay";
++
++	lan {
++		gpios = <&gpio2 RK_PB7 GPIO_ACTIVE_HIGH>;
++		label = "nanopi:green:lan";
++	};
++
++	wan {
++		gpios = <&gpio2 RK_PC2 GPIO_ACTIVE_HIGH>;
++		label = "nanopi:green:wan";
++	};
++};
++
++&leds_gpio {
++	rockchip,pins =
++		<0 RK_PA2 RK_FUNC_GPIO &pcfg_pull_none>,
++		<2 RK_PB7 RK_FUNC_GPIO &pcfg_pull_none>,
++		<2 RK_PC2 RK_FUNC_GPIO &pcfg_pull_none>;
++};
++
++&pwm2 {
++	pinctrl-names = "default", "sleep";
++	pinctrl-1 = <&pwm2_sleep_pin>;
++	status = "okay";
++};
++
++&rk805 {
++	interrupt-parent = <&gpio1>;
++	interrupts = <RK_PD0 IRQ_TYPE_LEVEL_LOW>;
++};
++
++&vccio_sd {
++	status = "okay";
++};
++
++&io_domains {
++	vccio3-supply = <&vccio_sd>;
++};
++
++&sdmmc {
++	vqmmc-supply = <&vccio_sd>;
++	max-frequency = <150000000>;
++	sd-uhs-sdr12;
++	sd-uhs-sdr25;
++	sd-uhs-sdr50;
++	sd-uhs-sdr104;
++	status = "okay";
++};
++
++&sdmmc_ext {
++	status = "disabled";
++};
++
++&sdio_pwrseq {
++	status = "disabled";
++};
++
++&pinctrl {
++	pmic {
++		pmic_int_l: pmic-int-l {
++			rockchip,pins = <1 RK_PD0 RK_FUNC_GPIO &pcfg_pull_up>;
++		};
++	};
++
++	pwm {
++		pwm2_sleep_pin: pwm2-sleep-pin {
++			rockchip,pins = <2 RK_PA6 RK_FUNC_GPIO &pcfg_output_low>;
++		};
++	};
++
++	rockchip-key {
++		gpio_key1: gpio-key1 {
++			rockchip,pins = <0 RK_PA0 RK_FUNC_GPIO &pcfg_pull_none>;
++		};
++	};
++
++	usb {
++		otg_vbus_drv: otg-vbus-drv {
++			rockchip,pins = <1 RK_PD2 RK_FUNC_GPIO &pcfg_pull_none>;
++		};
++
++		usb30_en_drv: usb30-en-drv {
++			rockchip,pins = <2 RK_PC6 RK_FUNC_GPIO &pcfg_pull_none>;
++		};
++	};
++};
diff --git a/target/linux/rockchip/patches-5.4/003-nanopi-r2s-kernel-patches.patch b/target/linux/rockchip/patches-5.4/003-nanopi-r2s-kernel-patches.patch
new file mode 100644
index 0000000000..f98717ecf2
--- /dev/null
+++ b/target/linux/rockchip/patches-5.4/003-nanopi-r2s-kernel-patches.patch
@@ -0,0 +1,551 @@
+diff --git a/arch/arm64/boot/dts/rockchip/rk3328-dram-default-timing.dtsi b/arch/arm64/boot/dts/rockchip/rk3328-dram-default-timing.dtsi
+new file mode 100644
+index 000000000..a3f5ff4bd
+--- /dev/null
++++ b/arch/arm64/boot/dts/rockchip/rk3328-dram-default-timing.dtsi
+@@ -0,0 +1,311 @@
++/*
++ * Copyright (c) 2017 Fuzhou Rockchip Electronics Co., Ltd
++ *
++ * This file is dual-licensed: you can use it either under the terms
++ * of the GPL or the X11 license, at your option. Note that this dual
++ * licensing only applies to this file, and not this project as a
++ * whole.
++ *
++ *  a) This library is free software; you can redistribute it and/or
++ *     modify it under the terms of the GNU General Public License as
++ *     published by the Free Software Foundation; either version 2 of the
++ *     License, or (at your option) any later version.
++ *
++ *     This library is distributed in the hope that it will be useful,
++ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
++ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ *     GNU General Public License for more details.
++ *
++ * Or, alternatively,
++ *
++ *  b) Permission is hereby granted, free of charge, to any person
++ *     obtaining a copy of this software and associated documentation
++ *     files (the "Software"), to deal in the Software without
++ *     restriction, including without limitation the rights to use,
++ *     copy, modify, merge, publish, distribute, sublicense, and/or
++ *     sell copies of the Software, and to permit persons to whom the
++ *     Software is furnished to do so, subject to the following
++ *     conditions:
++ *
++ *     The above copyright notice and this permission notice shall be
++ *     included in all copies or substantial portions of the Software.
++ *
++ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
++ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
++ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
++ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
++ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
++ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
++ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
++ *     OTHER DEALINGS IN THE SOFTWARE.
++ */
++#include <dt-bindings/clock/rockchip-ddr.h>
++#include <dt-bindings/memory/rk3328-dram.h>
++
++/ {
++	ddr_timing: ddr_timing {
++		compatible = "rockchip,ddr-timing";
++		ddr3_speed_bin = <DDR3_DEFAULT>;
++		ddr4_speed_bin = <DDR4_DEFAULT>;
++		pd_idle = <0>;
++		sr_idle = <0>;
++		sr_mc_gate_idle = <0>;
++		srpd_lite_idle	= <0>;
++		standby_idle = <0>;
++
++		auto_pd_dis_freq = <1066>;
++		auto_sr_dis_freq = <800>;
++		ddr3_dll_dis_freq = <300>;
++		ddr4_dll_dis_freq = <625>;
++		phy_dll_dis_freq = <400>;
++
++		ddr3_odt_dis_freq = <100>;
++		phy_ddr3_odt_dis_freq = <100>;
++		ddr3_drv = <DDR3_DS_40ohm>;
++		ddr3_odt = <DDR3_ODT_120ohm>;
++		phy_ddr3_ca_drv = <PHY_DDR3_RON_RTT_34ohm>;
++		phy_ddr3_ck_drv = <PHY_DDR3_RON_RTT_45ohm>;
++		phy_ddr3_dq_drv = <PHY_DDR3_RON_RTT_34ohm>;
++		phy_ddr3_odt = <PHY_DDR3_RON_RTT_225ohm>;
++
++		lpddr3_odt_dis_freq = <666>;
++		phy_lpddr3_odt_dis_freq = <666>;
++		lpddr3_drv = <LP3_DS_40ohm>;
++		lpddr3_odt = <LP3_ODT_240ohm>;
++		phy_lpddr3_ca_drv = <PHY_DDR4_LPDDR3_RON_RTT_34ohm>;
++		phy_lpddr3_ck_drv = <PHY_DDR4_LPDDR3_RON_RTT_43ohm>;
++		phy_lpddr3_dq_drv = <PHY_DDR4_LPDDR3_RON_RTT_34ohm>;
++		phy_lpddr3_odt = <PHY_DDR4_LPDDR3_RON_RTT_240ohm>;
++
++		lpddr4_odt_dis_freq = <800>;
++		phy_lpddr4_odt_dis_freq = <800>;
++		lpddr4_drv = <LP4_PDDS_60ohm>;
++		lpddr4_dq_odt = <LP4_DQ_ODT_40ohm>;
++		lpddr4_ca_odt = <LP4_CA_ODT_40ohm>;
++		phy_lpddr4_ca_drv = <PHY_DDR4_LPDDR3_RON_RTT_40ohm>;
++		phy_lpddr4_ck_cs_drv = <PHY_DDR4_LPDDR3_RON_RTT_80ohm>;
++		phy_lpddr4_dq_drv = <PHY_DDR4_LPDDR3_RON_RTT_80ohm>;
++		phy_lpddr4_odt = <PHY_DDR4_LPDDR3_RON_RTT_60ohm>;
++
++		ddr4_odt_dis_freq = <666>;
++		phy_ddr4_odt_dis_freq = <666>;
++		ddr4_drv = <DDR4_DS_34ohm>;
++		ddr4_odt = <DDR4_RTT_NOM_240ohm>;
++		phy_ddr4_ca_drv = <PHY_DDR4_LPDDR3_RON_RTT_34ohm>;
++		phy_ddr4_ck_drv = <PHY_DDR4_LPDDR3_RON_RTT_43ohm>;
++		phy_ddr4_dq_drv = <PHY_DDR4_LPDDR3_RON_RTT_34ohm>;
++		phy_ddr4_odt = <PHY_DDR4_LPDDR3_RON_RTT_240ohm>;
++
++		/* CA de-skew, one step is 47.8ps, range 0-15 */
++		ddr3a1_ddr4a9_de-skew = <7>;
++		ddr3a0_ddr4a10_de-skew = <7>;
++		ddr3a3_ddr4a6_de-skew = <8>;
++		ddr3a2_ddr4a4_de-skew = <8>;
++		ddr3a5_ddr4a8_de-skew = <7>;
++		ddr3a4_ddr4a5_de-skew = <9>;
++		ddr3a7_ddr4a11_de-skew = <7>;
++		ddr3a6_ddr4a7_de-skew = <9>;
++		ddr3a9_ddr4a0_de-skew = <8>;
++		ddr3a8_ddr4a13_de-skew = <7>;
++		ddr3a11_ddr4a3_de-skew = <9>;
++		ddr3a10_ddr4cs0_de-skew = <7>;
++		ddr3a13_ddr4a2_de-skew = <8>;
++		ddr3a12_ddr4ba1_de-skew = <7>;
++		ddr3a15_ddr4odt0_de-skew = <7>;
++		ddr3a14_ddr4a1_de-skew = <8>;
++		ddr3ba1_ddr4a15_de-skew = <7>;
++		ddr3ba0_ddr4bg0_de-skew = <7>;
++		ddr3ras_ddr4cke_de-skew = <7>;
++		ddr3ba2_ddr4ba0_de-skew = <8>;
++		ddr3we_ddr4bg1_de-skew = <8>;
++		ddr3cas_ddr4a12_de-skew = <7>;
++		ddr3ckn_ddr4ckn_de-skew = <8>;
++		ddr3ckp_ddr4ckp_de-skew = <8>;
++		ddr3cke_ddr4a16_de-skew = <8>;
++		ddr3odt0_ddr4a14_de-skew = <7>;
++		ddr3cs0_ddr4act_de-skew = <8>;
++		ddr3reset_ddr4reset_de-skew = <7>;
++		ddr3cs1_ddr4cs1_de-skew = <7>;
++		ddr3odt1_ddr4odt1_de-skew = <7>;
++
++		/* DATA de-skew
++		 * RX one step is 25.1ps, range 0-15
++		 * TX one step is 47.8ps, range 0-15
++		 */
++		cs0_dm0_rx_de-skew = <7>;
++		cs0_dm0_tx_de-skew = <8>;
++		cs0_dq0_rx_de-skew = <7>;
++		cs0_dq0_tx_de-skew = <8>;
++		cs0_dq1_rx_de-skew = <7>;
++		cs0_dq1_tx_de-skew = <8>;
++		cs0_dq2_rx_de-skew = <7>;
++		cs0_dq2_tx_de-skew = <8>;
++		cs0_dq3_rx_de-skew = <7>;
++		cs0_dq3_tx_de-skew = <8>;
++		cs0_dq4_rx_de-skew = <7>;
++		cs0_dq4_tx_de-skew = <8>;
++		cs0_dq5_rx_de-skew = <7>;
++		cs0_dq5_tx_de-skew = <8>;
++		cs0_dq6_rx_de-skew = <7>;
++		cs0_dq6_tx_de-skew = <8>;
++		cs0_dq7_rx_de-skew = <7>;
++		cs0_dq7_tx_de-skew = <8>;
++		cs0_dqs0_rx_de-skew = <6>;
++		cs0_dqs0p_tx_de-skew = <9>;
++		cs0_dqs0n_tx_de-skew = <9>;
++
++		cs0_dm1_rx_de-skew = <7>;
++		cs0_dm1_tx_de-skew = <7>;
++		cs0_dq8_rx_de-skew = <7>;
++		cs0_dq8_tx_de-skew = <8>;
++		cs0_dq9_rx_de-skew = <7>;
++		cs0_dq9_tx_de-skew = <7>;
++		cs0_dq10_rx_de-skew = <7>;
++		cs0_dq10_tx_de-skew = <8>;
++		cs0_dq11_rx_de-skew = <7>;
++		cs0_dq11_tx_de-skew = <7>;
++		cs0_dq12_rx_de-skew = <7>;
++		cs0_dq12_tx_de-skew = <8>;
++		cs0_dq13_rx_de-skew = <7>;
++		cs0_dq13_tx_de-skew = <7>;
++		cs0_dq14_rx_de-skew = <7>;
++		cs0_dq14_tx_de-skew = <8>;
++		cs0_dq15_rx_de-skew = <7>;
++		cs0_dq15_tx_de-skew = <7>;
++		cs0_dqs1_rx_de-skew = <7>;
++		cs0_dqs1p_tx_de-skew = <9>;
++		cs0_dqs1n_tx_de-skew = <9>;
++
++		cs0_dm2_rx_de-skew = <7>;
++		cs0_dm2_tx_de-skew = <8>;
++		cs0_dq16_rx_de-skew = <7>;
++		cs0_dq16_tx_de-skew = <8>;
++		cs0_dq17_rx_de-skew = <7>;
++		cs0_dq17_tx_de-skew = <8>;
++		cs0_dq18_rx_de-skew = <7>;
++		cs0_dq18_tx_de-skew = <8>;
++		cs0_dq19_rx_de-skew = <7>;
++		cs0_dq19_tx_de-skew = <8>;
++		cs0_dq20_rx_de-skew = <7>;
++		cs0_dq20_tx_de-skew = <8>;
++		cs0_dq21_rx_de-skew = <7>;
++		cs0_dq21_tx_de-skew = <8>;
++		cs0_dq22_rx_de-skew = <7>;
++		cs0_dq22_tx_de-skew = <8>;
++		cs0_dq23_rx_de-skew = <7>;
++		cs0_dq23_tx_de-skew = <8>;
++		cs0_dqs2_rx_de-skew = <6>;
++		cs0_dqs2p_tx_de-skew = <9>;
++		cs0_dqs2n_tx_de-skew = <9>;
++
++		cs0_dm3_rx_de-skew = <7>;
++		cs0_dm3_tx_de-skew = <7>;
++		cs0_dq24_rx_de-skew = <7>;
++		cs0_dq24_tx_de-skew = <8>;
++		cs0_dq25_rx_de-skew = <7>;
++		cs0_dq25_tx_de-skew = <7>;
++		cs0_dq26_rx_de-skew = <7>;
++		cs0_dq26_tx_de-skew = <7>;
++		cs0_dq27_rx_de-skew = <7>;
++		cs0_dq27_tx_de-skew = <7>;
++		cs0_dq28_rx_de-skew = <7>;
++		cs0_dq28_tx_de-skew = <7>;
++		cs0_dq29_rx_de-skew = <7>;
++		cs0_dq29_tx_de-skew = <7>;
++		cs0_dq30_rx_de-skew = <7>;
++		cs0_dq30_tx_de-skew = <7>;
++		cs0_dq31_rx_de-skew = <7>;
++		cs0_dq31_tx_de-skew = <7>;
++		cs0_dqs3_rx_de-skew = <7>;
++		cs0_dqs3p_tx_de-skew = <9>;
++		cs0_dqs3n_tx_de-skew = <9>;
++
++		cs1_dm0_rx_de-skew = <7>;
++		cs1_dm0_tx_de-skew = <8>;
++		cs1_dq0_rx_de-skew = <7>;
++		cs1_dq0_tx_de-skew = <8>;
++		cs1_dq1_rx_de-skew = <7>;
++		cs1_dq1_tx_de-skew = <8>;
++		cs1_dq2_rx_de-skew = <7>;
++		cs1_dq2_tx_de-skew = <8>;
++		cs1_dq3_rx_de-skew = <7>;
++		cs1_dq3_tx_de-skew = <8>;
++		cs1_dq4_rx_de-skew = <7>;
++		cs1_dq4_tx_de-skew = <8>;
++		cs1_dq5_rx_de-skew = <7>;
++		cs1_dq5_tx_de-skew = <8>;
++		cs1_dq6_rx_de-skew = <7>;
++		cs1_dq6_tx_de-skew = <8>;
++		cs1_dq7_rx_de-skew = <7>;
++		cs1_dq7_tx_de-skew = <8>;
++		cs1_dqs0_rx_de-skew = <6>;
++		cs1_dqs0p_tx_de-skew = <9>;
++		cs1_dqs0n_tx_de-skew = <9>;
++
++		cs1_dm1_rx_de-skew = <7>;
++		cs1_dm1_tx_de-skew = <7>;
++		cs1_dq8_rx_de-skew = <7>;
++		cs1_dq8_tx_de-skew = <8>;
++		cs1_dq9_rx_de-skew = <7>;
++		cs1_dq9_tx_de-skew = <7>;
++		cs1_dq10_rx_de-skew = <7>;
++		cs1_dq10_tx_de-skew = <8>;
++		cs1_dq11_rx_de-skew = <7>;
++		cs1_dq11_tx_de-skew = <7>;
++		cs1_dq12_rx_de-skew = <7>;
++		cs1_dq12_tx_de-skew = <8>;
++		cs1_dq13_rx_de-skew = <7>;
++		cs1_dq13_tx_de-skew = <7>;
++		cs1_dq14_rx_de-skew = <7>;
++		cs1_dq14_tx_de-skew = <8>;
++		cs1_dq15_rx_de-skew = <7>;
++		cs1_dq15_tx_de-skew = <7>;
++		cs1_dqs1_rx_de-skew = <7>;
++		cs1_dqs1p_tx_de-skew = <9>;
++		cs1_dqs1n_tx_de-skew = <9>;
++
++		cs1_dm2_rx_de-skew = <7>;
++		cs1_dm2_tx_de-skew = <8>;
++		cs1_dq16_rx_de-skew = <7>;
++		cs1_dq16_tx_de-skew = <8>;
++		cs1_dq17_rx_de-skew = <7>;
++		cs1_dq17_tx_de-skew = <8>;
++		cs1_dq18_rx_de-skew = <7>;
++		cs1_dq18_tx_de-skew = <8>;
++		cs1_dq19_rx_de-skew = <7>;
++		cs1_dq19_tx_de-skew = <8>;
++		cs1_dq20_rx_de-skew = <7>;
++		cs1_dq20_tx_de-skew = <8>;
++		cs1_dq21_rx_de-skew = <7>;
++		cs1_dq21_tx_de-skew = <8>;
++		cs1_dq22_rx_de-skew = <7>;
++		cs1_dq22_tx_de-skew = <8>;
++		cs1_dq23_rx_de-skew = <7>;
++		cs1_dq23_tx_de-skew = <8>;
++		cs1_dqs2_rx_de-skew = <6>;
++		cs1_dqs2p_tx_de-skew = <9>;
++		cs1_dqs2n_tx_de-skew = <9>;
++
++		cs1_dm3_rx_de-skew = <7>;
++		cs1_dm3_tx_de-skew = <7>;
++		cs1_dq24_rx_de-skew = <7>;
++		cs1_dq24_tx_de-skew = <8>;
++		cs1_dq25_rx_de-skew = <7>;
++		cs1_dq25_tx_de-skew = <7>;
++		cs1_dq26_rx_de-skew = <7>;
++		cs1_dq26_tx_de-skew = <7>;
++		cs1_dq27_rx_de-skew = <7>;
++		cs1_dq27_tx_de-skew = <7>;
++		cs1_dq28_rx_de-skew = <7>;
++		cs1_dq28_tx_de-skew = <7>;
++		cs1_dq29_rx_de-skew = <7>;
++		cs1_dq29_tx_de-skew = <7>;
++		cs1_dq30_rx_de-skew = <7>;
++		cs1_dq30_tx_de-skew = <7>;
++		cs1_dq31_rx_de-skew = <7>;
++		cs1_dq31_tx_de-skew = <7>;
++		cs1_dqs3_rx_de-skew = <7>;
++		cs1_dqs3p_tx_de-skew = <9>;
++		cs1_dqs3n_tx_de-skew = <9>;
++	};
++};
+diff --git a/include/dt-bindings/clock/rockchip-ddr.h b/include/dt-bindings/clock/rockchip-ddr.h
+new file mode 100644
+index 000000000..b065432e7
+--- /dev/null
++++ b/include/dt-bindings/clock/rockchip-ddr.h
+@@ -0,0 +1,63 @@
++/*
++ *
++ * Copyright (C) 2017 ROCKCHIP, Inc.
++ *
++ * This software is licensed under the terms of the GNU General Public
++ * License version 2, as published by the Free Software Foundation, and
++ * may be copied, distributed, and modified under those terms.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ */
++
++#ifndef _DT_BINDINGS_CLOCK_ROCKCHIP_DDR_H
++#define _DT_BINDINGS_CLOCK_ROCKCHIP_DDR_H
++
++#define DDR2_DEFAULT	(0)
++
++#define DDR3_800D	(0)	/* 5-5-5 */
++#define DDR3_800E	(1)	/* 6-6-6 */
++#define DDR3_1066E	(2)	/* 6-6-6 */
++#define DDR3_1066F	(3)	/* 7-7-7 */
++#define DDR3_1066G	(4)	/* 8-8-8 */
++#define DDR3_1333F	(5)	/* 7-7-7 */
++#define DDR3_1333G	(6)	/* 8-8-8 */
++#define DDR3_1333H	(7)	/* 9-9-9 */
++#define DDR3_1333J	(8)	/* 10-10-10 */
++#define DDR3_1600G	(9)	/* 8-8-8 */
++#define DDR3_1600H	(10)	/* 9-9-9 */
++#define DDR3_1600J	(11)	/* 10-10-10 */
++#define DDR3_1600K	(12)	/* 11-11-11 */
++#define DDR3_1866J	(13)	/* 10-10-10 */
++#define DDR3_1866K	(14)	/* 11-11-11 */
++#define DDR3_1866L	(15)	/* 12-12-12 */
++#define DDR3_1866M	(16)	/* 13-13-13 */
++#define DDR3_2133K	(17)	/* 11-11-11 */
++#define DDR3_2133L	(18)	/* 12-12-12 */
++#define DDR3_2133M	(19)	/* 13-13-13 */
++#define DDR3_2133N	(20)	/* 14-14-14 */
++#define DDR3_DEFAULT	(21)
++#define DDR_DDR2	(22)
++#define DDR_LPDDR	(23)
++#define DDR_LPDDR2	(24)
++
++#define DDR4_1600J	(0)	/* 10-10-10 */
++#define DDR4_1600K	(1)	/* 11-11-11 */
++#define DDR4_1600L	(2)	/* 12-12-12 */
++#define DDR4_1866L	(3)	/* 12-12-12 */
++#define DDR4_1866M	(4)	/* 13-13-13 */
++#define DDR4_1866N	(5)	/* 14-14-14 */
++#define DDR4_2133N	(6)	/* 14-14-14 */
++#define DDR4_2133P	(7)	/* 15-15-15 */
++#define DDR4_2133R	(8)	/* 16-16-16 */
++#define DDR4_2400P	(9)	/* 15-15-15 */
++#define DDR4_2400R	(10)	/* 16-16-16 */
++#define DDR4_2400U	(11)	/* 18-18-18 */
++#define DDR4_DEFAULT	(12)
++
++#define PAUSE_CPU_STACK_SIZE	16
++
++#endif
+diff --git a/include/dt-bindings/memory/rk3328-dram.h b/include/dt-bindings/memory/rk3328-dram.h
+new file mode 100644
+index 000000000..171f41c25
+--- /dev/null
++++ b/include/dt-bindings/memory/rk3328-dram.h
+@@ -0,0 +1,159 @@
++/*
++ * Copyright (c) 2017 Fuzhou Rockchip Electronics Co., Ltd
++ *
++ * This file is dual-licensed: you can use it either under the terms
++ * of the GPL or the X11 license, at your option. Note that this dual
++ * licensing only applies to this file, and not this project as a
++ * whole.
++ *
++ *  a) This library is free software; you can redistribute it and/or
++ *     modify it under the terms of the GNU General Public License as
++ *     published by the Free Software Foundation; either version 2 of the
++ *     License, or (at your option) any later version.
++ *
++ *     This library is distributed in the hope that it will be useful,
++ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
++ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ *     GNU General Public License for more details.
++ *
++ * Or, alternatively,
++ *
++ *  b) Permission is hereby granted, free of charge, to any person
++ *     obtaining a copy of this software and associated documentation
++ *     files (the "Software"), to deal in the Software without
++ *     restriction, including without limitation the rights to use,
++ *     copy, modify, merge, publish, distribute, sublicense, and/or
++ *     sell copies of the Software, and to permit persons to whom the
++ *     Software is furnished to do so, subject to the following
++ *     conditions:
++ *
++ *     The above copyright notice and this permission notice shall be
++ *     included in all copies or substantial portions of the Software.
++ *
++ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
++ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
++ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
++ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
++ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
++ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
++ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
++ *     OTHER DEALINGS IN THE SOFTWARE.
++ */
++#ifndef _DT_BINDINGS_DRAM_ROCKCHIP_RK3328_H
++#define _DT_BINDINGS_DRAM_ROCKCHIP_RK3328_H
++
++#define DDR3_DS_34ohm			(34)
++#define DDR3_DS_40ohm			(40)
++
++#define DDR3_ODT_DIS			(0)
++#define DDR3_ODT_40ohm			(40)
++#define DDR3_ODT_60ohm			(60)
++#define DDR3_ODT_120ohm			(120)
++
++#define LP2_DS_34ohm			(34)
++#define LP2_DS_40ohm			(40)
++#define LP2_DS_48ohm			(48)
++#define LP2_DS_60ohm			(60)
++#define LP2_DS_68_6ohm			(68)	/* optional */
++#define LP2_DS_80ohm			(80)
++#define LP2_DS_120ohm			(120)	/* optional */
++
++#define LP3_DS_34ohm			(34)
++#define LP3_DS_40ohm			(40)
++#define LP3_DS_48ohm			(48)
++#define LP3_DS_60ohm			(60)
++#define LP3_DS_80ohm			(80)
++#define LP3_DS_34D_40U			(3440)
++#define LP3_DS_40D_48U			(4048)
++#define LP3_DS_34D_48U			(3448)
++
++#define LP3_ODT_DIS			(0)
++#define LP3_ODT_60ohm			(60)
++#define LP3_ODT_120ohm			(120)
++#define LP3_ODT_240ohm			(240)
++
++#define LP4_PDDS_40ohm			(40)
++#define LP4_PDDS_48ohm			(48)
++#define LP4_PDDS_60ohm			(60)
++#define LP4_PDDS_80ohm			(80)
++#define LP4_PDDS_120ohm			(120)
++#define LP4_PDDS_240ohm			(240)
++
++#define LP4_DQ_ODT_40ohm		(40)
++#define LP4_DQ_ODT_48ohm		(48)
++#define LP4_DQ_ODT_60ohm		(60)
++#define LP4_DQ_ODT_80ohm		(80)
++#define LP4_DQ_ODT_120ohm		(120)
++#define LP4_DQ_ODT_240ohm		(240)
++#define LP4_DQ_ODT_DIS			(0)
++
++#define LP4_CA_ODT_40ohm		(40)
++#define LP4_CA_ODT_48ohm		(48)
++#define LP4_CA_ODT_60ohm		(60)
++#define LP4_CA_ODT_80ohm		(80)
++#define LP4_CA_ODT_120ohm		(120)
++#define LP4_CA_ODT_240ohm		(240)
++#define LP4_CA_ODT_DIS			(0)
++
++#define DDR4_DS_34ohm			(34)
++#define DDR4_DS_48ohm			(48)
++#define DDR4_RTT_NOM_DIS		(0)
++#define DDR4_RTT_NOM_60ohm		(60)
++#define DDR4_RTT_NOM_120ohm		(120)
++#define DDR4_RTT_NOM_40ohm		(40)
++#define DDR4_RTT_NOM_240ohm		(240)
++#define DDR4_RTT_NOM_48ohm		(48)
++#define DDR4_RTT_NOM_80ohm		(80)
++#define DDR4_RTT_NOM_34ohm		(34)
++
++#define PHY_DDR3_RON_RTT_DISABLE	(0)
++#define PHY_DDR3_RON_RTT_451ohm		(1)
++#define PHY_DDR3_RON_RTT_225ohm		(2)
++#define PHY_DDR3_RON_RTT_150ohm		(3)
++#define PHY_DDR3_RON_RTT_112ohm		(4)
++#define PHY_DDR3_RON_RTT_90ohm		(5)
++#define PHY_DDR3_RON_RTT_75ohm		(6)
++#define PHY_DDR3_RON_RTT_64ohm		(7)
++#define PHY_DDR3_RON_RTT_56ohm		(16)
++#define PHY_DDR3_RON_RTT_50ohm		(17)
++#define PHY_DDR3_RON_RTT_45ohm		(18)
++#define PHY_DDR3_RON_RTT_41ohm		(19)
++#define PHY_DDR3_RON_RTT_37ohm		(20)
++#define PHY_DDR3_RON_RTT_34ohm		(21)
++#define PHY_DDR3_RON_RTT_33ohm		(22)
++#define PHY_DDR3_RON_RTT_30ohm		(23)
++#define PHY_DDR3_RON_RTT_28ohm		(24)
++#define PHY_DDR3_RON_RTT_26ohm		(25)
++#define PHY_DDR3_RON_RTT_25ohm		(26)
++#define PHY_DDR3_RON_RTT_23ohm		(27)
++#define PHY_DDR3_RON_RTT_22ohm		(28)
++#define PHY_DDR3_RON_RTT_21ohm		(29)
++#define PHY_DDR3_RON_RTT_20ohm		(30)
++#define PHY_DDR3_RON_RTT_19ohm		(31)
++
++#define PHY_DDR4_LPDDR3_RON_RTT_DISABLE (0)
++#define PHY_DDR4_LPDDR3_RON_RTT_480ohm	(1)
++#define PHY_DDR4_LPDDR3_RON_RTT_240ohm	(2)
++#define PHY_DDR4_LPDDR3_RON_RTT_160ohm	(3)
++#define PHY_DDR4_LPDDR3_RON_RTT_120ohm	(4)
++#define PHY_DDR4_LPDDR3_RON_RTT_96ohm	(5)
++#define PHY_DDR4_LPDDR3_RON_RTT_80ohm	(6)
++#define PHY_DDR4_LPDDR3_RON_RTT_68ohm	(7)
++#define PHY_DDR4_LPDDR3_RON_RTT_60ohm	(16)
++#define PHY_DDR4_LPDDR3_RON_RTT_53ohm	(17)
++#define PHY_DDR4_LPDDR3_RON_RTT_48ohm	(18)
++#define PHY_DDR4_LPDDR3_RON_RTT_43ohm	(19)
++#define PHY_DDR4_LPDDR3_RON_RTT_40ohm	(20)
++#define PHY_DDR4_LPDDR3_RON_RTT_37ohm	(21)
++#define PHY_DDR4_LPDDR3_RON_RTT_34ohm	(22)
++#define PHY_DDR4_LPDDR3_RON_RTT_32ohm	(23)
++#define PHY_DDR4_LPDDR3_RON_RTT_30ohm	(24)
++#define PHY_DDR4_LPDDR3_RON_RTT_28ohm	(25)
++#define PHY_DDR4_LPDDR3_RON_RTT_26ohm	(26)
++#define PHY_DDR4_LPDDR3_RON_RTT_25ohm	(27)
++#define PHY_DDR4_LPDDR3_RON_RTT_24ohm	(28)
++#define PHY_DDR4_LPDDR3_RON_RTT_22ohm	(29)
++#define PHY_DDR4_LPDDR3_RON_RTT_21ohm	(30)
++#define PHY_DDR4_LPDDR3_RON_RTT_20ohm	(31)
++
++#endif /*_DT_BINDINGS_DRAM_ROCKCHIP_RK3328_H*/
diff --git a/target/linux/rockchip/patches-5.4/010-nanopi-r2s-rtl8152-leds.patch b/target/linux/rockchip/patches-5.4/010-nanopi-r2s-rtl8152-leds.patch
new file mode 100644
index 0000000000..eea0c9763d
--- /dev/null
+++ b/target/linux/rockchip/patches-5.4/010-nanopi-r2s-rtl8152-leds.patch
@@ -0,0 +1,36 @@
+From 2d4f786f94b331904682c24a792462726d474007 Mon Sep 17 00:00:00 2001
+From: hmz007 <hmz007@gmail.com>
+Date: Mon, 23 Dec 2019 13:10:06 +0800
+Subject: [PATCH] r8152: Add module param for customized LEDs
+
+Signed-off-by: hmz007 <hmz007@gmail.com>
+---
+ drivers/net/usb/r8152.c | 8 ++++++++
+ 1 file changed, 8 insertions(+)
+
+diff --git a/drivers/net/usb/r8152.c b/drivers/net/usb/r8152.c
+index eb78f6d9390c..ec737fffcded 100644
+--- a/drivers/net/usb/r8152.c
++++ b/drivers/net/usb/r8152.c
+@@ -37,6 +37,11 @@
+ #define DRIVER_DESC "Realtek RTL8152/RTL8153 Based USB Ethernet Adapters"
+ #define MODULENAME "r8152"
+ 
++/* LED0: Activity, LED1: Link */
++static int ledsel = 0x78;
++module_param(ledsel, int, 0);
++MODULE_PARM_DESC(ledsel, "Override default LED configuration");
++
+ #define R8152_PHY_ID		32
+ 
+ #define PLA_IDR			0xc000
+@@ -4545,6 +4550,9 @@ static void r8153b_init(struct r8152 *tp)
+ 	ocp_data &= ~(RX_AGG_DISABLE | RX_ZERO_EN);
+ 	ocp_write_word(tp, MCU_TYPE_USB, USB_USB_CTRL, ocp_data);
+ 
++	/* set customized led */
++	ocp_write_word(tp, MCU_TYPE_PLA, PLA_LEDSEL, ledsel);
++
+ 	rtl_tally_reset(tp);
+ 
+ 	tp->coalesce = 15000;	/* 15 us */
diff --git a/target/linux/rockchip/patches-5.4/011-nanopi-r2s-mac-frfom-dt.patch b/target/linux/rockchip/patches-5.4/011-nanopi-r2s-mac-frfom-dt.patch
new file mode 100644
index 0000000000..4040e88f09
--- /dev/null
+++ b/target/linux/rockchip/patches-5.4/011-nanopi-r2s-mac-frfom-dt.patch
@@ -0,0 +1,40 @@
+From 27dfe6f4347e883fd618d5a37500c7f6d3652fb9 Mon Sep 17 00:00:00 2001
+From: hmz007 <hmz007@gmail.com>
+Date: Fri, 22 Nov 2019 19:03:00 +0800
+Subject: [PATCH] r8152: support to get MAC address from device tree
+
+Signed-off-by: hmz007 <hmz007@gmail.com>
+---
+ drivers/net/usb/r8152.c | 12 ++++++++++++
+ 1 file changed, 12 insertions(+)
+
+diff --git a/drivers/net/usb/r8152.c b/drivers/net/usb/r8152.c
+index b2507c59ba8b..eb78f6d9390c 100644
+--- a/drivers/net/usb/r8152.c
++++ b/drivers/net/usb/r8152.c
+@@ -6,6 +6,7 @@
+ #include <linux/signal.h>
+ #include <linux/slab.h>
+ #include <linux/module.h>
++#include <linux/of_net.h>
+ #include <linux/netdevice.h>
+ #include <linux/etherdevice.h>
+ #include <linux/mii.h>
+@@ -1298,6 +1299,17 @@ static int determine_ethernet_addr(struct r8152 *tp, struct sockaddr *sa)
+ 	if (ret < 0) {
+ 		netif_err(tp, probe, dev, "Get ether addr fail\n");
+ 	} else if (!is_valid_ether_addr(sa->sa_data)) {
++		/* try to get MAC address from DT */
++		if (tp->udev->dev.of_node) {
++			const u8 *mac = of_get_mac_address(tp->udev->dev.of_node);
++			if (!IS_ERR(mac) && is_valid_ether_addr(mac)) {
++				ether_addr_copy(sa->sa_data, mac);
++				netif_info(tp, probe, dev, "DT mac addr %pM\n",
++					   sa->sa_data);
++				return 0;
++			}
++		}
++
+ 		netif_err(tp, probe, dev, "Invalid ether addr %pM\n",
+ 			  sa->sa_data);
+ 		eth_hw_addr_random(dev);
