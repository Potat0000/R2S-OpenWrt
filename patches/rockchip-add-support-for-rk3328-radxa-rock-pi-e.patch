From 12546a0da7d5c4031e8b270b49827e05728f0846 Mon Sep 17 00:00:00 2001
From: Jayantajit Gogoi <jayanta.gogoi525@gmail.com>
Date: Thu, 11 Jun 2020 18:26:48 +0000
Subject: [PATCH] rockchip: add support for rk3328 radxa rock pi e

Signed-off-by: Jayantajit Gogoi <jayanta.gogoi525@gmail.com>
---
 .../arm-trusted-firmware-rockchip/Makefile    |    6 +-
 package/boot/uboot-rockchip/Makefile          |   18 +-
 ...p-Avoid-using-libfdt-with-of-platdata.diff |   65 +
 ...ude-ofnode-functions-with-of-platdata.diff |   41 +
 ...TPL-to-use-of-platdata-without-libfdt.diff |   22 +
 .../005-add-rock-pi-e-support-dts.patch       |  325 ++++
 .../patches/006-add-rock-pi-e-defconfig.patch |  110 ++
 .../patches/007-sdmmc-fifo-mode-in-spl.patch  |   22 +
 .../patches/008-set-sdmmc-priority.patch      |   15 +
 .../armv8/base-files/etc/board.d/02_network   |    3 +
 .../rockchip/armv8/base-files/etc/inittab     |    6 +
 target/linux/rockchip/armv8/config-5.4        |   78 +-
 target/linux/rockchip/image/Makefile          |    6 +-
 target/linux/rockchip/image/armv8.mk          |   12 +-
 target/linux/rockchip/image/mmc.bootscript    |   14 +-
 .../001-rk3328_fix_wrong_mmc_shift.patch      |   48 +
 .../002-add-rk3328-usb3-driver.patch          | 1424 +++++++++++++++++
 .../003-add-rk3328-rock-pi-e-support.patch    |  420 +++++
 .../004-rk3328_add_idle_state.patch           |   71 +
 .../004-unlock-1512mhz-rk3328.patch           |   16 +
 .../patches-5.4/005-add_hwmon_support.patch   |   92 ++
 .../006-rk3328_add_mmc_reset.patch            |   40 +
 .../patches-5.4/007-add_mmc_poweroff.patch    |   94 ++
 .../rockchip/patches-5.4/008-mmc_rename.patch |   56 +
 .../009-rk3328_add_sdmmc_ext_node.patch       |   34 +
 25 files changed, 3018 insertions(+), 20 deletions(-)
 create mode 100644 package/boot/uboot-rockchip/patches/001-rockchip-Avoid-using-libfdt-with-of-platdata.diff
 create mode 100644 package/boot/uboot-rockchip/patches/002-dm-core-Don-t-include-ofnode-functions-with-of-platdata.diff
 create mode 100644 package/boot/uboot-rockchip/patches/003-spl-Allow-SPL-TPL-to-use-of-platdata-without-libfdt.diff
 create mode 100644 package/boot/uboot-rockchip/patches/005-add-rock-pi-e-support-dts.patch
 create mode 100644 package/boot/uboot-rockchip/patches/006-add-rock-pi-e-defconfig.patch
 create mode 100644 package/boot/uboot-rockchip/patches/007-sdmmc-fifo-mode-in-spl.patch
 create mode 100644 package/boot/uboot-rockchip/patches/008-set-sdmmc-priority.patch
 create mode 100644 target/linux/rockchip/armv8/base-files/etc/inittab
 create mode 100644 target/linux/rockchip/patches-5.4/001-rk3328_fix_wrong_mmc_shift.patch
 create mode 100644 target/linux/rockchip/patches-5.4/002-add-rk3328-usb3-driver.patch
 create mode 100644 target/linux/rockchip/patches-5.4/003-add-rk3328-rock-pi-e-support.patch
 create mode 100644 target/linux/rockchip/patches-5.4/004-rk3328_add_idle_state.patch
 create mode 100644 target/linux/rockchip/patches-5.4/004-unlock-1512mhz-rk3328.patch
 create mode 100644 target/linux/rockchip/patches-5.4/005-add_hwmon_support.patch
 create mode 100644 target/linux/rockchip/patches-5.4/006-rk3328_add_mmc_reset.patch
 create mode 100644 target/linux/rockchip/patches-5.4/007-add_mmc_poweroff.patch
 create mode 100644 target/linux/rockchip/patches-5.4/008-mmc_rename.patch
 create mode 100644 target/linux/rockchip/patches-5.4/009-rk3328_add_sdmmc_ext_node.patch

diff --git a/package/boot/arm-trusted-firmware-rockchip/Makefile b/package/boot/arm-trusted-firmware-rockchip/Makefile
index a1c9e120e7..b712a3530a 100644
--- a/package/boot/arm-trusted-firmware-rockchip/Makefile
+++ b/package/boot/arm-trusted-firmware-rockchip/Makefile
@@ -8,12 +8,12 @@
 include $(TOPDIR)/rules.mk
 
 PKG_NAME:=arm-trusted-firmware-rockchip
-PKG_VERSION:=2.3-rc0
+PKG_VERSION:=2.3
 PKG_RELEASE:=1
 
 PKG_SOURCE:=atf-v$(PKG_VERSION).tar.gz
 PKG_SOURCE_URL:=https://github.com/atf-builds/atf/releases/download/v$(PKG_VERSION)/atf-v$(PKG_VERSION).tar.gz?
-PKG_HASH:=8d0a2bd18adf54f9cf6fe923d10f21c1d21f42a15067757333ff8989b25f100a
+PKG_HASH:=bf352298743aed594cf2958dd588e06ab6713fc514bb6f809bf55a85a87134c1
 
 PKG_LICENSE:=BSD-3-Clause
 PKG_LICENSE_FILES:=license.md
@@ -40,7 +40,7 @@ endef
 
 define Build/InstallDev
 	$(INSTALL_DIR) -p $(STAGING_DIR_IMAGE)
-	$(CP) $(PKG_BUILD_DIR)/rk3399_bl31.elf $(STAGING_DIR_IMAGE)/bl31.elf
+	$(CP) $(PKG_BUILD_DIR)/rk*.elf $(STAGING_DIR_IMAGE)/
 endef
 
 define Package/arm-trusted-firmware-rockchip/install
diff --git a/package/boot/uboot-rockchip/Makefile b/package/boot/uboot-rockchip/Makefile
index b99d051fcf..13ca020861 100644
--- a/package/boot/uboot-rockchip/Makefile
+++ b/package/boot/uboot-rockchip/Makefile
@@ -13,6 +13,7 @@ PKG_MAINTAINER:=Tobias Maedel <openwrt@tbspace.de>
 
 include $(INCLUDE_DIR)/u-boot.mk
 include $(INCLUDE_DIR)/package.mk
+PKG_BUILD_DEPENDS:=arm-trusted-firmware-rockchip
 
 define U-Boot/Default
   BUILD_TARGET:=rockchip
@@ -20,27 +21,34 @@ define U-Boot/Default
   HIDDEN:=1
 endef
 
+define U-Boot/rock-pi-e-rk3328
+  BUILD_SUBTARGET:=armv8
+  NAME:=Rock Pi E
+  BUILD_DEVICES:= \
+    radxa_rock-pi-e
+  BL31=$(STAGING_DIR_IMAGE)/rk3328_bl31.elf
+endef
+
 define U-Boot/rockpro64-rk3399
   BUILD_SUBTARGET:=armv8
   NAME:=RockPro64
   BUILD_DEVICES:= \
     pine64_rockpro64
-  DEPENDS:=+PACKAGE_u-boot-rockpro64-rk3399:arm-trusted-firmware-rockchip
-  PKG_BUILD_DEPENDS:=arm-trusted-firmware-rockchip
+  BL31=$(STAGING_DIR_IMAGE)/rk3399_bl31.elf
 endef
 
 UBOOT_TARGETS := \
+  rock-pi-e-rk3328 \
   rockpro64-rk3399
 
 UBOOT_CONFIGURE_VARS += USE_PRIVATE_LIBGCC=yes
 
 UBOOT_MAKE_FLAGS += \
-  BL31=$(STAGING_DIR_IMAGE)/bl31.elf
+  BL31=$(BL31)
 
 define Build/Configure
-	$(SED) s/subdir.*pylibfdt//g $(PKG_BUILD_DIR)/scripts/dtc/Makefile
+	echo CONFIG_CMD_SETEXPR=y >> $(PKG_BUILD_DIR)/configs/$(UBOOT_CONFIG)_defconfig
 	$(call Build/Configure/U-Boot)
-
 	$(SED) 's#CONFIG_MKIMAGE_DTC_PATH=.*#CONFIG_MKIMAGE_DTC_PATH="$(PKG_BUILD_DIR)/scripts/dtc/dtc"#g' $(PKG_BUILD_DIR)/.config
 	echo 'CONFIG_IDENT_STRING=" OpenWrt"' >> $(PKG_BUILD_DIR)/.config
 endef
diff --git a/package/boot/uboot-rockchip/patches/001-rockchip-Avoid-using-libfdt-with-of-platdata.diff b/package/boot/uboot-rockchip/patches/001-rockchip-Avoid-using-libfdt-with-of-platdata.diff
new file mode 100644
index 0000000000..21e8202533
--- /dev/null
+++ b/package/boot/uboot-rockchip/patches/001-rockchip-Avoid-using-libfdt-with-of-platdata.diff
@@ -0,0 +1,65 @@
+diff --git a/drivers/clk/rockchip/clk_rk3328.c b/drivers/clk/rockchip/clk_rk3328.c
+index a89e2ecc4a..e86c17e6d6 100644
+--- a/drivers/clk/rockchip/clk_rk3328.c
++++ b/drivers/clk/rockchip/clk_rk3328.c
+@@ -672,6 +672,10 @@ static int rk3328_gmac2io_set_parent(struct clk *clk, struct clk *parent)
+ 		return 0;
+ 	}
+ 
++	/* FIXME: Device tree should be read in ofdata_to_platdata() */
++	if (CONFIG_IS_ENABLED(OF_PLATDATA))
++		return -EDEADLK;
++
+ 	/*
+ 	 * Otherwise, we need to check the clock-output-names of the
+ 	 * requested parent to see if the requested id is "gmac_clkin".
+@@ -709,6 +713,10 @@ static int rk3328_gmac2io_ext_set_parent(struct clk *clk, struct clk *parent)
+ 		return 0;
+ 	}
+ 
++	/* FIXME: Device tree should be read in ofdata_to_platdata() */
++	if (CONFIG_IS_ENABLED(OF_PLATDATA))
++		return -EDEADLK;
++
+ 	/*
+ 	 * Otherwise, we need to check the clock-output-names of the
+ 	 * requested parent to see if the requested id is "gmac_clkin".
+@@ -765,9 +773,11 @@ static int rk3328_clk_probe(struct udevice *dev)
+ 
+ static int rk3328_clk_ofdata_to_platdata(struct udevice *dev)
+ {
+-	struct rk3328_clk_priv *priv = dev_get_priv(dev);
++	if (!CONFIG_IS_ENABLED(OF_PLATDATA)) {
++		struct rk3328_clk_priv *priv = dev_get_priv(dev);
+ 
+-	priv->cru = dev_read_addr_ptr(dev);
++		priv->cru = dev_read_addr_ptr(dev);
++	}
+ 
+ 	return 0;
+ }
+diff --git a/drivers/pinctrl/rockchip/pinctrl-rockchip-core.c b/drivers/pinctrl/rockchip/pinctrl-rockchip-core.c
+index 80dc431d20..dccc54e95f 100644
+--- a/drivers/pinctrl/rockchip/pinctrl-rockchip-core.c
++++ b/drivers/pinctrl/rockchip/pinctrl-rockchip-core.c
+@@ -383,8 +383,8 @@ static int rockchip_pinconf_prop_name_to_param(const char *property,
+ 	return -EPERM;
+ }
+ 
+-static int rockchip_pinctrl_set_state(struct udevice *dev,
+-				      struct udevice *config)
++static int __maybe_unused rockchip_pinctrl_set_state(struct udevice *dev,
++						     struct udevice *config)
+ {
+ 	struct rockchip_pinctrl_priv *priv = dev_get_priv(dev);
+ 	struct rockchip_pin_ctrl *ctrl = priv->ctrl;
+@@ -474,7 +474,9 @@ static int rockchip_pinctrl_set_state(struct udevice *dev,
+ }
+ 
+ const struct pinctrl_ops rockchip_pinctrl_ops = {
++#if !CONFIG_IS_ENABLED(PLATDATA)
+ 	.set_state			= rockchip_pinctrl_set_state,
++#endif
+ 	.get_gpio_mux			= rockchip_pinctrl_get_gpio_mux,
+ };
+ 
diff --git a/package/boot/uboot-rockchip/patches/002-dm-core-Don-t-include-ofnode-functions-with-of-platdata.diff b/package/boot/uboot-rockchip/patches/002-dm-core-Don-t-include-ofnode-functions-with-of-platdata.diff
new file mode 100644
index 0000000000..c25b320e87
--- /dev/null
+++ b/package/boot/uboot-rockchip/patches/002-dm-core-Don-t-include-ofnode-functions-with-of-platdata.diff
@@ -0,0 +1,41 @@
+diff --git a/drivers/core/Makefile b/drivers/core/Makefile
+index bce7467da1..b9e4a2aab1 100644
+--- a/drivers/core/Makefile
++++ b/drivers/core/Makefile
+@@ -13,6 +13,8 @@ obj-$(CONFIG_OF_LIVE) += of_access.o of_addr.o
+ ifndef CONFIG_DM_DEV_READ_INLINE
+ obj-$(CONFIG_OF_CONTROL) += read.o
+ endif
+-obj-$(CONFIG_OF_CONTROL) += of_extra.o ofnode.o read_extra.o
++ifdef CONFIG_$(SPL_TPL_)OF_LIBFDT
++obj-$(CONFIG_$(SPL_TPL_)OF_CONTROL) += of_extra.o ofnode.o read_extra.o
++endif
+ 
+ ccflags-$(CONFIG_DM_DEBUG) += -DDEBUG
+diff --git a/include/dm/read.h b/include/dm/read.h
+index d37fcb504d..4f02d07d00 100644
+--- a/include/dm/read.h
++++ b/include/dm/read.h
+@@ -43,8 +43,7 @@ static inline bool dev_of_valid(struct udevice *dev)
+ 	return ofnode_valid(dev_ofnode(dev));
+ }
+ 
+-#ifndef CONFIG_DM_DEV_READ_INLINE
+-
++#if !defined(CONFIG_DM_DEV_READ_INLINE) || CONFIG_IS_ENABLED(OF_PLATDATA)
+ /**
+  * dev_read_u32() - read a 32-bit integer from a device's DT property
+  *
+diff --git a/net/eth-uclass.c b/net/eth-uclass.c
+index 3bd98b01ad..e3bfcdb6cc 100644
+--- a/net/eth-uclass.c
++++ b/net/eth-uclass.c
+@@ -467,7 +467,7 @@ static int eth_pre_unbind(struct udevice *dev)
+ 
+ static bool eth_dev_get_mac_address(struct udevice *dev, u8 mac[ARP_HLEN])
+ {
+-#if IS_ENABLED(CONFIG_OF_CONTROL)
++#if CONFIG_IS_ENABLED(OF_CONTROL)
+ 	const uint8_t *p;
+ 
+ 	p = dev_read_u8_array_ptr(dev, "mac-address", ARP_HLEN);
diff --git a/package/boot/uboot-rockchip/patches/003-spl-Allow-SPL-TPL-to-use-of-platdata-without-libfdt.diff b/package/boot/uboot-rockchip/patches/003-spl-Allow-SPL-TPL-to-use-of-platdata-without-libfdt.diff
new file mode 100644
index 0000000000..144657b9a8
--- /dev/null
+++ b/package/boot/uboot-rockchip/patches/003-spl-Allow-SPL-TPL-to-use-of-platdata-without-libfdt.diff
@@ -0,0 +1,22 @@
+diff --git a/lib/Kconfig b/lib/Kconfig
+index b8a8509d72..1cae2d5cc8 100644
+--- a/lib/Kconfig
++++ b/lib/Kconfig
+@@ -496,7 +496,7 @@ config OF_LIBFDT_OVERLAY
+ 
+ config SPL_OF_LIBFDT
+ 	bool "Enable the FDT library for SPL"
+-	default y if SPL_OF_CONTROL
++	default y if SPL_OF_CONTROL && !SPL_OF_PLATDATA
+ 	help
+ 	  This enables the FDT library (libfdt). It provides functions for
+ 	  accessing binary device tree images in memory, such as adding and
+@@ -517,7 +517,7 @@ config SPL_OF_LIBFDT_ASSUME_MASK
+ 
+ config TPL_OF_LIBFDT
+ 	bool "Enable the FDT library for TPL"
+-	default y if TPL_OF_CONTROL
++	default y if TPL_OF_CONTROL && !TPL_OF_PLATDATA
+ 	help
+ 	  This enables the FDT library (libfdt). It provides functions for
+ 	  accessing binary device tree images in memory, such as adding and
diff --git a/package/boot/uboot-rockchip/patches/005-add-rock-pi-e-support-dts.patch b/package/boot/uboot-rockchip/patches/005-add-rock-pi-e-support-dts.patch
new file mode 100644
index 0000000000..621ac58c7c
--- /dev/null
+++ b/package/boot/uboot-rockchip/patches/005-add-rock-pi-e-support-dts.patch
@@ -0,0 +1,325 @@
+diff --git a/arch/arm/dts/Makefile b/arch/arm/dts/Makefile
+index c6af87cf5e..61afe94a05 100644
+--- a/arch/arm/dts/Makefile
++++ b/arch/arm/dts/Makefile
+@@ -107,6 +107,7 @@ dtb-$(CONFIG_ROCKCHIP_RK3308) += \
+ dtb-$(CONFIG_ROCKCHIP_RK3328) += \
+ 	rk3328-evb.dtb \
+-	rk3328-rock64.dtb
++	rk3328-rock64.dtb \
++	rk3328-rock-pi-e.dtb
+ 
+ dtb-$(CONFIG_ROCKCHIP_RK3368) += \
+ 	rk3368-lion.dtb \
+diff --git a/arch/arm/dts/rk3328-rock-pi-e-u-boot.dtsi b/arch/arm/dts/rk3328-rock-pi-e-u-boot.dtsi
+new file mode 100644
+index 0000000000..bf5b1f3adc
+--- /dev/null
++++ b/arch/arm/dts/rk3328-rock-pi-e-u-boot.dtsi
+@@ -0,0 +1,33 @@
++// SPDX-License-Identifier: GPL-2.0+
++/*
++ * (C) Copyright 2020 Radxa
++ */
++
++#include "rk3328-u-boot.dtsi"
++#include "rk3328-sdram-ddr3-666.dtsi"
++
++&gpio0 {
++	u-boot,dm-spl;
++};
++
++&pinctrl {
++	u-boot,dm-spl;
++};
++
++&sdmmc0m1_gpio {
++	u-boot,dm-spl;
++};
++
++&pcfg_pull_up_4ma {
++	u-boot,dm-spl;
++};
++
++&usb_host0_xhci {
++	vbus-supply = <&vcc5v0_host_xhci>;
++	status = "okay";
++};
++
++/* Need this and all the pinctrl/gpio stuff above to set pinmux */
++&vcc_sd {
++	u-boot,dm-spl;
++};
+diff --git a/arch/arm/dts/rk3328-rock-pi-e.dts b/arch/arm/dts/rk3328-rock-pi-e.dts
+new file mode 100644
+index 0000000000..4b9f9a8248
+--- /dev/null
++++ b/arch/arm/dts/rk3328-rock-pi-e.dts
+@@ -0,0 +1,267 @@
++// SPDX-License-Identifier: GPL-2.0+
++/*
++ * (C) Copyright 2020 Radxa
++ */
++
++/dts-v1/;
++#include "rk3328.dtsi"
++
++/ {
++	model = "Radxa Rock Pi E";
++	compatible = "radxa,rock-pi-e", "rockchip,rk3328";
++
++	chosen {
++		stdout-path = "serial2:1500000n8";
++	};
++
++	gmac_clkin: external-gmac-clock {
++		compatible = "fixed-clock";
++		clock-frequency = <125000000>;
++		clock-output-names = "gmac_clkin";
++		#clock-cells = <0>;
++	};
++
++	vcc_sd: sdmmc-regulator {
++		compatible = "regulator-fixed";
++		gpio = <&gpio0 RK_PD6 GPIO_ACTIVE_LOW>;
++		pinctrl-names = "default";
++		pinctrl-0 = <&sdmmc0m1_gpio>;
++		regulator-name = "vcc_sd";
++		regulator-always-on;
++		regulator-boot-on;
++		regulator-min-microvolt = <3300000>;
++		regulator-max-microvolt = <3300000>;
++		vin-supply = <&vcc_io>;
++	};
++
++	vcc5v0_host_xhci: vcc5v0-host-xhci-drv {
++		compatible = "regulator-fixed";
++		enable-active-high;
++		regulator-name = "vcc5v0_host_xhci";
++		gpio = <&gpio3 RK_PA7 GPIO_ACTIVE_HIGH>;
++		regulator-min-microvolt = <5000000>;
++		regulator-max-microvolt = <5000000>;
++	};
++
++	vcc_sys: vcc-sys {
++		compatible = "regulator-fixed";
++		regulator-name = "vcc_sys";
++		regulator-always-on;
++		regulator-boot-on;
++		regulator-min-microvolt = <5000000>;
++		regulator-max-microvolt = <5000000>;
++	};
++};
++
++&cpu0 {
++	cpu-supply = <&vdd_arm>;
++};
++
++&cpu1 {
++	cpu-supply = <&vdd_arm>;
++};
++
++&cpu2 {
++	cpu-supply = <&vdd_arm>;
++};
++
++&cpu3 {
++	cpu-supply = <&vdd_arm>;
++};
++
++&emmc {
++	bus-width = <8>;
++	cap-mmc-highspeed;
++	mmc-hs200-1_8v;
++	supports-emmc;
++	disable-wp;
++	non-removable;
++	num-slots = <1>;
++	pinctrl-names = "default";
++	pinctrl-0 = <&emmc_clk &emmc_cmd &emmc_bus8>;
++	vmmc-supply = <&vcc_io>;
++	vqmmc-supply = <&vcc18_emmc>;
++	status = "okay";
++};
++
++&gmac2io {
++	assigned-clocks = <&cru SCLK_MAC2IO>, <&cru SCLK_MAC2IO_EXT>;
++	assigned-clock-parents = <&gmac_clkin>, <&gmac_clkin>;
++	clock_in_out = "input";
++	phy-supply = <&vcc_io>;
++	phy-mode = "rgmii";
++	pinctrl-names = "default";
++	pinctrl-0 = <&rgmiim1_pins>;
++	snps,force_thresh_dma_mode;
++	snps,reset-gpio = <&gpio1 RK_PC2 GPIO_ACTIVE_LOW>;
++	snps,reset-active-low;
++	snps,reset-delays-us = <0 10000 50000>;
++	tx_delay = <0x26>;
++	rx_delay = <0x11>;
++	status = "okay";
++};
++
++&i2c1 {
++	status = "okay";
++
++	rk805: rk805@18 {
++		compatible = "rockchip,rk805";
++		status = "okay";
++		reg = <0x18>;
++		interrupt-parent = <&gpio2>;
++		interrupts = <6 IRQ_TYPE_LEVEL_LOW>;
++		#clock-cells = <1>;
++		clock-output-names = "xin32k", "rk805-clkout2";
++		pinctrl-names = "default";
++		pinctrl-0 = <&pmic_int_l>;
++		rockchip,system-power-controller;
++		wakeup-source;
++
++		vcc1-supply = <&vcc_sys>;
++		vcc2-supply = <&vcc_sys>;
++		vcc3-supply = <&vcc_sys>;
++		vcc4-supply = <&vcc_sys>;
++		vcc5-supply = <&vcc_io>;
++		vcc6-supply = <&vcc_sys>;
++
++		regulators {
++			vdd_logic: DCDC_REG1 {
++				regulator-name = "vdd_logic";
++				regulator-min-microvolt = <712500>;
++				regulator-max-microvolt = <1450000>;
++				regulator-ramp-delay = <12500>;
++				regulator-always-on;
++				regulator-boot-on;
++				regulator-state-mem {
++					regulator-on-in-suspend;
++					regulator-suspend-microvolt = <1000000>;
++				};
++			};
++
++			vdd_arm: DCDC_REG2 {
++				regulator-name = "vdd_arm";
++				regulator-min-microvolt = <712500>;
++				regulator-max-microvolt = <1450000>;
++				regulator-ramp-delay = <12500>;
++				regulator-always-on;
++				regulator-boot-on;
++				regulator-state-mem {
++					regulator-on-in-suspend;
++					regulator-suspend-microvolt = <950000>;
++				};
++			};
++
++			vcc_ddr: DCDC_REG3 {
++				regulator-name = "vcc_ddr";
++				regulator-always-on;
++				regulator-boot-on;
++				regulator-state-mem {
++					regulator-on-in-suspend;
++				};
++			};
++
++			vcc_io: DCDC_REG4 {
++				regulator-name = "vcc_io";
++				regulator-min-microvolt = <3300000>;
++				regulator-max-microvolt = <3300000>;
++				regulator-always-on;
++				regulator-boot-on;
++				regulator-state-mem {
++					regulator-on-in-suspend;
++					regulator-suspend-microvolt = <3300000>;
++				};
++			};
++
++			vcc_18: LDO_REG1 {
++				regulator-name = "vcc_18";
++				regulator-min-microvolt = <1800000>;
++				regulator-max-microvolt = <1800000>;
++				regulator-always-on;
++				regulator-boot-on;
++				regulator-state-mem {
++					regulator-on-in-suspend;
++					regulator-suspend-microvolt = <1800000>;
++				};
++			};
++
++			vcc18_emmc: LDO_REG2 {
++				regulator-name = "vcc18_emmc";
++				regulator-min-microvolt = <1800000>;
++				regulator-max-microvolt = <1800000>;
++				regulator-always-on;
++				regulator-boot-on;
++				regulator-state-mem {
++					regulator-on-in-suspend;
++					regulator-suspend-microvolt = <1800000>;
++				};
++			};
++
++			vdd_10: LDO_REG3 {
++				regulator-name = "vdd_10";
++				regulator-min-microvolt = <1000000>;
++				regulator-max-microvolt = <1000000>;
++				regulator-always-on;
++				regulator-boot-on;
++				regulator-state-mem {
++					regulator-on-in-suspend;
++					regulator-suspend-microvolt = <1000000>;
++				};
++			};
++		};
++	};
++};
++
++&io_domains {
++	status = "okay";
++
++	vccio1-supply = <&vcc_io>;
++	vccio2-supply = <&vcc18_emmc>;
++	vccio3-supply = <&vcc_io>;
++	vccio4-supply = <&vcc_io>;
++	vccio5-supply = <&vcc_io>;
++	vccio6-supply = <&vcc_io>;
++	pmuio-supply = <&vcc_io>;
++};
++
++&pinctrl {
++	pmic {
++		pmic_int_l: pmic-int-l {
++			rockchip,pins = <2 RK_PA6 RK_FUNC_GPIO &pcfg_pull_up>;
++		};
++	};
++};
++
++&sdmmc {
++	bus-width = <4>;
++	cap-mmc-highspeed;
++	cap-sd-highspeed;
++	card-detect-delay = <200>;
++	disable-wp;
++	max-frequency = <150000000>;
++	num-slots = <1>;
++	pinctrl-names = "default";
++	pinctrl-0 = <&sdmmc0_clk &sdmmc0_cmd &sdmmc0_dectn &sdmmc0_bus4>;
++	supports-sd;
++	vmmc-supply = <&vcc_sd>;
++	status = "okay";
++};
++
++&saradc {
++	status = "okay";
++};
++
++&uart2 {
++	status = "okay";
++};
++
++&usb20_otg {
++	status = "okay";
++};
++
++&usb_host0_ehci {
++	status = "okay";
++};
++
++&usb_host0_ohci {
++	status = "okay";
++};
diff --git a/package/boot/uboot-rockchip/patches/006-add-rock-pi-e-defconfig.patch b/package/boot/uboot-rockchip/patches/006-add-rock-pi-e-defconfig.patch
new file mode 100644
index 0000000000..e9d99158ad
--- /dev/null
+++ b/package/boot/uboot-rockchip/patches/006-add-rock-pi-e-defconfig.patch
@@ -0,0 +1,110 @@
+diff --git a/configs/rock-pi-e-rk3328_defconfig b/configs/rock-pi-e-rk3328_defconfig
+new file mode 100644
+index 0000000000..759838775f
+--- /dev/null
++++ b/configs/rock-pi-e-rk3328_defconfig
+@@ -0,0 +1,104 @@
++CONFIG_ARM=y
++CONFIG_ARCH_ROCKCHIP=y
++CONFIG_SYS_TEXT_BASE=0x00200000
++CONFIG_SPL_GPIO_SUPPORT=y
++CONFIG_ENV_OFFSET=0x3F8000
++CONFIG_ROCKCHIP_RK3328=y
++CONFIG_TPL_ROCKCHIP_COMMON_BOARD=y
++CONFIG_TPL_LIBCOMMON_SUPPORT=y
++CONFIG_TPL_LIBGENERIC_SUPPORT=y
++CONFIG_SPL_DRIVERS_MISC_SUPPORT=y
++CONFIG_SPL_STACK_R_ADDR=0x4000000
++CONFIG_SPL_SYS_MALLOC_F_LEN=0x4000
++CONFIG_NR_DRAM_BANKS=1
++CONFIG_DEBUG_UART_BASE=0xFF130000
++CONFIG_DEBUG_UART_CLOCK=24000000
++CONFIG_SMBIOS_PRODUCT_NAME="rock-pi-e_rk3328"
++CONFIG_DEBUG_UART=y
++CONFIG_TPL_SYS_MALLOC_F_LEN=0x800
++# CONFIG_ANDROID_BOOT_IMAGE is not set
++CONFIG_FIT=y
++CONFIG_FIT_VERBOSE=y
++CONFIG_SPL_LOAD_FIT=y
++CONFIG_DEFAULT_FDT_FILE="rockchip/rk3328-rock-pi-e.dtb"
++CONFIG_MISC_INIT_R=y
++# CONFIG_DISPLAY_CPUINFO is not set
++CONFIG_DISPLAY_BOARDINFO_LATE=y
++# CONFIG_SPL_RAW_IMAGE_SUPPORT is not set
++CONFIG_TPL_SYS_MALLOC_SIMPLE=y
++CONFIG_SPL_STACK_R=y
++CONFIG_SPL_I2C_SUPPORT=y
++CONFIG_SPL_POWER_SUPPORT=y
++CONFIG_SPL_STACK_R_MALLOC_SIMPLE_LEN=0x10000
++CONFIG_SPL_ATF=y
++CONFIG_SPL_ATF_NO_PLATFORM_PARAM=y
++CONFIG_TPL_DRIVERS_MISC_SUPPORT=y
++CONFIG_CMD_BOOTZ=y
++CONFIG_CMD_GPT=y
++CONFIG_CMD_MMC=y
++CONFIG_CMD_USB=y
++CONFIG_CMD_TIME=y
++CONFIG_SPL_OF_CONTROL=y
++CONFIG_TPL_OF_CONTROL=y
++CONFIG_DEFAULT_DEVICE_TREE="rk3328-rock-pi-e"
++CONFIG_OF_SPL_REMOVE_PROPS="clock-names interrupt-parent assigned-clocks assigned-clock-rates assigned-clock-parents"
++CONFIG_TPL_OF_PLATDATA=y
++CONFIG_ENV_IS_IN_MMC=y
++CONFIG_SYS_RELOC_GD_ENV_ADDR=y
++CONFIG_NET_RANDOM_ETHADDR=y
++CONFIG_TPL_DM=y
++CONFIG_REGMAP=y
++CONFIG_SPL_REGMAP=y
++CONFIG_TPL_REGMAP=y
++CONFIG_SYSCON=y
++CONFIG_SPL_SYSCON=y
++CONFIG_TPL_SYSCON=y
++CONFIG_CLK=y
++CONFIG_SPL_CLK=y
++CONFIG_FASTBOOT_BUF_ADDR=0x800800
++CONFIG_FASTBOOT_CMD_OEM_FORMAT=y
++CONFIG_ROCKCHIP_GPIO=y
++CONFIG_SYS_I2C_ROCKCHIP=y
++CONFIG_MMC_DW=y
++CONFIG_MMC_DW_ROCKCHIP=y
++CONFIG_SF_DEFAULT_SPEED=20000000
++CONFIG_DM_ETH=y
++CONFIG_ETH_DESIGNWARE=y
++CONFIG_GMAC_ROCKCHIP=y
++CONFIG_PHY=y
++CONFIG_PINCTRL=y
++CONFIG_SPL_PINCTRL=y
++CONFIG_DM_PMIC=y
++CONFIG_PMIC_RK8XX=y
++CONFIG_SPL_DM_REGULATOR=y
++CONFIG_REGULATOR_PWM=y
++CONFIG_SPL_DM_REGULATOR_FIXED=y
++CONFIG_DM_REGULATOR_FIXED=y
++CONFIG_REGULATOR_RK8XX=y
++CONFIG_PWM_ROCKCHIP=y
++CONFIG_RAM=y
++CONFIG_SPL_RAM=y
++CONFIG_TPL_RAM=y
++CONFIG_DM_RESET=y
++CONFIG_BAUDRATE=1500000
++CONFIG_DEBUG_UART_SHIFT=2
++CONFIG_DEBUG_UART_ANNOUNCE=y
++CONFIG_DEBUG_UART_SKIP_INIT=y
++CONFIG_SYSRESET=y
++# CONFIG_TPL_SYSRESET is not set
++CONFIG_USB=y
++CONFIG_USB_XHCI_HCD=y
++CONFIG_USB_XHCI_DWC3=y
++CONFIG_USB_EHCI_HCD=y
++CONFIG_USB_EHCI_GENERIC=y
++CONFIG_USB_OHCI_HCD=y
++CONFIG_USB_OHCI_GENERIC=y
++CONFIG_USB_DWC2=y
++CONFIG_USB_DWC3=y
++# CONFIG_USB_DWC3_GADGET is not set
++CONFIG_USB_GADGET=y
++CONFIG_USB_GADGET_DWC2_OTG=y
++CONFIG_SPL_TINY_MEMSET=y
++CONFIG_TPL_TINY_MEMSET=y
++CONFIG_ERRNO_STR=y
++CONFIG_SMBIOS_MANUFACTURER="radxa"
diff --git a/package/boot/uboot-rockchip/patches/007-sdmmc-fifo-mode-in-spl.patch b/package/boot/uboot-rockchip/patches/007-sdmmc-fifo-mode-in-spl.patch
new file mode 100644
index 0000000000..9b7354f97e
--- /dev/null
+++ b/package/boot/uboot-rockchip/patches/007-sdmmc-fifo-mode-in-spl.patch
@@ -0,0 +1,22 @@
+From b0693aeb9ceab57ffc9d9f4ceca610bd82d5ca07 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Kamil=20Trzci=C5=84ski?= <ayufan@ayufan.eu>
+Date: Mon, 21 May 2018 02:00:19 +0200
+Subject: [PATCH] ayufan: rock64: for SPL build always use fifo-mode
+
+Change-Id: I9ac012ce4aaf03a151f7c5c818829d631efdd7ed
+diff --git a/drivers/mmc/rockchip_dw_mmc.c b/drivers/mmc/rockchip_dw_mmc.c
+index fc0f0fad76..d1f26e41fe 100644
+--- a/drivers/mmc/rockchip_dw_mmc.c
++++ b/drivers/mmc/rockchip_dw_mmc.c
+@@ -70,7 +70,11 @@ static int rockchip_dwmmc_ofdata_to_platdata(struct udevice *dev)
+ 
+ 	if (priv->fifo_depth < 0)
+ 		return -EINVAL;
++#ifdef CONFIG_SPL_BUILD
++	priv->fifo_mode = true; // always force fifo mode
++#else
+ 	priv->fifo_mode = dev_read_bool(dev, "fifo-mode");
++#endif
+ 
+ 	/*
+ 	 * 'clock-freq-min-max' is deprecated
diff --git a/package/boot/uboot-rockchip/patches/008-set-sdmmc-priority.patch b/package/boot/uboot-rockchip/patches/008-set-sdmmc-priority.patch
new file mode 100644
index 0000000000..b71d4a2119
--- /dev/null
+++ b/package/boot/uboot-rockchip/patches/008-set-sdmmc-priority.patch
@@ -0,0 +1,15 @@
+diff --git a/include/configs/rockchip-common.h b/include/configs/rockchip-common.h
+index 68e1105a..906c22ed 100644
+--- a/include/configs/rockchip-common.h
++++ b/include/configs/rockchip-common.h
+@@ -14,8 +14,8 @@
+ /* First try to boot from SD (index 0), then eMMC (index 1) */
+ #if CONFIG_IS_ENABLED(CMD_MMC)
+ 	#define BOOT_TARGET_MMC(func) \
+-		func(MMC, mmc, 0) \
+-		func(MMC, mmc, 1)
++		func(MMC, mmc, 1) \
++		func(MMC, mmc, 0)
+ #else
+ 	#define BOOT_TARGET_MMC(func)
+ #endif
diff --git a/target/linux/rockchip/armv8/base-files/etc/board.d/02_network b/target/linux/rockchip/armv8/base-files/etc/board.d/02_network
index c5adda1706..b436110f42 100755
--- a/target/linux/rockchip/armv8/base-files/etc/board.d/02_network
+++ b/target/linux/rockchip/armv8/base-files/etc/board.d/02_network
@@ -5,6 +5,9 @@
 board_config_update
 
 case "$(board_name)" in
+radxa,rock-pi-e)
+	ucidef_set_interfaces_lan_wan "eth1" "eth0"
+	;;
 *)
 	ucidef_set_interface_lan 'eth0'
 	;;
diff --git a/target/linux/rockchip/armv8/base-files/etc/inittab b/target/linux/rockchip/armv8/base-files/etc/inittab
new file mode 100644
index 0000000000..df47827128
--- /dev/null
+++ b/target/linux/rockchip/armv8/base-files/etc/inittab
@@ -0,0 +1,6 @@
+::sysinit:/etc/init.d/rcS S boot
+::shutdown:/etc/init.d/rcS K shutdown
+::askconsole:/usr/libexec/login.sh
+tts/0::askfirst:/usr/libexec/login.sh
+ttyS0::askfirst:/usr/libexec/login.sh
+tty1::askfirst:/usr/libexec/login.sh
diff --git a/target/linux/rockchip/armv8/config-5.4 b/target/linux/rockchip/armv8/config-5.4
index 48b05b432b..526ecd78b6 100644
--- a/target/linux/rockchip/armv8/config-5.4
+++ b/target/linux/rockchip/armv8/config-5.4
@@ -73,7 +73,7 @@ CONFIG_CMA_ALIGNMENT=8
 CONFIG_CMA_AREAS=7
 # CONFIG_CMA_DEBUG is not set
 # CONFIG_CMA_DEBUGFS is not set
-CONFIG_CMA_SIZE_MBYTES=5
+CONFIG_CMA_SIZE_MBYTES=16
 # CONFIG_CMA_SIZE_SEL_MAX is not set
 CONFIG_CMA_SIZE_SEL_MBYTES=y
 # CONFIG_CMA_SIZE_SEL_MIN is not set
@@ -101,6 +101,7 @@ CONFIG_CPU_FREQ_GOV_POWERSAVE=y
 CONFIG_CPU_FREQ_GOV_SCHEDUTIL=y
 # CONFIG_CPU_FREQ_GOV_USERSPACE is not set
 CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_HAS_PMU=y
 CONFIG_CPU_IDLE=y
 # CONFIG_CPU_IDLE_GOV_LADDER is not set
 CONFIG_CPU_IDLE_GOV_MENU=y
@@ -123,7 +124,7 @@ CONFIG_DEVFREQ_GOV_PERFORMANCE=y
 CONFIG_DEVFREQ_GOV_POWERSAVE=y
 CONFIG_DEVFREQ_GOV_SIMPLE_ONDEMAND=y
 CONFIG_DEVFREQ_GOV_USERSPACE=y
-# CONFIG_DEVFREQ_THERMAL is not set
+CONFIG_DEVFREQ_THERMAL=y
 CONFIG_DEVMEM=y
 # CONFIG_DEVPORT is not set
 CONFIG_DEVTMPFS=y
@@ -134,6 +135,10 @@ CONFIG_DMA_ENGINE=y
 CONFIG_DMA_OF=y
 CONFIG_DMA_SHARED_BUFFER=y
 CONFIG_DNOTIFY=y
+CONFIG_DRM=y
+# CONFIG_DRM_ROCKCHIP is not set
+# CONFIG_ROCKCHIP_ANALOGIX_DP is not set
+# CONFIG_ROCKCHIP_CDN_DP is not set
 CONFIG_DT_IDLE_STATES=y
 CONFIG_DUMMY_CONSOLE=y
 CONFIG_DWMAC_DWC_QOS_ETH=y
@@ -146,6 +151,7 @@ CONFIG_EXT4_FS=y
 CONFIG_EXT4_FS_POSIX_ACL=y
 CONFIG_EXTCON=y
 CONFIG_FANOTIFY=y
+CONFIG_FB=y
 CONFIG_FHANDLE=y
 CONFIG_FIXED_PHY=y
 # CONFIG_FLATMEM_MANUAL is not set
@@ -163,6 +169,9 @@ CONFIG_GPIOLIB=y
 CONFIG_GPIO_DWAPB=y
 CONFIG_GPIO_GENERIC=y
 CONFIG_GPIO_GENERIC_PLATFORM=y
+CONFIG_GPIO_RK8XX=y
+CONFIG_GPIO_SYSCON=y
+CONFIG_GPIO_SYSFS=y
 # CONFIG_HARDENED_USERCOPY is not set
 CONFIG_HAS_IOPORT_MAP=y
 CONFIG_HAVE_ARCH_MMAP_RND_COMPAT_BITS=y
@@ -182,15 +191,23 @@ CONFIG_HUGETLB_PAGE=y
 CONFIG_HWMON=y
 CONFIG_HWSPINLOCK=y
 CONFIG_HW_CONSOLE=y
+CONFIG_HW_PERF_EVENTS=y
 # CONFIG_HZ_PERIODIC is not set
 CONFIG_I2C=y
 CONFIG_I2C_ALGOBIT=y
 CONFIG_I2C_BOARDINFO=y
 CONFIG_I2C_CHARDEV=y
 CONFIG_I2C_COMPAT=y
+CONFIG_I2C_DESIGNWARE_CORE=y
+CONFIG_I2C_DESIGNWARE_PLATFORM=y
+# CONFIG_I2C_DESIGNWARE_SLAVE is not set
 CONFIG_I2C_GPIO=y
 CONFIG_I2C_HELPER_AUTO=y
+CONFIG_I2C_MUX=y
+CONFIG_I2C_MUX_PCA954x=y
 CONFIG_I2C_RK3X=y
+CONFIG_I2C_SLAVE=y
+# CONFIG_I2C_SLAVE_EEPROM is not set
 CONFIG_INDIRECT_PIO=y
 CONFIG_INPUT=y
 CONFIG_INPUT_EVDEV=y
@@ -198,7 +215,9 @@ CONFIG_INPUT_FF_MEMLESS=y
 CONFIG_INPUT_KEYBOARD=y
 CONFIG_INPUT_LEDS=y
 CONFIG_INPUT_MATRIXKMAP=y
-# CONFIG_INPUT_MISC is not set
+CONFIG_INPUT_MISC=y
+CONFIG_INPUT_RAVE_SP_PWRBUTTON=y
+CONFIG_INPUT_RK805_PWRKEY=y
 CONFIG_IOMMU_API=y
 # CONFIG_IOMMU_DEBUGFS is not set
 # CONFIG_IOMMU_DEFAULT_PASSTHROUGH is not set
@@ -212,6 +231,7 @@ CONFIG_IOMMU_SUPPORT=y
 # CONFIG_IONIC is not set
 # CONFIG_IO_STRICT_DEVMEM is not set
 CONFIG_IO_URING=y
+# CONFIG_IPMB_DEVICE_INTERFACE is not set
 CONFIG_IRQ_MSI_IOMMU=y
 CONFIG_IRQ_TIME_ACCOUNTING=y
 CONFIG_JBD2=y
@@ -223,11 +243,13 @@ CONFIG_KEXEC_FILE=y
 # CONFIG_KEXEC_SIG is not set
 CONFIG_KEYBOARD_GPIO=y
 CONFIG_KSM=y
+CONFIG_KVM=y
 # CONFIG_LEDS_BRIGHTNESS_HW_CHANGED is not set
 CONFIG_LEDS_GPIO=y
 CONFIG_LEDS_PWM=y
 CONFIG_LEDS_SYSCON=y
 CONFIG_LEDS_TRIGGER_CPU=y
+CONFIG_LEDS_TRIGGER_GPIO=y
 CONFIG_LEDS_TRIGGER_HEARTBEAT=y
 CONFIG_LEDS_TRIGGER_PANIC=y
 # CONFIG_LEDS_TRIGGER_TIMER is not set
@@ -248,6 +270,8 @@ CONFIG_MDIO_BUS_MUX_GPIO=y
 CONFIG_MDIO_BUS_MUX_MMIOREG=y
 CONFIG_MDIO_DEVICE=y
 CONFIG_MDIO_GPIO=y
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_MEDIA_CEC_RC=y
 CONFIG_MEMORY_ISOLATION=y
 CONFIG_MFD_CORE=y
 CONFIG_MFD_RK808=y
@@ -318,18 +342,23 @@ CONFIG_PCI_DOMAINS_GENERIC=y
 CONFIG_PCI_MSI=y
 CONFIG_PCI_MSI_IRQ_DOMAIN=y
 CONFIG_PCI_STUB=y
+CONFIG_PERF_EVENTS=y
 CONFIG_PGTABLE_LEVELS=4
 CONFIG_PHYLIB=y
 CONFIG_PHYLINK=y
-CONFIG_PHY_ROCKCHIP_DP=y
+# CONFIG_PHY_ROCKCHIP_DP is not set
 CONFIG_PHY_ROCKCHIP_EMMC=y
 # CONFIG_PHY_ROCKCHIP_INNO_HDMI is not set
 CONFIG_PHY_ROCKCHIP_INNO_USB2=y
+CONFIG_PHY_ROCKCHIP_INNO_USB3=y
+# CONFIG_ROCKCHIP_LVDS is not set
+# CONFIG_ROCKCHIP_RGB is not set
+# CONFIG_ROCKCHIP_RK3066_HDMI is not set
 CONFIG_PHY_ROCKCHIP_PCIE=y
 CONFIG_PHY_ROCKCHIP_TYPEC=y
 CONFIG_PHY_ROCKCHIP_USB=y
 CONFIG_PINCTRL=y
-# CONFIG_PINCTRL_RK805 is not set
+CONFIG_PINCTRL_RK805=y
 CONFIG_PINCTRL_ROCKCHIP=y
 # CONFIG_PINCTRL_SINGLE is not set
 CONFIG_PL330_DMA=y
@@ -343,6 +372,9 @@ CONFIG_PM_GENERIC_DOMAINS_OF=y
 CONFIG_PM_OPP=y
 CONFIG_POWER_AVS=y
 CONFIG_POWER_SUPPLY_HWMON=y
+CONFIG_PPS=y
+CONFIG_PPS_CLIENT_KTIMER=y
+CONFIG_PPS_CLIENT_GPIO=y
 CONFIG_PREEMPT=y
 CONFIG_PREEMPTION=y
 CONFIG_PREEMPT_COUNT=y
@@ -370,6 +402,7 @@ CONFIG_RCU_CPU_STALL_TIMEOUT=21
 # CONFIG_RCU_EXPERT is not set
 CONFIG_RCU_TRACE=y
 # CONFIG_READ_ONLY_THP_FOR_FS is not set
+CONFIG_REALTEK_PHY=y
 CONFIG_REGMAP=y
 CONFIG_REGMAP_I2C=y
 CONFIG_REGMAP_IRQ=y
@@ -388,7 +421,8 @@ CONFIG_ROCKCHIP_IOMMU=y
 CONFIG_ROCKCHIP_MBOX=y
 CONFIG_ROCKCHIP_PHY=y
 CONFIG_ROCKCHIP_PM_DOMAINS=y
-# CONFIG_ROCKCHIP_THERMAL is not set
+CONFIG_ROCKCHIP_SARADC=y
+CONFIG_ROCKCHIP_THERMAL=y
 CONFIG_ROCKCHIP_TIMER=y
 CONFIG_RSEQ=y
 CONFIG_RTC_CLASS=y
@@ -426,6 +460,11 @@ CONFIG_SERIO_LIBPS2=y
 CONFIG_SG_POOL=y
 CONFIG_SIMPLE_PM_BUS=y
 CONFIG_SLUB_DEBUG=y
+# CONFIG_SND_SOC_RK3288_HDMI_ANALOG is not set
+# CONFIG_SND_SOC_ROCKCHIP_MAX98090 is not set
+# CONFIG_SND_SOC_ROCKCHIP_RT5645 is not set
+# CONFIG_SND_SOC_ROCKCHIP_RT5651 is not set
+# CONFIG_SND_SOC_RK3399_GRU_SOUND is not set
 CONFIG_SPARSEMEM=y
 CONFIG_SPARSEMEM_EXTREME=y
 CONFIG_SPARSEMEM_MANUAL=y
@@ -483,7 +522,10 @@ CONFIG_TYPEC_TCPM=y
 CONFIG_UNINLINE_SPIN_UNLOCK=y
 CONFIG_USB=y
 CONFIG_USB_COMMON=y
+CONFIG_USB_DWC2=y
+CONFIG_USB_DWC2_DUAL_ROLE=y
 CONFIG_USB_DWC3=y
+CONFIG_USB_DWC3_DUAL_ROLE=y
 CONFIG_USB_DWC3_HOST=y
 CONFIG_USB_DWC3_OF_SIMPLE=y
 CONFIG_USB_EHCI_HCD=y
@@ -502,8 +544,14 @@ CONFIG_USB_ULPI_VIEWPORT=y
 CONFIG_USB_XHCI_HCD=y
 CONFIG_USB_XHCI_PLATFORM=y
 # CONFIG_USERIO is not set
+CONFIG_VIDEO_IR_I2C=y
 # CONFIG_VFIO is not set
+# CONFIG_VFIO_NOIOMMU is not set
+# CONFIG_VFIO_PCI is not set
+# CONFIG_VFIO_PLATFORM is not set
+# CONFIG_VFIO_MDEV is not set
 # CONFIG_VIRTIO_MENU is not set
+CONFIG_VIRTUALIZATION=y
 CONFIG_VM_EVENT_COUNTERS=y
 CONFIG_VT=y
 CONFIG_VT_CONSOLE=y
@@ -516,3 +564,21 @@ CONFIG_XZ_DEC_ARMTHUMB=y
 CONFIG_XZ_DEC_BCJ=y
 CONFIG_ZLIB_DEFLATE=y
 CONFIG_ZLIB_INFLATE=y
+CONFIG_ARM64_CRYPTO=y
+CONFIG_ARM_ROCKCHIP_CPUFREQ=y
+CONFIG_ARM_ROCKCHIP_DMC_DEVFREQ=y
+CONFIG_CRYPTO_AES_ARM64_CE_BLK=y
+CONFIG_CRYPTO_AES_ARM64_CE_CCM=y
+CONFIG_CRYPTO_ANSI_CPRNG=y
+CONFIG_CRYPTO_CMAC=y
+CONFIG_CRYPTO_ECB=y
+CONFIG_CRYPTO_GHASH_ARM64_CE=y
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_SHA1_ARM64_CE=y
+CONFIG_CRYPTO_SHA2_ARM64_CE=y
+CONFIG_CRYPTO_SHA512=y
+CONFIG_CRYPTO_TWOFISH=y
+CONFIG_CRYPTO_USER_API_HASH=y
+CONFIG_CRYPTO_USER_API_SKCIPHER=y
+CONFIG_REGULATOR_GPIO=y
\ No newline at end of file
diff --git a/target/linux/rockchip/image/Makefile b/target/linux/rockchip/image/Makefile
index 22854d9d02..143f3ab82d 100644
--- a/target/linux/rockchip/image/Makefile
+++ b/target/linux/rockchip/image/Makefile
@@ -24,10 +24,10 @@ endef
 
 define Build/boot-script
 	# Make an U-boot image and copy it to the boot partition
-	mkimage -A arm -O linux -T script -C none -a 0 -e 0 -d mmc.bootscript $@.boot/boot.scr
+	mkimage -A arm -O linux -T script -C lzma -a 0 -e 0 -d mmc.bootscript $@.boot/boot.scr
 endef
 
-define Build/pine64-img
+define Build/sdcard-img
 	# Creates the final SD/eMMC images, 
 	# combining boot partition, root partition as well as the u-boot bootloader
 
@@ -50,7 +50,7 @@ endef
 ### Devices ###
 define Device/Default
   PROFILES := Default
-  KERNEL := kernel-bin
+  KERNEL := kernel-bin | lzma
   IMAGES := sysupgrade.img.gz
   SUPPORTED_DEVICES := $(subst _,$(comma),$(1))
   DEVICE_DTS = rockchip/$$(SOC)-$(lastword $(subst _, ,$(1)))
diff --git a/target/linux/rockchip/image/armv8.mk b/target/linux/rockchip/image/armv8.mk
index 737c6e4f9a..865ad8d443 100644
--- a/target/linux/rockchip/image/armv8.mk
+++ b/target/linux/rockchip/image/armv8.mk
@@ -4,11 +4,21 @@
 # This is free software, licensed under the GNU General Public License v2.
 # See /LICENSE for more information.
 #
+define Device/radxa_rock-pi-e
+  DEVICE_VENDOR := Radxa
+  DEVICE_MODEL := Rock Pi E
+  SOC := rk3328
+  UBOOT_DEVICE_NAME := rock-pi-e-rk3328
+  IMAGE/sysupgrade.img.gz := boot-common | boot-script | sdcard-img | gzip | append-metadata
+  DEVICE_PACKAGES += kmod-phy-realtek
+endef
+TARGET_DEVICES += radxa_rock-pi-e
+
 define Device/pine64_rockpro64
   DEVICE_VENDOR := Pine64
   DEVICE_MODEL := RockPro64
   SOC := rk3399
   UBOOT_DEVICE_NAME := rockpro64-rk3399
-  IMAGE/sysupgrade.img.gz := boot-common | boot-script | pine64-img | gzip | append-metadata
+  IMAGE/sysupgrade.img.gz := boot-common | boot-script | sdcard-img | gzip | append-metadata
 endef
 TARGET_DEVICES += pine64_rockpro64
diff --git a/target/linux/rockchip/image/mmc.bootscript b/target/linux/rockchip/image/mmc.bootscript
index b70a62c4c7..13a55d3ac9 100644
--- a/target/linux/rockchip/image/mmc.bootscript
+++ b/target/linux/rockchip/image/mmc.bootscript
@@ -1,8 +1,18 @@
 part uuid mmc ${devnum}:2 uuid
 
-setenv bootargs "console=ttyS2,1500000 console=tty1 earlycon=uart8250,mmio32,0xff1a0000 root=PARTUUID=${uuid} rw rootwait"
+if test $stdout = 'serial@ff1a0000' ;
+then serial_addr=',0xff1a0000';
+elif test $stdout = 'serial@ff130000' ;
+then serial_addr=',0xff130000';
+fi;
+
+setenv bootargs "console=ttyS2,1500000 console=tty1 earlycon=uart8250,mmio32${serial_addr} swiotlb=1 root=PARTUUID=${uuid} rw rootwait loglevel=9";
 
 load mmc ${devnum}:1 ${fdt_addr_r} rockchip.dtb
 load mmc ${devnum}:1 ${kernel_addr_r} kernel.img
 
-booti ${kernel_addr_r} - ${fdt_addr_r}
+echo "Uncompress lzma kernel into memmory.."
+setexpr kernel_addr_dec ${filesize} + ${kernel_addr_r} || kernel_addr_dec=0x03000000
+lzmadec ${kernel_addr_r} ${kernel_addr_dec}
+
+booti ${kernel_addr_dec} - ${fdt_addr_r}
diff --git a/target/linux/rockchip/patches-5.4/001-rk3328_fix_wrong_mmc_shift.patch b/target/linux/rockchip/patches-5.4/001-rk3328_fix_wrong_mmc_shift.patch
new file mode 100644
index 0000000000..de7a866710
--- /dev/null
+++ b/target/linux/rockchip/patches-5.4/001-rk3328_fix_wrong_mmc_shift.patch
@@ -0,0 +1,48 @@
+From 6376a1b0e30a1d30c4269083fb5b9a146a944ada Mon Sep 17 00:00:00 2001
+From: Ziyuan Xu <xzy.xu@rock-chips.com>
+Date: Wed, 28 Nov 2018 17:39:50 +0800
+Subject: [PATCH] Revert "clk: rockchip: fix wrong mmc phase shift for rk3328"
+
+This reverts commit 4ef244988993afc8a6447e990a4ccb4a223d3f20.
+
+The description for CRU_EMMC/SDMMC/SDIO_CON[0/1] is jumble on
+chapters, make it clear that the correct shift is 1 that from
+IC engineer.
+
+Change-Id: I48dce293ec6ef82a5c78db38efc083227776ea99
+Signed-off-by: Ziyuan Xu <xzy.xu@rock-chips.com>
+---
+ drivers/clk/rockchip/clk-rk3328.c | 8 ++++----
+ 1 file changed, 4 insertions(+), 4 deletions(-)
+
+diff --git a/drivers/clk/rockchip/clk-rk3328.c b/drivers/clk/rockchip/clk-rk3328.c
+index ac6e6163a232..d77925271198 100644
+--- a/drivers/clk/rockchip/clk-rk3328.c
++++ b/drivers/clk/rockchip/clk-rk3328.c
+@@ -808,22 +808,22 @@ static struct rockchip_clk_branch rk3328_clk_branches[] __initdata = {
+ 	MMC(SCLK_SDMMC_DRV, "sdmmc_drv", "clk_sdmmc",
+ 	    RK3328_SDMMC_CON0, 1),
+ 	MMC(SCLK_SDMMC_SAMPLE, "sdmmc_sample", "clk_sdmmc",
+-	    RK3328_SDMMC_CON1, 0),
++	    RK3328_SDMMC_CON1, 1),
+ 
+ 	MMC(SCLK_SDIO_DRV, "sdio_drv", "clk_sdio",
+ 	    RK3328_SDIO_CON0, 1),
+ 	MMC(SCLK_SDIO_SAMPLE, "sdio_sample", "clk_sdio",
+-	    RK3328_SDIO_CON1, 0),
++	    RK3328_SDIO_CON1, 1),
+ 
+ 	MMC(SCLK_EMMC_DRV, "emmc_drv", "clk_emmc",
+ 	    RK3328_EMMC_CON0, 1),
+ 	MMC(SCLK_EMMC_SAMPLE, "emmc_sample", "clk_emmc",
+-	    RK3328_EMMC_CON1, 0),
++	    RK3328_EMMC_CON1, 1),
+ 
+ 	MMC(SCLK_SDMMC_EXT_DRV, "sdmmc_ext_drv", "clk_sdmmc_ext",
+ 	    RK3328_SDMMC_EXT_CON0, 1),
+ 	MMC(SCLK_SDMMC_EXT_SAMPLE, "sdmmc_ext_sample", "clk_sdmmc_ext",
+-	    RK3328_SDMMC_EXT_CON1, 0),
++	    RK3328_SDMMC_EXT_CON1, 1),
+ };
+ 
+ static const char *const rk3328_critical_clocks[] __initconst = {
diff --git a/target/linux/rockchip/patches-5.4/002-add-rk3328-usb3-driver.patch b/target/linux/rockchip/patches-5.4/002-add-rk3328-usb3-driver.patch
new file mode 100644
index 0000000000..6a15af240f
--- /dev/null
+++ b/target/linux/rockchip/patches-5.4/002-add-rk3328-usb3-driver.patch
@@ -0,0 +1,1424 @@
+Add the rockchip innosilicon usb3 phy driver, supporting devices such as the rk3328.
+Pulled from:
+https://github.com/FireflyTeam/kernel/blob/roc-rk3328-cc/drivers/phy/rockchip/phy-rockchip-inno-usb3.c
+
+Signed-off-by: Peter Geis <pgwipeout@gmail.com>
+---
+ drivers/phy/rockchip/Kconfig                  |    9 +
+ drivers/phy/rockchip/Makefile                 |    1 +
+ drivers/phy/rockchip/phy-rockchip-inno-usb3.c | 1107 +++++++++++++++++
+ 3 files changed, 1117 insertions(+)
+ create mode 100644 drivers/phy/rockchip/phy-rockchip-inno-usb3.c
+
+diff --git a/drivers/phy/rockchip/Kconfig b/drivers/phy/rockchip/Kconfig
+index c454c90cd99e..766407939d4a 100644
+--- a/drivers/phy/rockchip/Kconfig
++++ b/drivers/phy/rockchip/Kconfig
+@@ -35,6 +35,15 @@ config PHY_ROCKCHIP_INNO_USB2
+ 	help
+ 	  Support for Rockchip USB2.0 PHY with Innosilicon IP block.
+ 
++config PHY_ROCKCHIP_INNO_USB3
++	tristate "Rockchip INNO USB 3.0 PHY Driver"
++	depends on (ARCH_ROCKCHIP || COMPILE_TEST) && OF
++	depends on USB_SUPPORT
++	select GENERIC_PHY
++	select USB_PHY
++	help
++	  Support for Rockchip USB 3.0 PHY with Innosilicon IP block.
++
+ config PHY_ROCKCHIP_PCIE
+ 	tristate "Rockchip PCIe PHY Driver"
+ 	depends on (ARCH_ROCKCHIP && OF) || COMPILE_TEST
+diff --git a/drivers/phy/rockchip/Makefile b/drivers/phy/rockchip/Makefile
+index fd21cbaf40dd..d7b3d16c19ae 100644
+--- a/drivers/phy/rockchip/Makefile
++++ b/drivers/phy/rockchip/Makefile
+@@ -3,6 +3,7 @@ obj-$(CONFIG_PHY_ROCKCHIP_DP)		+= phy-rockchip-dp.o
+ obj-$(CONFIG_PHY_ROCKCHIP_EMMC)		+= phy-rockchip-emmc.o
+ obj-$(CONFIG_PHY_ROCKCHIP_INNO_HDMI)	+= phy-rockchip-inno-hdmi.o
+ obj-$(CONFIG_PHY_ROCKCHIP_INNO_USB2)	+= phy-rockchip-inno-usb2.o
++obj-$(CONFIG_PHY_ROCKCHIP_INNO_USB3)	+= phy-rockchip-inno-usb3.o
+ obj-$(CONFIG_PHY_ROCKCHIP_PCIE)		+= phy-rockchip-pcie.o
+ obj-$(CONFIG_PHY_ROCKCHIP_TYPEC)	+= phy-rockchip-typec.o
+ obj-$(CONFIG_PHY_ROCKCHIP_USB)		+= phy-rockchip-usb.o
+diff --git a/drivers/phy/rockchip/phy-rockchip-inno-usb3.c b/drivers/phy/rockchip/phy-rockchip-inno-usb3.c
+new file mode 100644
+index 000000000000..31fee8f3a705
+--- /dev/null
++++ b/drivers/phy/rockchip/phy-rockchip-inno-usb3.c
+@@ -0,0 +1,1107 @@
++// SPDX-License-Identifier: GPL-2.0-or-later
++/*
++ * Rockchip USB 3.0 PHY with Innosilicon IP block driver
++ *
++ * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd
++ */
++
++#include <linux/clk.h>
++#include <linux/delay.h>
++#include <linux/debugfs.h>
++#include <linux/gpio/consumer.h>
++#include <linux/interrupt.h>
++#include <linux/io.h>
++#include <linux/kernel.h>
++#include <linux/mfd/syscon.h>
++#include <linux/module.h>
++#include <linux/of.h>
++#include <linux/of_address.h>
++#include <linux/of_clk.h>
++#include <linux/of_irq.h>
++#include <linux/of_platform.h>
++#include <linux/phy/phy.h>
++#include <linux/platform_device.h>
++#include <linux/regmap.h>
++#include <linux/reset.h>
++#include <linux/usb/phy.h>
++#include <linux/uaccess.h>
++
++#define U3PHY_PORT_NUM	2
++#define BIT_WRITEABLE_SHIFT	16
++#define SCHEDULE_DELAY	(60 * HZ)
++
++#define U3PHY_APB_RST	BIT(0)
++#define U3PHY_POR_RST	BIT(1)
++#define U3PHY_MAC_RST	BIT(2)
++
++struct rockchip_u3phy;
++struct rockchip_u3phy_port;
++
++enum rockchip_u3phy_type {
++	U3PHY_TYPE_PIPE,
++	U3PHY_TYPE_UTMI,
++};
++
++enum rockchip_u3phy_pipe_pwr {
++	PIPE_PWR_P0	= 0,
++	PIPE_PWR_P1	= 1,
++	PIPE_PWR_P2	= 2,
++	PIPE_PWR_P3	= 3,
++	PIPE_PWR_MAX	= 4,
++};
++
++enum rockchip_u3phy_rest_req {
++	U3_POR_RSTN	= 0,
++	U2_POR_RSTN	= 1,
++	PIPE_MAC_RSTN	= 2,
++	UTMI_MAC_RSTN	= 3,
++	PIPE_APB_RSTN	= 4,
++	UTMI_APB_RSTN	= 5,
++	U3PHY_RESET_MAX	= 6,
++};
++
++enum rockchip_u3phy_utmi_state {
++	PHY_UTMI_HS_ONLINE	= 0,
++	PHY_UTMI_DISCONNECT	= 1,
++	PHY_UTMI_CONNECT	= 2,
++	PHY_UTMI_FS_LS_ONLINE	= 4,
++};
++
++/*
++ * @rvalue: reset value
++ * @dvalue: desired value
++ */
++struct u3phy_reg {
++	unsigned int	offset;
++	unsigned int	bitend;
++	unsigned int	bitstart;
++	unsigned int	rvalue;
++	unsigned int	dvalue;
++};
++
++struct rockchip_u3phy_grfcfg {
++	struct u3phy_reg	um_suspend;
++	struct u3phy_reg	ls_det_en;
++	struct u3phy_reg	ls_det_st;
++	struct u3phy_reg	um_ls;
++	struct u3phy_reg	um_hstdct;
++	struct u3phy_reg	u2_only_ctrl;
++	struct u3phy_reg	u3_disable;
++	struct u3phy_reg	pp_pwr_st;
++	struct u3phy_reg	pp_pwr_en[PIPE_PWR_MAX];
++};
++
++/**
++ * struct rockchip_u3phy_apbcfg: usb3-phy apb configuration.
++ * @u2_pre_emp: usb2-phy pre-emphasis tuning.
++ * @u2_pre_emp_sth: usb2-phy pre-emphasis strength tuning.
++ * @u2_odt_tuning: usb2-phy odt 45ohm tuning.
++ */
++struct rockchip_u3phy_apbcfg {
++	unsigned int	u2_pre_emp;
++	unsigned int	u2_pre_emp_sth;
++	unsigned int	u2_odt_tuning;
++};
++
++struct rockchip_u3phy_cfg {
++	unsigned int reg;
++	const struct rockchip_u3phy_grfcfg grfcfg;
++
++	int (*phy_pipe_power)(struct rockchip_u3phy *u3phy,
++			      struct rockchip_u3phy_port *u3phy_port,
++			      bool on);
++	int (*phy_tuning)(struct rockchip_u3phy *u3phy,
++			  struct rockchip_u3phy_port *u3phy_port,
++			  struct device_node *child_np);
++};
++
++struct rockchip_u3phy_port {
++	struct phy	*phy;
++	void __iomem	*base;
++	unsigned int	index;
++	unsigned char	type;
++	bool		suspended;
++	bool		refclk_25m_quirk;
++	struct mutex	mutex; /* mutex for updating register */
++	struct delayed_work	um_sm_work;
++};
++
++struct rockchip_u3phy {
++	struct device *dev;
++	struct regmap *u3phy_grf;
++	struct regmap *grf;
++	int um_ls_irq;
++	struct clk **clks;
++	int num_clocks;
++	struct dentry *root;
++	struct gpio_desc *vbus_drv_gpio;
++	struct reset_control *rsts[U3PHY_RESET_MAX];
++	struct rockchip_u3phy_apbcfg apbcfg;
++	const struct rockchip_u3phy_cfg *cfgs;
++	struct rockchip_u3phy_port ports[U3PHY_PORT_NUM];
++	struct usb_phy usb_phy;
++};
++
++static inline int param_write(void __iomem *base,
++			      const struct u3phy_reg *reg, bool desired)
++{
++	unsigned int val, mask;
++	unsigned int tmp = desired ? reg->dvalue : reg->rvalue;
++	int ret = 0;
++
++	mask = GENMASK(reg->bitend, reg->bitstart);
++	val = (tmp << reg->bitstart) | (mask << BIT_WRITEABLE_SHIFT);
++	ret = regmap_write(base, reg->offset, val);
++
++	return ret;
++}
++
++static inline bool param_exped(void __iomem *base,
++			       const struct u3phy_reg *reg,
++			       unsigned int value)
++{
++	int ret;
++	unsigned int tmp, orig;
++	unsigned int mask = GENMASK(reg->bitend, reg->bitstart);
++
++	ret = regmap_read(base, reg->offset, &orig);
++	if (ret)
++		return false;
++
++	tmp = (orig & mask) >> reg->bitstart;
++	return tmp == value;
++}
++
++static int rockchip_u3phy_usb2_only_show(struct seq_file *s, void *unused)
++{
++	struct rockchip_u3phy	*u3phy = s->private;
++
++	if (param_exped(u3phy->u3phy_grf, &u3phy->cfgs->grfcfg.u2_only_ctrl, 1))
++		dev_info(u3phy->dev, "u2\n");
++	else
++		dev_info(u3phy->dev, "u3\n");
++
++	return 0;
++}
++
++static int rockchip_u3phy_usb2_only_open(struct inode *inode,
++					 struct file *file)
++{
++	return single_open(file, rockchip_u3phy_usb2_only_show,
++			   inode->i_private);
++}
++
++static ssize_t rockchip_u3phy_usb2_only_write(struct file *file,
++					      const char __user *ubuf,
++					      size_t count, loff_t *ppos)
++{
++	struct seq_file			*s = file->private_data;
++	struct rockchip_u3phy		*u3phy = s->private;
++	struct rockchip_u3phy_port	*u3phy_port;
++	char				buf[32];
++	u8				index;
++
++	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
++		return -EFAULT;
++
++	if (!strncmp(buf, "u3", 2) &&
++	    param_exped(u3phy->u3phy_grf,
++			&u3phy->cfgs->grfcfg.u2_only_ctrl, 1)) {
++		dev_info(u3phy->dev, "Set usb3.0 and usb2.0 mode successfully\n");
++
++		gpiod_set_value_cansleep(u3phy->vbus_drv_gpio, 0);
++
++		param_write(u3phy->grf,
++			    &u3phy->cfgs->grfcfg.u3_disable, false);
++		param_write(u3phy->u3phy_grf,
++			    &u3phy->cfgs->grfcfg.u2_only_ctrl, false);
++
++		for (index = 0; index < U3PHY_PORT_NUM; index++) {
++			u3phy_port = &u3phy->ports[index];
++			/* enable u3 rx termimation */
++			if (u3phy_port->type == U3PHY_TYPE_PIPE)
++				writel(0x30, u3phy_port->base + 0xd8);
++		}
++
++		atomic_notifier_call_chain(&u3phy->usb_phy.notifier, 0, NULL);
++
++		gpiod_set_value_cansleep(u3phy->vbus_drv_gpio, 1);
++	} else if (!strncmp(buf, "u2", 2) &&
++		   param_exped(u3phy->u3phy_grf,
++			       &u3phy->cfgs->grfcfg.u2_only_ctrl, 0)) {
++		dev_info(u3phy->dev, "Set usb2.0 only mode successfully\n");
++
++		gpiod_set_value_cansleep(u3phy->vbus_drv_gpio, 0);
++
++		param_write(u3phy->grf,
++			    &u3phy->cfgs->grfcfg.u3_disable, true);
++		param_write(u3phy->u3phy_grf,
++			    &u3phy->cfgs->grfcfg.u2_only_ctrl, true);
++
++		for (index = 0; index < U3PHY_PORT_NUM; index++) {
++			u3phy_port = &u3phy->ports[index];
++			/* disable u3 rx termimation */
++			if (u3phy_port->type == U3PHY_TYPE_PIPE)
++				writel(0x20, u3phy_port->base + 0xd8);
++		}
++
++		atomic_notifier_call_chain(&u3phy->usb_phy.notifier, 0, NULL);
++
++		gpiod_set_value_cansleep(u3phy->vbus_drv_gpio, 1);
++	} else {
++		dev_info(u3phy->dev, "Same or illegal mode\n");
++	}
++
++	return count;
++}
++
++static const struct file_operations rockchip_u3phy_usb2_only_fops = {
++	.open			= rockchip_u3phy_usb2_only_open,
++	.write			= rockchip_u3phy_usb2_only_write,
++	.read			= seq_read,
++	.llseek			= seq_lseek,
++	.release		= single_release,
++};
++
++int rockchip_u3phy_debugfs_init(struct rockchip_u3phy *u3phy)
++{
++	struct dentry		*root;
++	struct dentry		*file;
++	int			ret;
++
++	root = debugfs_create_dir(dev_name(u3phy->dev), NULL);
++	if (!root) {
++		ret = -ENOMEM;
++		goto err0;
++	}
++
++	u3phy->root = root;
++
++	file = debugfs_create_file("u3phy_mode", 0644, root,
++				   u3phy, &rockchip_u3phy_usb2_only_fops);
++	if (!file) {
++		ret = -ENOMEM;
++		goto err1;
++	}
++	return 0;
++
++err1:
++	debugfs_remove_recursive(root);
++err0:
++	return ret;
++}
++
++static const char *get_rest_name(enum rockchip_u3phy_rest_req rst)
++{
++	switch (rst) {
++	case U2_POR_RSTN:
++		return "u3phy-u2-por";
++	case U3_POR_RSTN:
++		return "u3phy-u3-por";
++	case PIPE_MAC_RSTN:
++		return "u3phy-pipe-mac";
++	case UTMI_MAC_RSTN:
++		return "u3phy-utmi-mac";
++	case UTMI_APB_RSTN:
++		return "u3phy-utmi-apb";
++	case PIPE_APB_RSTN:
++		return "u3phy-pipe-apb";
++	default:
++		return "invalid";
++	}
++}
++
++static void rockchip_u3phy_rest_deassert(struct rockchip_u3phy *u3phy,
++					 unsigned int flag)
++{
++	int rst;
++
++	if (flag & U3PHY_APB_RST) {
++		dev_dbg(u3phy->dev, "deassert APB bus interface reset\n");
++		for (rst = PIPE_APB_RSTN; rst <= UTMI_APB_RSTN; rst++) {
++			if (u3phy->rsts[rst])
++				reset_control_deassert(u3phy->rsts[rst]);
++		}
++	}
++
++	if (flag & U3PHY_POR_RST) {
++		usleep_range(12, 15);
++		dev_dbg(u3phy->dev, "deassert u2 and u3 phy power on reset\n");
++		for (rst = U3_POR_RSTN; rst <= U2_POR_RSTN; rst++) {
++			if (u3phy->rsts[rst])
++				reset_control_deassert(u3phy->rsts[rst]);
++		}
++	}
++
++	if (flag & U3PHY_MAC_RST) {
++		usleep_range(1200, 1500);
++		dev_dbg(u3phy->dev, "deassert pipe and utmi MAC reset\n");
++		for (rst = PIPE_MAC_RSTN; rst <= UTMI_MAC_RSTN; rst++)
++			if (u3phy->rsts[rst])
++				reset_control_deassert(u3phy->rsts[rst]);
++	}
++}
++
++static void rockchip_u3phy_rest_assert(struct rockchip_u3phy *u3phy)
++{
++	int rst;
++
++	dev_dbg(u3phy->dev, "assert u3phy reset\n");
++	for (rst = 0; rst < U3PHY_RESET_MAX; rst++)
++		if (u3phy->rsts[rst])
++			reset_control_assert(u3phy->rsts[rst]);
++}
++
++static int rockchip_u3phy_clk_enable(struct rockchip_u3phy *u3phy)
++{
++	int ret, clk;
++
++	for (clk = 0; clk < u3phy->num_clocks && u3phy->clks[clk]; clk++) {
++		ret = clk_prepare_enable(u3phy->clks[clk]);
++		if (ret)
++			goto err_disable_clks;
++	}
++	return 0;
++
++err_disable_clks:
++	while (--clk >= 0)
++		clk_disable_unprepare(u3phy->clks[clk]);
++	return ret;
++}
++
++static void rockchip_u3phy_clk_disable(struct rockchip_u3phy *u3phy)
++{
++	int clk;
++
++	for (clk = u3phy->num_clocks - 1; clk >= 0; clk--)
++		if (u3phy->clks[clk])
++			clk_disable_unprepare(u3phy->clks[clk]);
++}
++
++static int rockchip_u3phy_init(struct phy *phy)
++{
++	return 0;
++}
++
++static int rockchip_u3phy_exit(struct phy *phy)
++{
++	return 0;
++}
++
++static int rockchip_u3phy_power_on(struct phy *phy)
++{
++	struct rockchip_u3phy_port *u3phy_port = phy_get_drvdata(phy);
++	struct rockchip_u3phy *u3phy = dev_get_drvdata(phy->dev.parent);
++	int ret;
++
++	dev_info(&u3phy_port->phy->dev, "u3phy %s power on\n",
++		 (u3phy_port->type == U3PHY_TYPE_UTMI) ? "u2" : "u3");
++
++	if (!u3phy_port->suspended)
++		return 0;
++
++	ret = rockchip_u3phy_clk_enable(u3phy);
++	if (ret)
++		return ret;
++
++	if (u3phy_port->type == U3PHY_TYPE_UTMI) {
++		param_write(u3phy->u3phy_grf,
++			    &u3phy->cfgs->grfcfg.um_suspend, false);
++	} else {
++		/* current in p2 ? */
++		if (param_exped(u3phy->u3phy_grf,
++				&u3phy->cfgs->grfcfg.pp_pwr_st, PIPE_PWR_P2))
++			goto done;
++
++		if (u3phy->cfgs->phy_pipe_power) {
++			dev_dbg(u3phy->dev, "do pipe power up\n");
++			u3phy->cfgs->phy_pipe_power(u3phy, u3phy_port, true);
++		}
++
++		/* exit to p0 */
++		param_write(u3phy->u3phy_grf,
++			    &u3phy->cfgs->grfcfg.pp_pwr_en[PIPE_PWR_P0], true);
++		usleep_range(90, 100);
++
++		/* enter to p2 from p0 */
++		param_write(u3phy->u3phy_grf,
++			    &u3phy->cfgs->grfcfg.pp_pwr_en[PIPE_PWR_P2],
++			    false);
++		udelay(3);
++	}
++
++done:
++	u3phy_port->suspended = false;
++	return 0;
++}
++
++static int rockchip_u3phy_power_off(struct phy *phy)
++{
++	struct rockchip_u3phy_port *u3phy_port = phy_get_drvdata(phy);
++	struct rockchip_u3phy *u3phy = dev_get_drvdata(phy->dev.parent);
++
++	dev_info(&u3phy_port->phy->dev, "u3phy %s power off\n",
++		 (u3phy_port->type == U3PHY_TYPE_UTMI) ? "u2" : "u3");
++
++	if (u3phy_port->suspended)
++		return 0;
++
++	if (u3phy_port->type == U3PHY_TYPE_UTMI) {
++		param_write(u3phy->u3phy_grf,
++			    &u3phy->cfgs->grfcfg.um_suspend, true);
++	} else {
++		/* current in p3 ? */
++		if (param_exped(u3phy->u3phy_grf,
++				&u3phy->cfgs->grfcfg.pp_pwr_st, PIPE_PWR_P3))
++			goto done;
++
++		/* exit to p0 */
++		param_write(u3phy->u3phy_grf,
++			    &u3phy->cfgs->grfcfg.pp_pwr_en[PIPE_PWR_P0], true);
++		udelay(2);
++
++		/* enter to p3 from p0 */
++		param_write(u3phy->u3phy_grf,
++			    &u3phy->cfgs->grfcfg.pp_pwr_en[PIPE_PWR_P3], true);
++		udelay(6);
++
++		if (u3phy->cfgs->phy_pipe_power) {
++			dev_dbg(u3phy->dev, "do pipe power down\n");
++			u3phy->cfgs->phy_pipe_power(u3phy, u3phy_port, false);
++		}
++	}
++
++done:
++	rockchip_u3phy_clk_disable(u3phy);
++	u3phy_port->suspended = true;
++	return 0;
++}
++
++static __maybe_unused
++struct phy *rockchip_u3phy_xlate(struct device *dev,
++				 struct of_phandle_args *args)
++{
++	struct rockchip_u3phy *u3phy = dev_get_drvdata(dev);
++	struct rockchip_u3phy_port *u3phy_port = NULL;
++	struct device_node *phy_np = args->np;
++	int index;
++
++	if (args->args_count != 1) {
++		dev_err(dev, "invalid number of cells in 'phy' property\n");
++		return ERR_PTR(-EINVAL);
++	}
++
++	for (index = 0; index < U3PHY_PORT_NUM; index++) {
++		if (phy_np == u3phy->ports[index].phy->dev.of_node) {
++			u3phy_port = &u3phy->ports[index];
++			break;
++		}
++	}
++
++	if (!u3phy_port) {
++		dev_err(dev, "failed to find appropriate phy\n");
++		return ERR_PTR(-EINVAL);
++	}
++
++	return u3phy_port->phy;
++}
++
++static struct phy_ops rockchip_u3phy_ops = {
++	.init		= rockchip_u3phy_init,
++	.exit		= rockchip_u3phy_exit,
++	.power_on	= rockchip_u3phy_power_on,
++	.power_off	= rockchip_u3phy_power_off,
++	.owner		= THIS_MODULE,
++};
++
++/*
++ * The function manage host-phy port state and suspend/resume phy port
++ * to save power automatically.
++ *
++ * we rely on utmi_linestate and utmi_hostdisconnect to identify whether
++ * devices is disconnect or not. Besides, we do not need care it is FS/LS
++ * disconnected or HS disconnected, actually, we just only need get the
++ * device is disconnected at last through rearm the delayed work,
++ * to suspend the phy port in _PHY_STATE_DISCONNECT_ case.
++ */
++static void rockchip_u3phy_um_sm_work(struct work_struct *work)
++{
++	struct rockchip_u3phy_port *u3phy_port =
++		container_of(work, struct rockchip_u3phy_port, um_sm_work.work);
++	struct rockchip_u3phy *u3phy =
++		dev_get_drvdata(u3phy_port->phy->dev.parent);
++	unsigned int sh = u3phy->cfgs->grfcfg.um_hstdct.bitend -
++			u3phy->cfgs->grfcfg.um_hstdct.bitstart + 1;
++	unsigned int ul, uhd, state;
++	unsigned int ul_mask, uhd_mask;
++	int ret;
++
++	mutex_lock(&u3phy_port->mutex);
++
++	ret = regmap_read(u3phy->u3phy_grf,
++			  u3phy->cfgs->grfcfg.um_ls.offset, &ul);
++	if (ret < 0)
++		goto next_schedule;
++
++	ret = regmap_read(u3phy->u3phy_grf,
++			  u3phy->cfgs->grfcfg.um_hstdct.offset, &uhd);
++	if (ret < 0)
++		goto next_schedule;
++
++	uhd_mask = GENMASK(u3phy->cfgs->grfcfg.um_hstdct.bitend,
++			   u3phy->cfgs->grfcfg.um_hstdct.bitstart);
++	ul_mask = GENMASK(u3phy->cfgs->grfcfg.um_ls.bitend,
++			  u3phy->cfgs->grfcfg.um_ls.bitstart);
++
++	/* stitch on um_ls and um_hstdct as phy state */
++	state = ((uhd & uhd_mask) >> u3phy->cfgs->grfcfg.um_hstdct.bitstart) |
++		(((ul & ul_mask) >> u3phy->cfgs->grfcfg.um_ls.bitstart) << sh);
++
++	switch (state) {
++	case PHY_UTMI_HS_ONLINE:
++		dev_dbg(&u3phy_port->phy->dev, "HS online\n");
++		break;
++	case PHY_UTMI_FS_LS_ONLINE:
++		/*
++		 * For FS/LS device, the online state share with connect state
++		 * from um_ls and um_hstdct register, so we distinguish
++		 * them via suspended flag.
++		 *
++		 * Plus, there are two cases, one is D- Line pull-up, and D+
++		 * line pull-down, the state is 4; another is D+ line pull-up,
++		 * and D- line pull-down, the state is 2.
++		 */
++		if (!u3phy_port->suspended) {
++			/* D- line pull-up, D+ line pull-down */
++			dev_dbg(&u3phy_port->phy->dev, "FS/LS online\n");
++			break;
++		}
++		/* fall through */
++	case PHY_UTMI_CONNECT:
++		if (u3phy_port->suspended) {
++			dev_dbg(&u3phy_port->phy->dev, "Connected\n");
++			rockchip_u3phy_power_on(u3phy_port->phy);
++			u3phy_port->suspended = false;
++		} else {
++			/* D+ line pull-up, D- line pull-down */
++			dev_dbg(&u3phy_port->phy->dev, "FS/LS online\n");
++		}
++		break;
++	case PHY_UTMI_DISCONNECT:
++		if (!u3phy_port->suspended) {
++			dev_dbg(&u3phy_port->phy->dev, "Disconnected\n");
++			rockchip_u3phy_power_off(u3phy_port->phy);
++			u3phy_port->suspended = true;
++		}
++
++		/*
++		 * activate the linestate detection to get the next device
++		 * plug-in irq.
++		 */
++		param_write(u3phy->u3phy_grf,
++			    &u3phy->cfgs->grfcfg.ls_det_st, true);
++		param_write(u3phy->u3phy_grf,
++			    &u3phy->cfgs->grfcfg.ls_det_en, true);
++
++		/*
++		 * we don't need to rearm the delayed work when the phy port
++		 * is suspended.
++		 */
++		mutex_unlock(&u3phy_port->mutex);
++		return;
++	default:
++		dev_dbg(&u3phy_port->phy->dev, "unknown phy state\n");
++		break;
++	}
++
++next_schedule:
++	mutex_unlock(&u3phy_port->mutex);
++	schedule_delayed_work(&u3phy_port->um_sm_work, SCHEDULE_DELAY);
++}
++
++static irqreturn_t rockchip_u3phy_um_ls_irq(int irq, void *data)
++{
++	struct rockchip_u3phy_port *u3phy_port = data;
++	struct rockchip_u3phy *u3phy =
++		dev_get_drvdata(u3phy_port->phy->dev.parent);
++
++	if (!param_exped(u3phy->u3phy_grf,
++			 &u3phy->cfgs->grfcfg.ls_det_st,
++			 u3phy->cfgs->grfcfg.ls_det_st.dvalue))
++		return IRQ_NONE;
++
++	dev_dbg(u3phy->dev, "utmi linestate interrupt\n");
++	mutex_lock(&u3phy_port->mutex);
++
++	/* disable linestate detect irq and clear its status */
++	param_write(u3phy->u3phy_grf, &u3phy->cfgs->grfcfg.ls_det_en, false);
++	param_write(u3phy->u3phy_grf, &u3phy->cfgs->grfcfg.ls_det_st, true);
++
++	mutex_unlock(&u3phy_port->mutex);
++
++	/*
++	 * In this case for host phy, a new device is plugged in, meanwhile,
++	 * if the phy port is suspended, we need rearm the work to resume it
++	 * and mange its states; otherwise, we just return irq handled.
++	 */
++	if (u3phy_port->suspended) {
++		dev_dbg(u3phy->dev, "schedule utmi sm work\n");
++		rockchip_u3phy_um_sm_work(&u3phy_port->um_sm_work.work);
++	}
++
++	return IRQ_HANDLED;
++}
++
++static int rockchip_u3phy_parse_dt(struct rockchip_u3phy *u3phy,
++				   struct platform_device *pdev)
++
++{
++	struct device *dev = &pdev->dev;
++	struct device_node *np = dev->of_node;
++	int ret, i, clk;
++
++	u3phy->um_ls_irq = platform_get_irq_byname(pdev, "linestate");
++	if (u3phy->um_ls_irq < 0) {
++		dev_err(dev, "get utmi linestate irq failed\n");
++		return -ENXIO;
++	}
++
++	u3phy->vbus_drv_gpio = devm_gpiod_get_optional(dev, "vbus-drv",
++						       GPIOD_OUT_HIGH);
++
++	if (!u3phy->vbus_drv_gpio) {
++		dev_warn(&pdev->dev, "vbus_drv is not assigned\n");
++	} else if (IS_ERR(u3phy->vbus_drv_gpio)) {
++		dev_err(&pdev->dev, "failed to get vbus_drv\n");
++		return PTR_ERR(u3phy->vbus_drv_gpio);
++	}
++
++	u3phy->num_clocks = of_clk_get_parent_count(np);
++	if (u3phy->num_clocks == 0)
++		dev_warn(&pdev->dev, "no clks found in dt\n");
++
++	u3phy->clks = devm_kcalloc(dev, u3phy->num_clocks,
++				  sizeof(struct clk *), GFP_KERNEL);
++
++	for (clk = 0; clk < u3phy->num_clocks; clk++) {
++		u3phy->clks[clk] = of_clk_get(np, clk);
++		if (IS_ERR(u3phy->clks[clk])) {
++			ret = PTR_ERR(u3phy->clks[clk]);
++			if (ret == -EPROBE_DEFER)
++				goto err_put_clks;
++			dev_err(&pdev->dev, "failed to get clks, %i\n",
++				ret);
++			u3phy->clks[clk] = NULL;
++			break;
++		}
++	}
++
++	for (i = 0; i < U3PHY_RESET_MAX; i++) {
++		u3phy->rsts[i] = devm_reset_control_get(dev, get_rest_name(i));
++		if (IS_ERR(u3phy->rsts[i])) {
++			dev_info(dev, "no %s reset control specified\n",
++				 get_rest_name(i));
++			u3phy->rsts[i] = NULL;
++		}
++	}
++
++	return 0;
++
++err_put_clks:
++	while (--clk >= 0)
++		clk_put(u3phy->clks[clk]);
++	return ret;
++}
++
++static int rockchip_u3phy_port_init(struct rockchip_u3phy *u3phy,
++				    struct rockchip_u3phy_port *u3phy_port,
++				    struct device_node *child_np)
++{
++	struct resource res;
++	struct phy *phy;
++	int ret;
++
++	dev_dbg(u3phy->dev, "u3phy port initialize\n");
++
++	mutex_init(&u3phy_port->mutex);
++	u3phy_port->suspended = true; /* initial status */
++
++	phy = devm_phy_create(u3phy->dev, child_np, &rockchip_u3phy_ops);
++	if (IS_ERR(phy)) {
++		dev_err(u3phy->dev, "failed to create phy\n");
++		return PTR_ERR(phy);
++	}
++
++	u3phy_port->phy = phy;
++
++	ret = of_address_to_resource(child_np, 0, &res);
++	if (ret) {
++		dev_err(u3phy->dev, "failed to get address resource(np-%s)\n",
++			child_np->name);
++		return ret;
++	}
++
++	u3phy_port->base = devm_ioremap_resource(&u3phy_port->phy->dev, &res);
++	if (IS_ERR(u3phy_port->base)) {
++		dev_err(u3phy->dev, "failed to remap phy regs\n");
++		return PTR_ERR(u3phy_port->base);
++	}
++
++	if (!of_node_cmp(child_np->name, "pipe")) {
++		u3phy_port->type = U3PHY_TYPE_PIPE;
++		u3phy_port->refclk_25m_quirk =
++			of_property_read_bool(child_np,
++					      "rockchip,refclk-25m-quirk");
++	} else {
++		u3phy_port->type = U3PHY_TYPE_UTMI;
++		INIT_DELAYED_WORK(&u3phy_port->um_sm_work,
++				  rockchip_u3phy_um_sm_work);
++
++		ret = devm_request_threaded_irq(u3phy->dev, u3phy->um_ls_irq,
++						NULL, rockchip_u3phy_um_ls_irq,
++						IRQF_ONESHOT, "rockchip_u3phy",
++						u3phy_port);
++		if (ret) {
++			dev_err(u3phy->dev, "failed to request utmi linestate irq handle\n");
++			return ret;
++		}
++	}
++
++	if (u3phy->cfgs->phy_tuning) {
++		dev_dbg(u3phy->dev, "do u3phy tuning\n");
++		ret = u3phy->cfgs->phy_tuning(u3phy, u3phy_port, child_np);
++		if (ret)
++			return ret;
++	}
++
++	phy_set_drvdata(u3phy_port->phy, u3phy_port);
++	return 0;
++}
++
++static int rockchip_u3phy_on_init(struct usb_phy *usb_phy)
++{
++	struct rockchip_u3phy *u3phy =
++		container_of(usb_phy, struct rockchip_u3phy, usb_phy);
++
++	rockchip_u3phy_rest_deassert(u3phy, U3PHY_POR_RST | U3PHY_MAC_RST);
++	return 0;
++}
++
++static void rockchip_u3phy_on_shutdown(struct usb_phy *usb_phy)
++{
++	struct rockchip_u3phy *u3phy =
++		container_of(usb_phy, struct rockchip_u3phy, usb_phy);
++	int rst;
++
++	for (rst = 0; rst < U3PHY_RESET_MAX; rst++)
++		if (u3phy->rsts[rst] && rst != UTMI_APB_RSTN &&
++		    rst != PIPE_APB_RSTN)
++			reset_control_assert(u3phy->rsts[rst]);
++	udelay(1);
++}
++
++static int rockchip_u3phy_on_disconnect(struct usb_phy *usb_phy,
++					enum usb_device_speed speed)
++{
++	struct rockchip_u3phy *u3phy =
++		container_of(usb_phy, struct rockchip_u3phy, usb_phy);
++
++	dev_info(u3phy->dev, "%s device has disconnected\n",
++		 (speed == USB_SPEED_SUPER) ? "U3" : "UW/U2/U1.1/U1");
++
++	if (speed == USB_SPEED_SUPER)
++		atomic_notifier_call_chain(&usb_phy->notifier, 0, NULL);
++
++	return 0;
++}
++
++static int rockchip_u3phy_probe(struct platform_device *pdev)
++{
++	struct device *dev = &pdev->dev;
++	struct device_node *np = dev->of_node;
++	struct device_node *child_np;
++	struct phy_provider *provider;
++	struct rockchip_u3phy *u3phy;
++	const struct rockchip_u3phy_cfg *phy_cfgs;
++	const struct of_device_id *match;
++	unsigned int reg[2];
++	int index, ret;
++
++	match = of_match_device(dev->driver->of_match_table, dev);
++	if (!match || !match->data) {
++		dev_err(dev, "phy-cfgs are not assigned!\n");
++		return -EINVAL;
++	}
++
++	u3phy = devm_kzalloc(dev, sizeof(*u3phy), GFP_KERNEL);
++	if (!u3phy)
++		return -ENOMEM;
++
++	u3phy->u3phy_grf =
++		syscon_regmap_lookup_by_phandle(np, "rockchip,u3phygrf");
++	if (IS_ERR(u3phy->u3phy_grf))
++		return PTR_ERR(u3phy->u3phy_grf);
++
++	u3phy->grf =
++		syscon_regmap_lookup_by_phandle(np, "rockchip,grf");
++	if (IS_ERR(u3phy->grf)) {
++		dev_err(dev, "Missing rockchip,grf property\n");
++		return PTR_ERR(u3phy->grf);
++	}
++
++	if (of_property_read_u32_array(np, "reg", reg, 2)) {
++		dev_err(dev, "the reg property is not assigned in %s node\n",
++			np->name);
++		return -EINVAL;
++	}
++
++	u3phy->dev = dev;
++	phy_cfgs = match->data;
++	platform_set_drvdata(pdev, u3phy);
++
++	/* find out a proper config which can be matched with dt. */
++	index = 0;
++	while (phy_cfgs[index].reg) {
++		if (phy_cfgs[index].reg == reg[1]) {
++			u3phy->cfgs = &phy_cfgs[index];
++			break;
++		}
++
++		++index;
++	}
++
++	if (!u3phy->cfgs) {
++		dev_err(dev, "no phy-cfgs can be matched with %s node\n",
++			np->name);
++		return -EINVAL;
++	}
++
++	ret = rockchip_u3phy_parse_dt(u3phy, pdev);
++	if (ret) {
++		dev_err(dev, "parse dt failed, ret(%d)\n", ret);
++		return ret;
++	}
++
++	ret = rockchip_u3phy_clk_enable(u3phy);
++	if (ret) {
++		dev_err(dev, "clk enable failed, ret(%d)\n", ret);
++		return ret;
++	}
++
++	rockchip_u3phy_rest_assert(u3phy);
++	rockchip_u3phy_rest_deassert(u3phy, U3PHY_APB_RST | U3PHY_POR_RST);
++
++	index = 0;
++	for_each_available_child_of_node(np, child_np) {
++		struct rockchip_u3phy_port *u3phy_port = &u3phy->ports[index];
++
++		u3phy_port->index = index;
++		ret = rockchip_u3phy_port_init(u3phy, u3phy_port, child_np);
++		if (ret) {
++			dev_err(dev, "u3phy port init failed,ret(%d)\n", ret);
++			goto put_child;
++		}
++
++		/* to prevent out of boundary */
++		if (++index >= U3PHY_PORT_NUM)
++			break;
++	}
++
++	provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);
++	if (IS_ERR_OR_NULL(provider))
++		goto put_child;
++
++	rockchip_u3phy_rest_deassert(u3phy, U3PHY_MAC_RST);
++	rockchip_u3phy_clk_disable(u3phy);
++
++	u3phy->usb_phy.dev = dev;
++	u3phy->usb_phy.init = rockchip_u3phy_on_init;
++	u3phy->usb_phy.shutdown = rockchip_u3phy_on_shutdown;
++	u3phy->usb_phy.notify_disconnect = rockchip_u3phy_on_disconnect;
++	usb_add_phy(&u3phy->usb_phy, USB_PHY_TYPE_USB3);
++	ATOMIC_INIT_NOTIFIER_HEAD(&u3phy->usb_phy.notifier);
++
++	rockchip_u3phy_debugfs_init(u3phy);
++
++	dev_info(dev, "Rockchip u3phy initialized successfully\n");
++	return 0;
++
++put_child:
++	of_node_put(child_np);
++	return ret;
++}
++
++static int rk3328_u3phy_pipe_power(struct rockchip_u3phy *u3phy,
++				   struct rockchip_u3phy_port *u3phy_port,
++				   bool on)
++{
++	unsigned int reg;
++
++	if (on) {
++		reg = readl(u3phy_port->base + 0x1a8);
++		reg &= ~BIT(4); /* ldo power up */
++		writel(reg, u3phy_port->base + 0x1a8);
++
++		reg = readl(u3phy_port->base + 0x044);
++		reg &= ~BIT(4); /* bg power on */
++		writel(reg, u3phy_port->base + 0x044);
++
++		reg = readl(u3phy_port->base + 0x150);
++		reg |= BIT(6); /* tx bias enable */
++		writel(reg, u3phy_port->base + 0x150);
++
++		reg = readl(u3phy_port->base + 0x080);
++		reg &= ~BIT(2); /* tx cm power up */
++		writel(reg, u3phy_port->base + 0x080);
++
++		reg = readl(u3phy_port->base + 0x0c0);
++		/* tx obs enable and rx cm enable */
++		reg |= (BIT(3) | BIT(4));
++		writel(reg, u3phy_port->base + 0x0c0);
++
++		udelay(1);
++	} else {
++		reg = readl(u3phy_port->base + 0x1a8);
++		reg |= BIT(4); /* ldo power down */
++		writel(reg, u3phy_port->base + 0x1a8);
++
++		reg = readl(u3phy_port->base + 0x044);
++		reg |= BIT(4); /* bg power down */
++		writel(reg, u3phy_port->base + 0x044);
++
++		reg = readl(u3phy_port->base + 0x150);
++		reg &= ~BIT(6); /* tx bias disable */
++		writel(reg, u3phy_port->base + 0x150);
++
++		reg = readl(u3phy_port->base + 0x080);
++		reg |= BIT(2); /* tx cm power down */
++		writel(reg, u3phy_port->base + 0x080);
++
++		reg = readl(u3phy_port->base + 0x0c0);
++		/* tx obs disable and rx cm disable */
++		reg &= ~(BIT(3) | BIT(4));
++		writel(reg, u3phy_port->base + 0x0c0);
++	}
++
++	return 0;
++}
++
++static int rk3328_u3phy_tuning(struct rockchip_u3phy *u3phy,
++			       struct rockchip_u3phy_port *u3phy_port,
++			       struct device_node *child_np)
++{
++	if (u3phy_port->type == U3PHY_TYPE_UTMI) {
++		/*
++		 * For rk3328 SoC, pre-emphasis and pre-emphasis strength must
++		 * be written as one fixed value as below.
++		 *
++		 * Dissimilarly, the odt 45ohm value should be flexibly tuninged
++		 * for the different boards to adjust HS eye height, so its
++		 * value can be assigned in DT in code design.
++		 */
++
++		/* {bits[2:0]=111}: always enable pre-emphasis */
++		u3phy->apbcfg.u2_pre_emp = 0x0f;
++
++		/* {bits[5:3]=000}: pre-emphasis strength as the weakest */
++		u3phy->apbcfg.u2_pre_emp_sth = 0x41;
++
++		/* {bits[4:0]=10101}: odt 45ohm tuning */
++		u3phy->apbcfg.u2_odt_tuning = 0xb5;
++		/* optional override of the odt 45ohm tuning */
++		of_property_read_u32(child_np, "rockchip,odt-val-tuning",
++				     &u3phy->apbcfg.u2_odt_tuning);
++
++		writel(u3phy->apbcfg.u2_pre_emp, u3phy_port->base + 0x030);
++		writel(u3phy->apbcfg.u2_pre_emp_sth, u3phy_port->base + 0x040);
++		writel(u3phy->apbcfg.u2_odt_tuning, u3phy_port->base + 0x11c);
++	} else if (u3phy_port->type == U3PHY_TYPE_PIPE) {
++		if (u3phy_port->refclk_25m_quirk) {
++			dev_dbg(u3phy->dev, "switch to 25m refclk\n");
++			/* ref clk switch to 25M */
++			writel(0x64, u3phy_port->base + 0x11c);
++			writel(0x64, u3phy_port->base + 0x028);
++			writel(0x01, u3phy_port->base + 0x020);
++			writel(0x21, u3phy_port->base + 0x030);
++			writel(0x06, u3phy_port->base + 0x108);
++			writel(0x00, u3phy_port->base + 0x118);
++		} else {
++			/* configure for 24M ref clk */
++			writel(0x80, u3phy_port->base + 0x10c);
++			writel(0x01, u3phy_port->base + 0x118);
++			writel(0x38, u3phy_port->base + 0x11c);
++			writel(0x83, u3phy_port->base + 0x020);
++			writel(0x02, u3phy_port->base + 0x108);
++		}
++
++		/* Enable SSC */
++		udelay(3);
++		writel(0x08, u3phy_port->base + 0x000);
++		writel(0x0c, u3phy_port->base + 0x120);
++
++		/* Tuning Rx for compliance RJTL test */
++		writel(0x70, u3phy_port->base + 0x150);
++		writel(0x12, u3phy_port->base + 0x0c8);
++		writel(0x05, u3phy_port->base + 0x148);
++		writel(0x08, u3phy_port->base + 0x068);
++		writel(0xf0, u3phy_port->base + 0x1c4);
++		writel(0xff, u3phy_port->base + 0x070);
++		writel(0x0f, u3phy_port->base + 0x06c);
++		writel(0xe0, u3phy_port->base + 0x060);
++
++		/*
++		 * Tuning Tx to increase the bias current
++		 * used in TX driver and RX EQ, it can
++		 * also increase the voltage of LFPS.
++		 */
++		writel(0x08, u3phy_port->base + 0x180);
++	} else {
++		dev_err(u3phy->dev, "invalid u3phy port type\n");
++		return -EINVAL;
++	}
++
++	return 0;
++}
++
++static const struct rockchip_u3phy_cfg rk3328_u3phy_cfgs[] = {
++	{
++		.reg		= 0xff470000,
++		.grfcfg		= {
++			.um_suspend	= { 0x0004, 15, 0, 0x1452, 0x15d1 },
++			.u2_only_ctrl	= { 0x0020, 15, 15, 0, 1 },
++			.um_ls		= { 0x0030, 5, 4, 0, 1 },
++			.um_hstdct	= { 0x0030, 7, 7, 0, 1 },
++			.ls_det_en	= { 0x0040, 0, 0, 0, 1 },
++			.ls_det_st	= { 0x0044, 0, 0, 0, 1 },
++			.pp_pwr_st	= { 0x0034, 14, 13, 0, 0},
++			.pp_pwr_en	= { {0x0020, 14, 0, 0x0014, 0x0005},
++					    {0x0020, 14, 0, 0x0014, 0x000d},
++					    {0x0020, 14, 0, 0x0014, 0x0015},
++					    {0x0020, 14, 0, 0x0014, 0x001d} },
++			.u3_disable	= { 0x04c4, 15, 0, 0x1100, 0x101},
++		},
++		.phy_pipe_power	= rk3328_u3phy_pipe_power,
++		.phy_tuning	= rk3328_u3phy_tuning,
++	},
++	{ /* sentinel */ }
++};
++
++static const struct of_device_id rockchip_u3phy_dt_match[] = {
++	{ .compatible = "rockchip,rk3328-u3phy", .data = &rk3328_u3phy_cfgs },
++	{}
++};
++MODULE_DEVICE_TABLE(of, rockchip_u3phy_dt_match);
++
++static struct platform_driver rockchip_u3phy_driver = {
++	.probe		= rockchip_u3phy_probe,
++	.driver		= {
++		.name	= "rockchip-u3phy",
++		.of_match_table = rockchip_u3phy_dt_match,
++	},
++};
++module_platform_driver(rockchip_u3phy_driver);
++
++MODULE_AUTHOR("Frank Wang <frank.wang@rock-chips.com>");
++MODULE_AUTHOR("William Wu <william.wu@rock-chips.com>");
++MODULE_DESCRIPTION("Rockchip USB 3.0 PHY driver");
++MODULE_LICENSE("GPL v2");
+
+diff --git a/Documentation/devicetree/bindings/phy/phy-rockchip-inno-usb3.yaml b/Documentation/devicetree/bindings/phy/phy-rockchip-inno-usb3.yaml
+new file mode 100644
+index 000000000000..f4f28625173a
+--- /dev/null
++++ b/Documentation/devicetree/bindings/phy/phy-rockchip-inno-usb3.yaml
+@@ -0,0 +1,157 @@
++# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
++%YAML 1.2
++---
++$id: "http://devicetree.org/schemas/phy/phy-rockchip-inno-usb3.yaml#"
++$schema: "http://devicetree.org/meta-schemas/core.yaml#"
++
++title: ROCKCHIP USB 3.0 PHY WITH INNO IP BLOCK
++
++maintainers:
++
++properties:
++  compatible:
++    enum:
++      - rockchip,rk3328-u3phy
++
++  reg:
++    - description: the base address of the USB 3.0 PHY
++
++  interrupts:
++    maxItems: 1
++
++  interrupt-names:
++    items:
++      - const: linestate
++        description: host/otg linestate interrupt
++
++  clocks:
++    maxItems: 2
++
++  clock-names:
++    items:
++      - const: u3phy-otg
++        description: USB 3.0 PHY UTMI
++      - const: u3phy-pipe
++        description: USB 3.0 PHY Pipe
++
++  resets:
++    maxItems: 6
++
++  reset-names:
++    items:
++      - const: u3phy-u2-por
++      description: USB 2.0 logic of USB 3.0 PHY
++      - const: u3phy-u3-por
++      description: USB 3.0 logic of USB 3.0 PHY
++      - const: u3phy-pipe-mac
++      description: USB 3.0 PHY pipe MAC
++      - const: u3phy-utmi-mac
++      description: USB 3.0 PHY utmi MAC
++      - const: u3phy-utmi-apb
++      description: USB 3.0 PHY utmi apb
++      - const: u3phy-pipe-apb
++      description: USB 3.0 PHY pipe apb
++
++  "#phy-cells":
++    const: 1
++
++  rockchip,u3phygrf:
++    $ref: /schemas/types.yaml#/definitions/phandle-array
++    type: array
++    - description: phandle to the syscon managing the
++                   "USB 3.0 PHY general register files".
++
++  vbus-drv-gpios:
++    $ref: /schemas/types.yaml#/definitions/phandle-array
++    type: array
++    - description: phandle for gpio vbus supply
++
++required:
++  - compatible
++  - reg
++  - interrupts
++  - interrupt-names
++  - clocks
++  - clock-names
++  - resets
++  - reset-names
++  - "#phy-cells"
++  - rockchip,u3phygrf
++
++patternProperties:
++  "^u3phy_utmi@[0-9a-f]+$":
++    type: object
++
++    properties:
++      - description: USB 2.0 utmi phy.
++
++      rockchip,odt-val-tuning:
++        type: boolean
++        - description: specify 45ohm ODT tuning value.
++
++      "phy-cells":
++        const: 0
++
++    required:
++      - reg
++      - "#phy-cells"
++
++patternProperties:
++  "^u3phy_pipe@[0-9a-f]+$":
++    type: object
++
++    properties:
++      - description: USB 3.0 pipe phy.
++
++      rockchip,refclk-25m-quirk :
++
++        - description: phy reference clock changed to 25m quirk.
++
++      "phy-cells":
++        const: 0
++
++    required:
++      - reg
++      - "#phy-cells"
++
++examples:
++
++usb3phy_grf: syscon@ff460000 {
++	compatible = "rockchip,usb3phy-grf", "syscon";
++	reg = <0x0 0xff460000 0x0 0x1000>;
++};
++
++...
++
++u3phy: usb3-phy@ff470000 {
++	compatible = "rockchip,rk3328-u3phy";
++	reg = <0x0 0xff470000 0x0 0x0>;
++	rockchip,u3phygrf = <&usb3phy_grf>;
++	interrupts = <GIC_SPI 77 IRQ_TYPE_LEVEL_HIGH>;
++	interrupt-names = "linestate";
++	clocks = <&cru PCLK_USB3PHY_OTG>, <&cru PCLK_USB3PHY_PIPE>;
++	clock-names = "u3phy-otg", "u3phy-pipe";
++	resets = <&cru SRST_USB3PHY_U2>,
++		 <&cru SRST_USB3PHY_U3>,
++		 <&cru SRST_USB3PHY_PIPE>,
++		 <&cru SRST_USB3OTG_UTMI>,
++		 <&cru SRST_USB3PHY_OTG_P>,
++		 <&cru SRST_USB3PHY_PIPE_P>;
++	reset-names = "u3phy-u2-por", "u3phy-u3-por",
++		      "u3phy-pipe-mac", "u3phy-utmi-mac",
++		      "u3phy-utmi-apb", "u3phy-pipe-apb";
++	vbus-drv-gpios = <&gpio0 0 GPIO_ACTIVE_HIGH>;
++	#address-cells = <2>;
++	#size-cells = <2>;
++	ranges;
++
++	u3phy_utmi: utmi@ff470000 {
++		reg = <0x0 0xff470000 0x0 0x8000>;
++		#phy-cells = <0>;
++	};
++
++	u3phy_pipe: pipe@ff478000 {
++		reg = <0x0 0xff478000 0x0 0x8000>;
++		#phy-cells = <0>;
++	};
++};
+diff --git a/Documentation/devicetree/bindings/soc/rockchip/grf.txt b/Documentation/devicetree/bindings/soc/rockchip/grf.txt
+index ada5435ce2c3..5f2f19344cc7 100644
+--- a/Documentation/devicetree/bindings/soc/rockchip/grf.txt
++++ b/Documentation/devicetree/bindings/soc/rockchip/grf.txt
+@@ -34,6 +34,8 @@ Required Properties:
+    - "rockchip,rk3328-usb2phy-grf", "syscon": for rk3328
+ - compatible: USBGRF should be one of the following:
+    - "rockchip,rv1108-usbgrf", "syscon": for rv1108
++- compatible: USB3PHYGRF should be one of the following:
++   - "rockchip,u3phy-grf", "syscon"
+ - reg: physical base address of the controller and length of memory mapped
+   region.
+ 
+diff --git a/arch/arm64/boot/dts/rockchip/rk3328.dtsi b/arch/arm64/boot/dts/rockchip/rk3328.dtsi
+index 31cc1541f1f5..072e988ad655 100644
+--- a/arch/arm64/boot/dts/rockchip/rk3328.dtsi
++++ b/arch/arm64/boot/dts/rockchip/rk3328.dtsi
+@@ -805,6 +805,47 @@
+ 		};
+ 	};
+ 
++	usb3phy_grf: syscon@ff460000 {
++		compatible = "rockchip,usb3phy-grf", "syscon";
++		reg = <0x0 0xff460000 0x0 0x1000>;
++	};
++
++	u3phy: usb3-phy@ff470000 {
++		compatible = "rockchip,rk3328-u3phy";
++		reg = <0x0 0xff470000 0x0 0x0>;
++		rockchip,u3phygrf = <&usb3phy_grf>;
++		rockchip,grf = <&grf>;
++		interrupts = <GIC_SPI 77 IRQ_TYPE_LEVEL_HIGH>;
++		interrupt-names = "linestate";
++		clocks = <&cru PCLK_USB3PHY_OTG>, <&cru PCLK_USB3PHY_PIPE>;
++		clock-names = "u3phy-otg", "u3phy-pipe";
++		resets = <&cru SRST_USB3PHY_U2>,
++			 <&cru SRST_USB3PHY_U3>,
++			 <&cru SRST_USB3PHY_PIPE>,
++			 <&cru SRST_USB3OTG_UTMI>,
++			 <&cru SRST_USB3PHY_OTG_P>,
++			 <&cru SRST_USB3PHY_PIPE_P>;
++		reset-names = "u3phy-u2-por", "u3phy-u3-por",
++			      "u3phy-pipe-mac", "u3phy-utmi-mac",
++			      "u3phy-utmi-apb", "u3phy-pipe-apb";
++		#address-cells = <2>;
++		#size-cells = <2>;
++		ranges;
++		status = "disabled";
++
++		u3phy_utmi: utmi@ff470000 {
++			reg = <0x0 0xff470000 0x0 0x8000>;
++			#phy-cells = <0>;
++			status = "disabled";
++		};
++
++		u3phy_pipe: pipe@ff478000 {
++			reg = <0x0 0xff478000 0x0 0x8000>;
++			#phy-cells = <0>;
++			status = "disabled";
++		};
++	};
++
+ 	sdmmc: dwmmc@ff500000 {
+ 		compatible = "rockchip,rk3328-dw-mshc", "rockchip,rk3288-dw-mshc";
+ 		reg = <0x0 0xff500000 0x0 0x4000>;
+@@ -936,6 +977,37 @@
+ 		status = "disabled";
+ 	};
+ 
++	usbdrd3: usb@ff600000 {
++		compatible = "rockchip,rk3328-dwc3", "rockchip,rk3399-dwc3";
++		clocks = <&cru SCLK_USB3OTG_REF>, <&cru ACLK_USB3OTG>,
++			 <&cru SCLK_USB3OTG_SUSPEND>;
++		clock-names = "ref", "bus_early",
++			      "suspend";
++		#address-cells = <2>;
++		#size-cells = <2>;
++		ranges;
++		clock-ranges;
++		status = "disabled";
++
++		usbdrd_dwc3: dwc3@ff600000 {
++			compatible = "snps,dwc3";
++			reg = <0x0 0xff600000 0x0 0x100000>;
++			interrupts = <GIC_SPI 67 IRQ_TYPE_LEVEL_HIGH>;
++			dr_mode = "otg";
++			phys = <&u3phy_utmi>, <&u3phy_pipe>;
++			phy-names = "usb2-phy", "usb3-phy";
++			phy_type = "utmi_wide";
++			snps,dis_enblslpm_quirk;
++			snps,dis-u2-freeclk-exists-quirk;
++			snps,dis_u2_susphy_quirk;
++			snps,dis_u3_susphy_quirk;
++			snps,dis-del-phy-power-chg-quirk;
++			snps,dis-tx-ipgap-linecheck-quirk;
++			snps,xhci-trb-ent-quirk;
++			status = "disabled";
++		};
++	};
++
+ 	gic: interrupt-controller@ff811000 {
+ 		compatible = "arm,gic-400";
+ 		#interrupt-cells = <3>;
diff --git a/target/linux/rockchip/patches-5.4/003-add-rk3328-rock-pi-e-support.patch b/target/linux/rockchip/patches-5.4/003-add-rk3328-rock-pi-e-support.patch
new file mode 100644
index 0000000000..d4e24be558
--- /dev/null
+++ b/target/linux/rockchip/patches-5.4/003-add-rk3328-rock-pi-e-support.patch
@@ -0,0 +1,420 @@
+diff -ruN a/arch/arm64/boot/dts/rockchip/Makefile b/arch/arm64/boot/dts/rockchip/Makefile
+--- a/arch/arm64/boot/dts/rockchip/Makefile	2020-05-27 15:46:53.000000000 +0000
++++ b/arch/arm64/boot/dts/rockchip/Makefile	2020-06-07 16:32:59.590211585 +0000
+@@ -3,6 +3,7 @@
+ dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3328-evb.dtb
+ dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3328-rock64.dtb
+ dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3328-roc-cc.dtb
++dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3328-rock-pi-e.dtb
+ dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3368-evb-act8846.dtb
+ dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3368-geekbox.dtb
+ dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3368-lion-haikou.dtb
+diff -ruN a/arch/arm64/boot/dts/rockchip/rk3328-rock-pi-e.dts b/arch/arm64/boot/dts/rockchip/rk3328-rock-pi-e.dts
+--- a/arch/arm64/boot/dts/rockchip/rk3328-rock-pi-e.dts	1970-01-01 00:00:00.000000000 +0000
++++ b/arch/arm64/boot/dts/rockchip/rk3328-rock-pi-e.dts	2020-06-07 16:32:43.789930837 +0000
+@@ -0,0 +1,405 @@
++// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
++/*
++ * Copyright (c) 2016 Fuzhou Rockchip Electronics Co., Ltd
++ */
++
++/dts-v1/;
++#include "rk3328.dtsi"
++#include <dt-bindings/input/input.h>
++
++/ {
++	model = "Radxa Rock Pi E";
++	compatible = "radxa,rock-pi-e", "rockchip,rk3328";
++
++	chosen {
++		stdout-path = "serial2:1500000n8";
++	};
++
++	fiq_debugger: fiq-debugger {
++		compatible = "rockchip,fiq-debugger";
++		rockchip,serial-id = <2>;
++		rockchip,signal-irq = <159>;
++		rockchip,wake-irq = <0>;
++		/* If enable uart uses irq instead of fiq */
++		rockchip,irq-mode-enable = <0>;
++		rockchip,baudrate = <1500000>;  /* Only 115200 and 1500000 */
++		interrupts = <GIC_SPI 127 IRQ_TYPE_LEVEL_LOW>;
++		status = "disabled";
++	};
++
++	gmac_clkin: external-gmac-clock {
++		compatible = "fixed-clock";
++		clock-frequency = <125000000>;
++		clock-output-names = "gmac_clkin";
++		#clock-cells = <0>;
++	};
++
++	leds {
++		compatible = "gpio-leds";
++		status = "okay";
++
++		user {
++			label = "rockpi:green:user";
++			gpios = <&gpio3 RK_PA5 GPIO_ACTIVE_LOW>;
++			linux,default-trigger = "heartbeat";
++			default-state = "on";
++		};
++	};
++
++	vcc5v0_host_xhci: vcc5v0-host-xhci-drv {
++		compatible = "regulator-fixed";
++		gpio = <&gpio3 RK_PA7 GPIO_ACTIVE_HIGH>;
++		pinctrl-names = "default";
++		pinctrl-0 = <&host_vbus_drv>;
++		regulator-name = "vcc5v0_host_xhci";
++		regulator-min-microvolt = <5000000>;
++		regulator-max-microvolt = <5000000>;
++		enable-active-high;
++	};
++
++	vcc_phy: vcc-phy-regulator {
++		compatible = "regulator-fixed";
++		regulator-name = "vcc_phy";
++		regulator-always-on;
++		regulator-boot-on;
++	};
++
++	vcc_sd: sdmmc-regulator {
++		compatible = "regulator-fixed";
++		gpio = <&gpio0 RK_PD6 GPIO_ACTIVE_LOW>;
++		pinctrl-names = "default";
++		pinctrl-0 = <&sdmmc0m1_gpio>;
++		regulator-name = "vcc_sd";
++		regulator-always-on;
++		regulator-boot-on;
++		regulator-min-microvolt = <3300000>;
++		regulator-max-microvolt = <3300000>;
++		vin-supply = <&vcc_io>;
++	};
++
++	vcc_sys: vcc-sys {
++		compatible = "regulator-fixed";
++		regulator-name = "vcc_sys";
++		regulator-always-on;
++		regulator-boot-on;
++		regulator-min-microvolt = <5000000>;
++		regulator-max-microvolt = <5000000>;
++	};
++
++	xin32k: xin32k {
++		compatible = "fixed-clock";
++		clock-frequency = <32768>;
++		clock-output-names = "xin32k";
++		#clock-cells = <0>;
++	};
++};
++
++&cpu0 {
++	cpu-supply = <&vdd_arm>;
++};
++
++&cpu1 {
++	cpu-supply = <&vdd_arm>;
++};
++
++&cpu2 {
++	cpu-supply = <&vdd_arm>;
++};
++
++&cpu3 {
++	cpu-supply = <&vdd_arm>;
++};
++
++&emmc {
++	bus-width = <8>;
++	cap-mmc-highspeed;
++	max-frequency = <150000000>;
++	mmc-ddr-1_8v;
++	mmc-hs200-1_8v;
++	supports-emmc;
++	disable-wp;
++	non-removable;
++	num-slots = <1>;
++	pinctrl-names = "default";
++	pinctrl-0 = <&emmc_clk &emmc_cmd &emmc_bus8>;
++	vmmc-supply = <&vcc_io>;
++	vqmmc-supply = <&vcc18_emmc>;
++	status = "okay";
++};
++
++&gmac2io {
++	phy-supply = <&vcc_io>;
++	phy-mode = "rgmii";
++	clock_in_out = "input";
++	snps,reset-gpio = <&gpio1 RK_PC2 GPIO_ACTIVE_LOW>;
++	snps,reset-active-low;
++	snps,reset-delays-us = <0 10000 50000>;
++	assigned-clocks = <&cru SCLK_MAC2IO>, <&cru SCLK_MAC2IO_EXT>;
++	assigned-clock-parents = <&gmac_clkin>, <&gmac_clkin>;
++	pinctrl-names = "default";
++	pinctrl-0 = <&rgmiim1_pins>;
++	snps,txpbl = <0x4>;
++	tx_delay = <0x26>;
++	rx_delay = <0x11>;
++	status = "okay";
++};
++
++&gmac2phy {
++	phy-supply = <&vcc_phy>;
++	clock_in_out = "output";
++	assigned-clocks = <&cru SCLK_MAC2PHY_SRC>;
++	assigned-clock-rate = <50000000>;
++	assigned-clocks = <&cru SCLK_MAC2PHY>;
++	assigned-clock-parents = <&cru SCLK_MAC2PHY_SRC>;
++	snps,txpbl = <0x4>;
++	status = "okay";
++};
++
++&i2c1 {
++	status = "okay";
++
++	rk805: rk805@18 {
++		compatible = "rockchip,rk805";
++		status = "okay";
++		reg = <0x18>;
++		interrupt-parent = <&gpio2>;
++		interrupts = <6 IRQ_TYPE_LEVEL_LOW>;
++		pinctrl-names = "default";
++		pinctrl-0 = <&pmic_int_l>;
++		rockchip,system-power-controller;
++		wakeup-source;
++		gpio-controller;
++		#gpio-cells = <2>;
++		#clock-cells = <1>;
++		clock-output-names = "xin32k", "rk805-clkout2";
++
++		vcc1-supply = <&vcc_sys>;
++		vcc2-supply = <&vcc_sys>;
++		vcc3-supply = <&vcc_sys>;
++		vcc4-supply = <&vcc_sys>;
++		vcc5-supply = <&vcc_io>;
++		vcc6-supply = <&vcc_sys>;
++
++		rtc {
++			status = "okay";
++		};
++
++		pwrkey {
++			status = "disabled";
++		};
++
++		gpio {
++			status = "okay";
++		};
++
++		regulators {
++			vdd_logic: DCDC_REG1 {
++				regulator-name = "vdd_logic";
++				regulator-min-microvolt = <712500>;
++				regulator-max-microvolt = <1450000>;
++				regulator-initial-mode = <0x1>;
++				regulator-ramp-delay = <12500>;
++				regulator-boot-on;
++				regulator-always-on;
++				regulator-state-mem {
++					regulator-mode = <0x2>;
++					regulator-on-in-suspend;
++					regulator-suspend-microvolt = <1000000>;
++				};
++			};
++
++			vdd_arm: DCDC_REG2 {
++				regulator-name = "vdd_arm";
++				regulator-min-microvolt = <712500>;
++				regulator-max-microvolt = <1450000>;
++				regulator-initial-mode = <0x1>;
++				regulator-ramp-delay = <12500>;
++				regulator-boot-on;
++				regulator-always-on;
++				regulator-state-mem {
++					regulator-mode = <0x2>;
++					regulator-on-in-suspend;
++					regulator-suspend-microvolt = <950000>;
++				};
++			};
++
++			vcc_ddr: DCDC_REG3 {
++				regulator-name = "vcc_ddr";
++				regulator-initial-mode = <0x1>;
++				regulator-boot-on;
++				regulator-always-on;
++				regulator-state-mem {
++					regulator-mode = <0x2>;
++					regulator-on-in-suspend;
++				};
++			};
++
++			vcc_io: DCDC_REG4 {
++				regulator-name = "vcc_io";
++				regulator-min-microvolt = <3300000>;
++				regulator-max-microvolt = <3300000>;
++				regulator-initial-mode = <0x1>;
++				regulator-boot-on;
++				regulator-always-on;
++				regulator-state-mem {
++					regulator-mode = <0x2>;
++					regulator-on-in-suspend;
++					regulator-suspend-microvolt = <3300000>;
++				};
++			};
++
++			vdd_18: LDO_REG1 {
++				regulator-name = "vdd_18";
++				regulator-min-microvolt = <1800000>;
++				regulator-max-microvolt = <1800000>;
++				regulator-boot-on;
++				regulator-always-on;
++				regulator-state-mem {
++					regulator-on-in-suspend;
++					regulator-suspend-microvolt = <1800000>;
++				};
++			};
++
++			vcc18_emmc: LDO_REG2 {
++				regulator-name = "vcc18_emmc";
++				regulator-min-microvolt = <1800000>;
++				regulator-max-microvolt = <1800000>;
++				regulator-boot-on;
++				regulator-always-on;
++				regulator-state-mem {
++					regulator-on-in-suspend;
++					regulator-suspend-microvolt = <1800000>;
++				};
++			};
++
++			vdd_10: LDO_REG3 {
++				regulator-name = "vdd_10";
++				regulator-min-microvolt = <1000000>;
++				regulator-max-microvolt = <1000000>;
++				regulator-boot-on;
++				regulator-always-on;
++				regulator-state-mem {
++					regulator-on-in-suspend;
++					regulator-suspend-microvolt = <1000000>;
++				};
++			};
++		};
++	};
++};
++
++&io_domains {
++	status = "okay";
++
++	vccio1-supply = <&vcc_io>;
++	vccio2-supply = <&vcc18_emmc>;
++	vccio3-supply = <&vcc_io>;
++	vccio4-supply = <&vcc_io>;
++	vccio5-supply = <&vcc_io>;
++	vccio6-supply = <&vcc_io>;
++	pmuio-supply = <&vcc_io>;
++};
++
++&pinctrl {
++	pinctrl-names = "default";
++	pinctrl-0 = <&wifi_enable>;
++
++	pmic {
++		pmic_int_l: pmic-int-l {
++			rockchip,pins =
++				<2 RK_PA6 RK_FUNC_GPIO &pcfg_pull_up>;	/* gpio2_a6 */
++		};
++	};
++
++	usb {
++		host_vbus_drv: host-vbus-drv {
++			rockchip,pins =
++				<3 RK_PA7 RK_FUNC_GPIO &pcfg_pull_none>;
++		};
++	};
++
++	wifi {
++		wifi_enable: wifi-enable {
++			rockchip,pins =
++				<0 RK_PA0 RK_FUNC_GPIO &pcfg_pull_down>;
++		};
++	};
++};
++
++&saradc {
++	status = "okay";
++	vref-supply = <&vdd_18>;
++};
++
++&sdmmc {
++	bus-width = <4>;
++	cap-mmc-highspeed;
++	cap-sd-highspeed;
++	card-detect-delay = <200>;
++	disable-wp;
++	max-frequency = <150000000>;
++	num-slots = <1>;
++	pinctrl-names = "default";
++	pinctrl-0 = <&sdmmc0_clk &sdmmc0_cmd &sdmmc0_dectn &sdmmc0_bus4>;
++	supports-sd;
++	vmmc-supply = <&vcc_sd>;
++	status = "okay";
++};
++
++&tsadc {
++	status = "okay";
++	rockchip,hw-tshut-mode = <1>; /* tshut mode 0:CRU 1:GPIO */
++	rockchip,hw-tshut-polarity = <1>; /* tshut polarity 0:LOW 1:HIGH */
++};
++
++&u2phy {
++	status = "okay";
++};
++
++&u2phy_host {
++	status = "okay";
++};
++
++&u2phy_otg {
++	status = "okay";
++};
++
++&u3phy {
++	status = "okay";
++};
++
++&u3phy_pipe {
++	status = "okay";
++};
++
++&u3phy_utmi {
++	status = "okay";
++};
++
++&uart2 {
++	status = "okay";
++};
++
++&usb20_otg {
++	dr_mode = "host";
++	status = "okay";
++};
++
++&usbdrd3 {
++	status = "okay";
++};
++
++&usbdrd_dwc3 {
++	status = "okay";
++};
++
++&usb_host0_ehci {
++	status = "okay";
++};
++
++&usb_host0_ohci {
++	status = "okay";
++};
++
++&wdt {
++	status = "okay";
++};
diff --git a/target/linux/rockchip/patches-5.4/004-rk3328_add_idle_state.patch b/target/linux/rockchip/patches-5.4/004-rk3328_add_idle_state.patch
new file mode 100644
index 0000000000..1a62e29e1c
--- /dev/null
+++ b/target/linux/rockchip/patches-5.4/004-rk3328_add_idle_state.patch
@@ -0,0 +1,71 @@
+From 4f279f9fbca54464173240f7e73b145a136dfa1e Mon Sep 17 00:00:00 2001
+From: Robin Murphy <robin.murphy@arm.com>
+Date: Sun, 29 Dec 2019 20:16:17 +0000
+Subject: [PATCH] arm64: dts: rockchip: Add RK3328 idle state
+
+Downstream RK3328 DTBs describe a CPU idle state matching that present
+on other SoCs like RK3399. This works with upstream Trusted Firmware-A
+too, so let's add it here.
+
+Signed-off-by: Robin Murphy <robin.murphy@arm.com>
+Link: https://lore.kernel.org/r/a8c83e705d387446ea8121516d410e38b2d9c57b.1577640736.git.robin.murphy@arm.com
+Signed-off-by: Heiko Stuebner <heiko@sntech.de>
+---
+ arch/arm64/boot/dts/rockchip/rk3328.dtsi | 17 +++++++++++++++++
+ 1 file changed, 17 insertions(+)
+
+diff --git a/arch/arm64/boot/dts/rockchip/rk3328.dtsi b/arch/arm64/boot/dts/rockchip/rk3328.dtsi
+index 91306ebed4da..c9ff1188bd7b 100644
+--- a/arch/arm64/boot/dts/rockchip/rk3328.dtsi
++++ b/arch/arm64/boot/dts/rockchip/rk3328.dtsi
+@@ -41,6 +41,7 @@
+ 			reg = <0x0 0x0>;
+ 			clocks = <&cru ARMCLK>;
+ 			#cooling-cells = <2>;
++			cpu-idle-states = <&CPU_SLEEP>;
+ 			dynamic-power-coefficient = <120>;
+ 			enable-method = "psci";
+ 			next-level-cache = <&l2>;
+@@ -53,6 +54,7 @@
+ 			reg = <0x0 0x1>;
+ 			clocks = <&cru ARMCLK>;
+ 			#cooling-cells = <2>;
++			cpu-idle-states = <&CPU_SLEEP>;
+ 			dynamic-power-coefficient = <120>;
+ 			enable-method = "psci";
+ 			next-level-cache = <&l2>;
+@@ -65,6 +67,7 @@
+ 			reg = <0x0 0x2>;
+ 			clocks = <&cru ARMCLK>;
+ 			#cooling-cells = <2>;
++			cpu-idle-states = <&CPU_SLEEP>;
+ 			dynamic-power-coefficient = <120>;
+ 			enable-method = "psci";
+ 			next-level-cache = <&l2>;
+@@ -77,12 +80,26 @@
+ 			reg = <0x0 0x3>;
+ 			clocks = <&cru ARMCLK>;
+ 			#cooling-cells = <2>;
++			cpu-idle-states = <&CPU_SLEEP>;
+ 			dynamic-power-coefficient = <120>;
+ 			enable-method = "psci";
+ 			next-level-cache = <&l2>;
+ 			operating-points-v2 = <&cpu0_opp_table>;
+ 		};
+ 
++		idle-states {
++			entry-method = "psci";
++
++			CPU_SLEEP: cpu-sleep {
++				compatible = "arm,idle-state";
++				local-timer-stop;
++				arm,psci-suspend-param = <0x0010000>;
++				entry-latency-us = <120>;
++				exit-latency-us = <250>;
++				min-residency-us = <900>;
++			};
++		};
++
+ 		l2: l2-cache0 {
+ 			compatible = "cache";
+ 		};
diff --git a/target/linux/rockchip/patches-5.4/004-unlock-1512mhz-rk3328.patch b/target/linux/rockchip/patches-5.4/004-unlock-1512mhz-rk3328.patch
new file mode 100644
index 0000000000..7d67233d62
--- /dev/null
+++ b/target/linux/rockchip/patches-5.4/004-unlock-1512mhz-rk3328.patch
@@ -0,0 +1,16 @@
+diff --git a/arch/arm64/boot/dts/rockchip/rk3328.dtsi b/arch/arm64/boot/dts/rockchip/rk3328.dtsi
+index 8dabc6e29..d58c893a6 100644
+--- a/arch/arm64/boot/dts/rockchip/rk3328.dtsi
++++ b/arch/arm64/boot/dts/rockchip/rk3328.dtsi
+@@ -125,6 +125,11 @@
+ 			opp-microvolt = <1300000>;
+ 			clock-latency-ns = <40000>;
+ 		};
++		opp-1512000000 {
++			opp-hz = /bits/ 64 <1512000000>;
++			opp-microvolt = <1450000>;
++			clock-latency-ns = <40000>;
++		};
+ 	};
+ 
+ 	amba {
diff --git a/target/linux/rockchip/patches-5.4/005-add_hwmon_support.patch b/target/linux/rockchip/patches-5.4/005-add_hwmon_support.patch
new file mode 100644
index 0000000000..5d95ea66a6
--- /dev/null
+++ b/target/linux/rockchip/patches-5.4/005-add_hwmon_support.patch
@@ -0,0 +1,92 @@
+From f895f1f4de0b7252f29e7e5779727b303df9e58d Mon Sep 17 00:00:00 2001
+From: schaecsn <schaecsn@gmx.net>
+Date: Sun, 17 Nov 2019 21:24:13 -0800
+Subject: [PATCH] thermal: rockchip: enable hwmon
+
+Enable hwmon for the soc and gpu temperature sensors.
+
+Signed-off-by: Stefan Schaeckeler <schaecsn@gmx.net>
+---
+ drivers/thermal/rockchip_thermal.c | 12 +++++++++++-
+ 1 file changed, 11 insertions(+), 1 deletion(-)
+
+diff --git a/drivers/thermal/rockchip_thermal.c b/drivers/thermal/rockchip_thermal.c
+index 343c2f5c5a25..e47c60010259 100644
+--- a/drivers/thermal/rockchip_thermal.c
++++ b/drivers/thermal/rockchip_thermal.c
+@@ -19,6 +19,8 @@
+ #include <linux/mfd/syscon.h>
+ #include <linux/pinctrl/consumer.h>
+ 
++#include "thermal_hwmon.h"
++
+ /**
+  * If the temperature over a period of time High,
+  * the resulting TSHUT gave CRU module,let it reset the entire chip,
+@@ -1321,8 +1323,15 @@ static int rockchip_thermal_probe(struct platform_device *pdev)
+ 
+ 	thermal->chip->control(thermal->regs, true);
+ 
+-	for (i = 0; i < thermal->chip->chn_num; i++)
++	for (i = 0; i < thermal->chip->chn_num; i++) {
+ 		rockchip_thermal_toggle_sensor(&thermal->sensors[i], true);
++		thermal->sensors[i].tzd->tzp->no_hwmon = false;
++		error = thermal_add_hwmon_sysfs(thermal->sensors[i].tzd);
++		if (error)
++			dev_warn(&pdev->dev,
++				 "failed to register sensor %d with hwmon: %d\n",
++				 i, error);
++	}
+ 
+ 	platform_set_drvdata(pdev, thermal);
+ 
+@@ -1344,6 +1353,7 @@ static int rockchip_thermal_remove(struct platform_device *pdev)
+ 	for (i = 0; i < thermal->chip->chn_num; i++) {
+ 		struct rockchip_thermal_sensor *sensor = &thermal->sensors[i];
+ 
++		thermal_remove_hwmon_sysfs(sensor->tzd);
+ 		rockchip_thermal_toggle_sensor(sensor, false);
+ 	}
+ 
+
+From b5bcb54fe763aa9f40bae7af7e0629a3a6b93a52 Mon Sep 17 00:00:00 2001
+From: Robin Murphy <robin.murphy@arm.com>
+Date: Thu, 28 Nov 2019 20:59:27 +0000
+Subject: [PATCH] arm64: dts: rockchip: Add GPU cooling device for RK3399
+
+As for RK3288, now that we have a binding for the GPU we can
+hook up the missing cooling device for the thermal zone.
+
+Signed-off-by: Robin Murphy <robin.murphy@arm.com>
+---
+ arch/arm64/boot/dts/rockchip/rk3399.dtsi | 9 +++++++++
+ 1 file changed, 9 insertions(+)
+
+diff --git a/arch/arm64/boot/dts/rockchip/rk3399.dtsi b/arch/arm64/boot/dts/rockchip/rk3399.dtsi
+index e62ea0e2b657..aa0838adb224 100644
+--- a/arch/arm64/boot/dts/rockchip/rk3399.dtsi
++++ b/arch/arm64/boot/dts/rockchip/rk3399.dtsi
+@@ -827,6 +827,14 @@
+ 					type = "critical";
+ 				};
+ 			};
++
++			cooling-maps {
++				map0 {
++					trip = <&gpu_alert0>;
++					cooling-device =
++						<&gpu THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
++				};
++			};
+ 		};
+ 	};
+ 
+@@ -1886,6 +1894,7 @@
+ 			     <GIC_SPI 21 IRQ_TYPE_LEVEL_HIGH 0>;
+ 		interrupt-names = "gpu", "job", "mmu";
+ 		clocks = <&cru ACLK_GPU>;
++		#cooling-cells = <2>;
+ 		power-domains = <&power RK3399_PD_GPU>;
+ 		status = "disabled";
+ 	};
+
diff --git a/target/linux/rockchip/patches-5.4/006-rk3328_add_mmc_reset.patch b/target/linux/rockchip/patches-5.4/006-rk3328_add_mmc_reset.patch
new file mode 100644
index 0000000000..c66fbfbbaf
--- /dev/null
+++ b/target/linux/rockchip/patches-5.4/006-rk3328_add_mmc_reset.patch
@@ -0,0 +1,40 @@
+From 764e6cf1c0ffcfdbac7a259bc3ce4a7c4f221f75 Mon Sep 17 00:00:00 2001
+From: Jonas Karlman <jonas@kwiboo.se>
+Date: Sun, 29 Dec 2019 22:13:22 +0000
+Subject: [PATCH] arm64: dts: rockchip: add mmc reset on rk3328
+
+---
+ arch/arm64/boot/dts/rockchip/rk3328.dtsi | 6 ++++++
+ 1 file changed, 6 insertions(+)
+
+diff --git a/arch/arm64/boot/dts/rockchip/rk3328.dtsi b/arch/arm64/boot/dts/rockchip/rk3328.dtsi
+index 635f68fdc85c..3c50c11c2e5b 100644
+--- a/arch/arm64/boot/dts/rockchip/rk3328.dtsi
++++ b/arch/arm64/boot/dts/rockchip/rk3328.dtsi
+@@ -831,6 +831,8 @@
+ 		clock-names = "biu", "ciu", "ciu-drive", "ciu-sample";
+ 		fifo-depth = <0x100>;
+ 		max-frequency = <150000000>;
++		resets = <&cru SRST_MMC0>;
++		reset-names = "reset";
+ 		status = "disabled";
+ 	};
+ 
+@@ -843,6 +845,8 @@
+ 		clock-names = "biu", "ciu", "ciu-drive", "ciu-sample";
+ 		fifo-depth = <0x100>;
+ 		max-frequency = <150000000>;
++		resets = <&cru SRST_SDIO>;
++		reset-names = "reset";
+ 		status = "disabled";
+ 	};
+ 
+@@ -855,6 +859,8 @@
+ 		clock-names = "biu", "ciu", "ciu-drive", "ciu-sample";
+ 		fifo-depth = <0x100>;
+ 		max-frequency = <150000000>;
++		resets = <&cru SRST_EMMC>;
++		reset-names = "reset";
+ 		status = "disabled";
+ 	};
+ 
diff --git a/target/linux/rockchip/patches-5.4/007-add_mmc_poweroff.patch b/target/linux/rockchip/patches-5.4/007-add_mmc_poweroff.patch
new file mode 100644
index 0000000000..ed0078c5ae
--- /dev/null
+++ b/target/linux/rockchip/patches-5.4/007-add_mmc_poweroff.patch
@@ -0,0 +1,94 @@
+From 1049f9202ff060e16121c74fb712daea48979e42 Mon Sep 17 00:00:00 2001
+From: Jonas Karlman <jonas@kwiboo.se>
+Date: Fri, 11 Oct 2019 08:01:37 +0000
+Subject: [PATCH] mmc: dw_mmc: add power_off callback
+
+Signed-off-by: Jonas Karlman <jonas@kwiboo.se>
+---
+ drivers/mmc/host/dw_mmc.c | 3 +++
+ drivers/mmc/host/dw_mmc.h | 1 +
+ 2 files changed, 4 insertions(+)
+
+diff --git a/drivers/mmc/host/dw_mmc.c b/drivers/mmc/host/dw_mmc.c
+index 79c55c7b4afd..84557cdecf2a 100644
+--- a/drivers/mmc/host/dw_mmc.c
++++ b/drivers/mmc/host/dw_mmc.c
+@@ -1493,6 +1493,9 @@ static void dw_mci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+ 			regulator_disable(mmc->supply.vqmmc);
+ 		slot->host->vqmmc_enabled = false;
+ 
++		if (drv_data && drv_data->power_off)
++			drv_data->power_off(slot->host);
++
+ 		regs = mci_readl(slot->host, PWREN);
+ 		regs &= ~(1 << slot->id);
+ 		mci_writel(slot->host, PWREN, regs);
+diff --git a/drivers/mmc/host/dw_mmc.h b/drivers/mmc/host/dw_mmc.h
+index da5923a92e60..0b5c880364c5 100644
+--- a/drivers/mmc/host/dw_mmc.h
++++ b/drivers/mmc/host/dw_mmc.h
+@@ -563,5 +563,6 @@ struct dw_mci_drv_data {
+ 						struct mmc_ios *ios);
+ 	int		(*switch_voltage)(struct mmc_host *mmc,
+ 					  struct mmc_ios *ios);
++	void		(*power_off)(struct dw_mci *host);
+ };
+ #endif /* _DW_MMC_H_ */
+
+From 7f34988c4b1477568018aefdab4554f722985c29 Mon Sep 17 00:00:00 2001
+From: Jonas Karlman <jonas@kwiboo.se>
+Date: Fri, 11 Oct 2019 08:01:37 +0000
+Subject: [PATCH] mmc: dw_mmc-rockchip: try set vqmmc regulator to 3.3V on
+ power_off
+
+Signed-off-by: Jonas Karlman <jonas@kwiboo.se>
+---
+ drivers/mmc/host/dw_mmc-rockchip.c | 27 +++++++++++++++++++++++++++
+ 1 file changed, 27 insertions(+)
+
+diff --git a/drivers/mmc/host/dw_mmc-rockchip.c b/drivers/mmc/host/dw_mmc-rockchip.c
+index d4d02134848c..05410f90ddd3 100644
+--- a/drivers/mmc/host/dw_mmc-rockchip.c
++++ b/drivers/mmc/host/dw_mmc-rockchip.c
+@@ -24,6 +24,32 @@ struct dw_mci_rockchip_priv_data {
+ 	int			num_phases;
+ };
+ 
++static void dw_mci_rk3288_power_off(struct dw_mci *host)
++{
++	struct mmc_host	*mmc = host->slot->mmc;
++	struct mmc_ios *ios = &mmc->ios;
++	int old_signal_voltage;
++
++	if (IS_ERR(mmc->supply.vqmmc))
++		return;
++
++	if (mmc_host_is_spi(mmc))
++		return;
++
++	if (ios->vdd != 0 || ios->signal_voltage == MMC_SIGNAL_VOLTAGE_330)
++		return;
++
++	old_signal_voltage = ios->signal_voltage;
++
++	ios->signal_voltage = MMC_SIGNAL_VOLTAGE_330;
++	ios->vdd = fls(mmc->ocr_avail) - 1;
++
++	if (mmc_regulator_set_vqmmc(mmc, ios))
++		ios->signal_voltage = old_signal_voltage;
++
++	ios->vdd = 0;
++}
++
+ static void dw_mci_rk3288_set_ios(struct dw_mci *host, struct mmc_ios *ios)
+ {
+ 	struct dw_mci_rockchip_priv_data *priv = host->priv;
+@@ -319,6 +345,7 @@ static const struct dw_mci_drv_data rk3288_drv_data = {
+ 	.execute_tuning		= dw_mci_rk3288_execute_tuning,
+ 	.parse_dt		= dw_mci_rk3288_parse_dt,
+ 	.init			= dw_mci_rockchip_init,
++	.power_off		= dw_mci_rk3288_power_off,
+ };
+ 
+ static const struct of_device_id dw_mci_rockchip_match[] = {
+
diff --git a/target/linux/rockchip/patches-5.4/008-mmc_rename.patch b/target/linux/rockchip/patches-5.4/008-mmc_rename.patch
new file mode 100644
index 0000000000..f1ecd8e0b4
--- /dev/null
+++ b/target/linux/rockchip/patches-5.4/008-mmc_rename.patch
@@ -0,0 +1,56 @@
+From 3ef7c2558f31745588473b75a655894b37e62116 Mon Sep 17 00:00:00 2001
+From: Johan Jonker <jbx6244@gmail.com>
+Date: Wed, 15 Jan 2020 19:52:44 +0100
+Subject: arm64: dts: rockchip: rename dwmmc node names to mmc
+
+Current dts files with 'dwmmc' nodes are manually verified.
+In order to automate this process rockchip-dw-mshc.txt
+has to be converted to yaml. In the new setup
+rockchip-dw-mshc.yaml will inherit properties from
+mmc-controller.yaml and synopsys-dw-mshc-common.yaml.
+'dwmmc' will no longer be a valid name for a node,
+so change them all to 'mmc'
+
+Signed-off-by: Johan Jonker <jbx6244@gmail.com>
+Link: https://lore.kernel.org/r/20200115185244.18149-2-jbx6244@gmail.com
+Signed-off-by: Heiko Stuebner <heiko@sntech.de>
+---
+ arch/arm64/boot/dts/rockchip/rk3328.dtsi | 6 +++---
+ 1 file changed, 3 insertions(+), 3 deletions(-)
+
+(limited to 'arch/arm64/boot/dts/rockchip/rk3328.dtsi')
+
+diff --git a/arch/arm64/boot/dts/rockchip/rk3328.dtsi b/arch/arm64/boot/dts/rockchip/rk3328.dtsi
+index c9ff1188bd7b..1f53ead52c7f 100644
+--- a/arch/arm64/boot/dts/rockchip/rk3328.dtsi
++++ b/arch/arm64/boot/dts/rockchip/rk3328.dtsi
+@@ -822,7 +822,7 @@
+ 		};
+ 	};
+ 
+-	sdmmc: dwmmc@ff500000 {
++	sdmmc: mmc@ff500000 {
+ 		compatible = "rockchip,rk3328-dw-mshc", "rockchip,rk3288-dw-mshc";
+ 		reg = <0x0 0xff500000 0x0 0x4000>;
+ 		interrupts = <GIC_SPI 12 IRQ_TYPE_LEVEL_HIGH>;
+@@ -836,7 +836,7 @@
+ 		status = "disabled";
+ 	};
+ 
+-	sdio: dwmmc@ff510000 {
++	sdio: mmc@ff510000 {
+ 		compatible = "rockchip,rk3328-dw-mshc", "rockchip,rk3288-dw-mshc";
+ 		reg = <0x0 0xff510000 0x0 0x4000>;
+ 		interrupts = <GIC_SPI 13 IRQ_TYPE_LEVEL_HIGH>;
+@@ -850,7 +850,7 @@
+ 		status = "disabled";
+ 	};
+ 
+-	emmc: dwmmc@ff520000 {
++	emmc: mmc@ff520000 {
+ 		compatible = "rockchip,rk3328-dw-mshc", "rockchip,rk3288-dw-mshc";
+ 		reg = <0x0 0xff520000 0x0 0x4000>;
+ 		interrupts = <GIC_SPI 14 IRQ_TYPE_LEVEL_HIGH>;
+-- 
+cgit 1.2-0.3.lf.el7
+
diff --git a/target/linux/rockchip/patches-5.4/009-rk3328_add_sdmmc_ext_node.patch b/target/linux/rockchip/patches-5.4/009-rk3328_add_sdmmc_ext_node.patch
new file mode 100644
index 0000000000..829ff9014c
--- /dev/null
+++ b/target/linux/rockchip/patches-5.4/009-rk3328_add_sdmmc_ext_node.patch
@@ -0,0 +1,34 @@
+From 480b56effc7d96a1f87ee50e055ba2936fdad1f8 Mon Sep 17 00:00:00 2001
+From: Jonas Karlman <jonas@kwiboo.se>
+Date: Sun, 29 Dec 2019 22:14:02 +0000
+Subject: [PATCH] arm64: dts: rockchip: add sdmmc_ext node on rk3328
+
+---
+ arch/arm64/boot/dts/rockchip/rk3328.dtsi | 14 ++++++++++++++
+ 1 file changed, 14 insertions(+)
+
+diff --git a/arch/arm64/boot/dts/rockchip/rk3328.dtsi b/arch/arm64/boot/dts/rockchip/rk3328.dtsi
+index 3c50c11c2e5b..1c8057c7bcd3 100644
+--- a/arch/arm64/boot/dts/rockchip/rk3328.dtsi
++++ b/arch/arm64/boot/dts/rockchip/rk3328.dtsi
+@@ -987,6 +987,20 @@
+ 		};
+ 	};
+ 
++	sdmmc_ext: mmc@ff5f0000 {
++		compatible = "rockchip,rk3328-dw-mshc", "rockchip,rk3288-dw-mshc";
++		reg = <0x0 0xff5f0000 0x0 0x4000>;
++		interrupts = <GIC_SPI 4 IRQ_TYPE_LEVEL_HIGH>;
++		clocks = <&cru HCLK_SDMMC_EXT>, <&cru SCLK_SDMMC_EXT>,
++			 <&cru SCLK_SDMMC_EXT_DRV>, <&cru SCLK_SDMMC_EXT_SAMPLE>;
++		clock-names = "biu", "ciu", "ciu-drive", "ciu-sample";
++		fifo-depth = <0x100>;
++		max-frequency = <150000000>;
++		resets = <&cru SRST_SDMMCEXT>;
++		reset-names = "reset";
++		status = "disabled";
++	};
++
+ 	gic: interrupt-controller@ff811000 {
+ 		compatible = "arm,gic-400";
+ 		#interrupt-cells = <3>;
